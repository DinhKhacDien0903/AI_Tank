<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tank 1990 — Vanilla JS</title>
    <style>
        :root {
            --bg: #0b1220;
            --panel: #0f172a;
            --text: #e5e7eb;
            --muted: #94a3b8;
            --accent: #22c55e;
            --accent2: #6366f1;
            --danger: #ef4444;
            --steel: #38bdf8;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: linear-gradient(180deg, #0b1220, #0b3d2e);
            color: var(--text);
            font: 14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial
        }

        .wrap {
            max-width: 900px;
            margin: 24px auto;
            padding: 16px
        }

        h1 {
            font-size: 24px;
            margin: 0 0 12px
        }

        .hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: var(--panel);
            border: 1px solid #1f2937;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, .35)
        }

        .row {
            display: flex;
            gap: 16px;
            align-items: center
        }

        .pill {
            background: #1f2937;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px
        }

        .pill.steel {
            background: #0c4a6e
        }

        .frame {
            position: relative;
            margin-top: 12px;
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px
        }

        .board {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid #0f172a;
            box-shadow: 0 12px 32px rgba(0, 0, 0, .4)
        }

        canvas {
            display: block;
            width: 480px;
            height: 480px
        }

        .overlay {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, .6);
            gap: 12px;
            text-align: center
        }

        .overlay h2 {
            margin: 0;
            font-size: 28px
        }

        .btns {
            display: flex;
            gap: 10px
        }

        .btn {
            appearance: none;
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 700;
            cursor: pointer;
            transition: .2s transform, .2s opacity
        }

        .btn:active {
            transform: translateY(1px)
        }

        .btn.start {
            background: var(--accent);
            color: #001507
        }

        .btn.restart {
            background: var(--accent2);
            color: white
        }

        .muted {
            color: var(--muted)
        }

        .tips {
            font-size: 12px;
            color: var(--muted)
        }

        @media (min-width: 720px) {
            .frame {
                grid-template-columns: 480px 1fr;
                align-items: start
            }
        }

        .card {
            background: var(--panel);
            border: 1px solid #1f2937;
            border-radius: 16px;
            padding: 12px
        }
    </style>
</head>

<body>
    <div class="wrap">
        <h1>Tank 1990 — Single Level (Vanilla JS)</h1>
        <div class="hud">
            <div class="row">
                <span class="pill">Lives: <b id="uiLives">3</b></span>
                <span class="pill">HP: <b id="uiHP">3</b></span>
                <span class="pill">Power: <b id="uiPower">1</b></span>
                <span class="pill">Level: <b>1</b></span>
            </div>
            <div class="row">
                <span class="pill">Enemies Left: <b id="uiEnemies">20</b></span>
                <span class="pill">Score: <b id="uiScore">0</b></span>
                <span class="pill">Time: <b id="uiTime">3:00</b></span>
                <span id="uiBaseState" class="pill">Base: BRICK</span>
            </div>
        </div>

        <div class="frame">
            <div class="board">
                <canvas id="game" width="480" height="480"></canvas>
                <div id="overlay" class="overlay">
                    <p>Phím điều khiển: ← → ↑ ↓, bắn: Space</p>
                    <div class="btns">
                        <button id="btnStart" class="btn start">Start</button>
                    </div>
                </div>
            </div>

            <div class="card">
                <b>Luật chơi</b>
                <ul>
                    <li>Diệt 20 xe địch (10 Basic, 10 Armored) trong 3 phút.</li>
                    <li>Bảo vệ căn cứ đại bàng (2 lớp gạch). Shovel biến tường thành thép 20s và tự hồi phục.</li>
                    <li>Star tăng sức mạnh đạn +1 (tối đa 3). Mỗi vật phẩm +50 điểm.</li>
                    <li>Thua khi hết 3 mạng hoặc căn cứ bị phá. Hết giờ mà căn cứ còn & còn mạng ⇒ Thắng.</li>
                </ul>
                <p class="tips">Gợi ý: Chặn đường hẹp, tận dụng sông & bụi cây để áp sát!</p>
                <div class="btns" style="margin-top:8px">
                    <button id="btnRestart" class="btn restart" style="display:none">Restart</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function () {
            'use strict';
            // ===== Constants =====
            const TILE = 32, GRID = 15, W = TILE * GRID, H = TILE * GRID;
            const PLAY_SECONDS = 180; // 3 minutes
            const MAX_ACTIVE_ENEMIES = 4, TOTAL_BASIC = 10, TOTAL_ARMORED = 10;

            const DIRS = ["up", "down", "left", "right"];
            const rand = (n) => Math.floor(Math.random() * n);
            const choice = (arr) => arr[rand(arr.length)];
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

            // ===== DOM =====
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const uiLives = document.getElementById('uiLives');
            const uiHP = document.getElementById('uiHP');
            const uiPower = document.getElementById('uiPower');
            const uiEnemies = document.getElementById('uiEnemies');
            const uiScore = document.getElementById('uiScore');
            const uiTime = document.getElementById('uiTime');
            const uiBaseState = document.getElementById('uiBaseState');
            const overlay = document.getElementById('overlay');
            const btnStart = document.getElementById('btnStart');
            const btnRestart = document.getElementById('btnRestart');

            // ===== Game State =====
            const S = {
                map: [], // grid of tiles
                bushSet: new Set(),
                base: { gx: 7, gy: 13, alive: true },
                baseRings: [],
                tanks: [], // player + enemies
                bullets: [],
                keys: { up: false, down: false, left: false, right: false, shoot: false },
                running: false,
                spawn: { active: 0, basicLeft: TOTAL_BASIC, armoredLeft: TOTAL_ARMORED, totalSpawned: 0, cooldown: 1200, next: 0, preferred: null, points: [{ gx: 1, gy: 1 }, { gx: 7, gy: 1 }, { gx: 13, gy: 1 }] },
                items: [], // {kind:'star'|'shovel', x,y, expiresAt, active}
                itemPlan: { stars: [], shovels: [] },
                playerId: "",
                lastTime: 0, elapsed: 0, shovelUntil: 0,
                // UI mirrored
                lives: 3, playerHP: 3, playerPower: 1, enemiesRemaining: TOTAL_BASIC + TOTAL_ARMORED, score: 0, timeLeft: PLAY_SECONDS,
                status: 'menu' // 'menu'|'playing'|'won'|'lost'
            };

            function tile(type, hp) { return { type, hp } };
            function emptyMap() { const m = []; for (let y = 0; y < GRID; y++) { const r = []; for (let x = 0; x < GRID; x++) { r.push(tile('empty')); } m.push(r); } return m; }
            function within(x, y) { return x >= 0 && y >= 0 && x < GRID && y < GRID }
            function toPx(gx, gy) { return { x: gx * TILE + TILE / 2, y: gy * TILE + TILE / 2 } }
            function toGrid(px, py) { return { gx: Math.floor(px / TILE), gy: Math.floor(py / TILE) } }

            // ===== Map Setup =====
            function setupLevel() {
                S.map = emptyMap();
                S.bushSet = new Set();
                // Rivers
                [5, 9].forEach(rx => { for (let y = 3; y <= 11; y++) S.map[y][rx] = tile('river') });
                // Steel clusters
                [[2, 2], [12, 2], [2, 7], [12, 7], [2, 11], [12, 11]].forEach(([x, y]) => S.map[y][x] = tile('steel', 3));
                // Brick clusters
                [[4, 4], [10, 4], [4, 10], [10, 10], [7, 6], [7, 8]].forEach(([x, y]) => S.map[y][x] = tile('brick', 1));
                // Bush overlays
                [[3, 5], [11, 5], [3, 9], [11, 9], [7, 4], [7, 9]].forEach(([x, y]) => S.bushSet.add(`${x},${y}`));
                // Base
                S.base = { gx: 7, gy: 13, alive: true };
                S.map[S.base.gy][S.base.gx] = tile('base');
                S.baseRings = buildBaseRings(S.base.gx, S.base.gy);
                setBaseWalls('brick');
            }
            function buildBaseRings(cx, cy) {
                const coords = []; const add = (gx, gy) => { if (within(gx, gy) && !(gx === cx && gy === cy)) coords.push({ gx, gy }); };
                for (let y = cy - 1; y <= cy + 1; y++) { for (let x = cx - 1; x <= cx + 1; x++) { if (x === cx && y === cy) continue; add(x, y); } }
                for (let y = cy - 2; y <= cy + 2; y++) { for (let x = cx - 2; x <= cx + 2; x++) { const d = Math.max(Math.abs(x - cx), Math.abs(y - cy)); if (d === 2) add(x, y); } }
                return coords;
            }
            function setBaseWalls(mode) {
                for (const { gx, gy } of S.baseRings) { if (!within(gx, gy)) continue; S.map[gy][gx] = mode === 'steel' ? tile('steel', 3) : tile('brick', 1); }
                uiBaseState.textContent = 'Base: ' + (mode === 'steel' ? 'STEEL' : 'BRICK');
                uiBaseState.className = 'pill' + (mode === 'steel' ? ' steel' : '');
            }

            // ===== Tanks & Bullets =====
            function newPlayer() {
                const p = toPx(7, 10); // mới: ngay trên căn cứ nhưng ngoài tường
                return { id: 'P-' + Math.random().toString(36).slice(2), x: p.x, y: p.y, dir: 'up', speed: 100, size: TILE - 6, hp: 3, power: 1, cd: 400, last: 0, isPlayer: true, active: true, hasBullet: false };
            }

            function newEnemy(kind) {
                const sp = choice(S.spawn.points);
                let gx = sp.gx, gy = sp.gy, tries = 5; let pos = toPx(gx, gy);
                while (tries--) {
                    if (!blockedForTank(pos.x, pos.y, TILE - 6) && !overlapAnyTank(pos.x, pos.y, TILE - 6)) break;
                    const alt = choice(S.spawn.points); gx = alt.gx; gy = alt.gy; pos = toPx(gx, gy);
                }
                if (blockedForTank(pos.x, pos.y, TILE - 6)) return null;
                const armored = kind === 'armored';
                return { id: 'E-' + kind + '-' + Math.random().toString(36).slice(2), x: pos.x, y: pos.y, dir: 'down', speed: 80, size: TILE - 6, hp: armored ? 3 : 1, power: armored ? 2 : 1, cd: armored ? 600 : 800, last: 0, isPlayer: false, active: true, kind, ai: { next: performance.now() + 300, think: 500 }, hasBullet: false };
            }
            function blockedForTank(x, y, size) {
                const half = size / 2; const left = Math.floor((x - half) / TILE), right = Math.floor((x + half) / TILE), top = Math.floor((y - half) / TILE), bottom = Math.floor((y + half) / TILE);
                for (let gy = top; gy <= bottom; gy++) {
                    for (let gx = left; gx <= right; gx++) {
                        if (!within(gx, gy)) return true; const t = S.map[gy][gx];
                        if (t && (t.type === 'brick' || t.type === 'steel' || t.type === 'river' || t.type === 'base')) return true;
                    }
                }
                return false;
            }
            function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) { return Math.abs(ax - bx) * 2 < aw + bw && Math.abs(ay - by) * 2 < ah + bh }
            function overlapAnyTank(x, y, size) { return S.tanks.some(t => t.active && rectOverlap(x, y, size, size, t.x, t.y, t.size, t.size)); }

            function shoot(t) { const now = performance.now(); if (now - t.last < t.cd) return; if (t.hasBullet) return; const half = t.size / 2; let bx = t.x, by = t.y; const muzz = half + 6; if (t.dir === 'up') by -= muzz; if (t.dir === 'down') by += muzz; if (t.dir === 'left') bx -= muzz; if (t.dir === 'right') bx += muzz; S.bullets.push({ x: bx, y: by, dir: t.dir, speed: 320, power: t.power, owner: t.id, active: true }); t.last = now; t.hasBullet = true; }

            function damageTile(gx, gy, power) {
                const tile = S.map[gy][gx]; if (tile.type === 'brick' || tile.type === 'steel') { tile.hp = (tile.hp || (tile.type === 'brick' ? 1 : 3)) - power; if ((tile.hp || 0) <= 0) S.map[gy][gx] = { type: 'empty' }; }
                if (tile.type === 'base') { S.base.alive = false; endGame(false); }
            }

            function killTank(t) {
                t.active = false; if (t.isPlayer) { S.lives = Math.max(0, S.lives - 1); if (S.lives <= 0) { endGame(false); return; } const np = newPlayer(); S.playerId = np.id; replacePlayer(t, np); S.playerHP = np.hp; S.playerPower = np.power; }
                else { S.spawn.active = Math.max(0, S.spawn.active - 1); S.enemiesRemaining = Math.max(0, S.enemiesRemaining - 1); S.score += (t.kind === 'basic' ? 100 : 200); const key = (t.kind === 'basic') ? 'basicLeft' : 'armoredLeft'; if (S.spawn[key] > 0) S.spawn.preferred = t.kind; }
                syncUI();
            }
            function replacePlayer(oldT, np) { S.tanks = S.tanks.filter(z => z !== oldT); S.tanks.push(np); }

            // ===== Items =====
            function planItems() {
                const now = performance.now(); const plan = (count, minS, maxS) => { const a = []; for (let i = 0; i < count; i++) { a.push(now + (minS + Math.random() * (maxS - minS)) * 1000); } return a.sort((a, b) => a - b); };
                S.itemPlan.stars = plan(3, 10, PLAY_SECONDS - 10);
                S.itemPlan.shovels = plan(2, 15, PLAY_SECONDS - 15);
            }
            function spawnItem(kind) { let tries = 50; while (tries--) { const gx = rand(GRID), gy = rand(GRID); const t = S.map[gy][gx]; const key = `${gx},${gy}`; if (t.type === 'empty' && key !== `${S.base.gx},${S.base.gy}`) { const p = toPx(gx, gy); S.items.push({ kind, x: p.x, y: p.y, expiresAt: performance.now() + 12000, active: true }); break; } } }

            // ===== Game Flow =====
            function resetGame() {
                setupLevel();
                S.tanks = []; S.bullets = []; S.items = []; S.spawn = { active: 0, basicLeft: TOTAL_BASIC, armoredLeft: TOTAL_ARMORED, totalSpawned: 0, cooldown: 1200, next: 0, preferred: null, points: [{ gx: 1, gy: 1 }, { gx: 7, gy: 1 }, { gx: 13, gy: 1 }] };
                const p = newPlayer(); S.playerId = p.id; S.tanks.push(p);
                S.lives = 3; S.playerHP = 3; S.playerPower = 1; S.enemiesRemaining = TOTAL_BASIC + TOTAL_ARMORED; S.score = 0; S.timeLeft = PLAY_SECONDS; S.elapsed = 0; S.lastTime = 0; S.shovelUntil = 0; S.status = 'playing'; S.running = true;
                planItems();
                syncUI();
                overlay.style.display = 'none'; btnRestart.style.display = 'none';
            }
            function endGame(win) { if (!S.running) return; S.running = false; S.status = win ? 'won' : 'lost'; overlay.innerHTML = `<h2>${win ? 'YOU WIN' : 'GAME OVER'}</h2><p>Score: ${S.score}</p><div class="btns"><button class="btn restart" id="ovRestart">Restart</button></div>`; overlay.style.display = 'flex'; btnRestart.style.display = 'inline-block'; setTimeout(() => { const ov = document.getElementById('ovRestart'); if (ov) ov.onclick = () => resetGame(); }, 0); }

            function syncUI() { uiLives.textContent = S.lives; uiHP.textContent = getPlayer()?.hp ?? 0; uiPower.textContent = getPlayer()?.power ?? 1; uiEnemies.textContent = S.enemiesRemaining; uiScore.textContent = S.score; const mm = Math.floor(S.timeLeft / 60), ss = (S.timeLeft % 60).toString().padStart(2, '0'); uiTime.textContent = `${mm}:${ss}`; }

            function getPlayer() { return S.tanks.find(t => t.isPlayer && t.active); }

            // ===== Input =====
            window.addEventListener('keydown', e => { if (S.status !== 'playing') return; if (e.key === 'ArrowUp') { S.keys.up = true; e.preventDefault(); } else if (e.key === 'ArrowDown') { S.keys.down = true; e.preventDefault(); } else if (e.key === 'ArrowLeft') { S.keys.left = true; e.preventDefault(); } else if (e.key === 'ArrowRight') { S.keys.right = true; e.preventDefault(); } else if (e.key === ' ') { S.keys.shoot = true; e.preventDefault(); } });
            window.addEventListener('keyup', e => { if (e.key === 'ArrowUp') S.keys.up = false; else if (e.key === 'ArrowDown') S.keys.down = false; else if (e.key === 'ArrowLeft') S.keys.left = false; else if (e.key === 'ArrowRight') S.keys.right = false; else if (e.key === ' ') S.keys.shoot = false; });

            // ===== Loop =====
            function loop(now) {
                if (S.lastTime === 0) S.lastTime = now; const dt = (now - S.lastTime) / 1000; S.lastTime = now; if (S.status === 'playing' && S.running) {
                    S.elapsed += dt; const remain = Math.max(0, PLAY_SECONDS - Math.floor(S.elapsed)); if (remain !== S.timeLeft) { S.timeLeft = remain; syncUI(); }
                    if (remain <= 0) { if (S.base.alive && S.lives > 0) endGame(true); else endGame(false); }
                    update(dt, now); draw();
                } else { draw(); }
                requestAnimationFrame(loop);
            }

            function update(dt, now) { // Items schedule
                if (S.itemPlan.stars.length && now >= S.itemPlan.stars[0]) { S.itemPlan.stars.shift(); spawnItem('star'); }
                if (S.itemPlan.shovels.length && now >= S.itemPlan.shovels[0]) { S.itemPlan.shovels.shift(); spawnItem('shovel'); }
                // expire items
                for (const it of S.items) { if (it.active && it.expiresAt && now >= it.expiresAt) it.active = false; }
                // player pickup
                const pl = getPlayer(); if (pl) { for (const it of S.items) { if (!it.active) continue; if (rectOverlap(pl.x, pl.y, pl.size, pl.size, it.x, it.y, TILE, TILE)) { it.active = false; if (it.kind === 'star') { S.score += 50; pl.power = Math.min(3, pl.power + 1); S.playerPower = pl.power; } else { S.score += 50; setBaseWalls('steel'); S.shovelUntil = performance.now() + 20000; } syncUI(); } } }

                // shovel timer
                if (S.shovelUntil && now >= S.shovelUntil) { S.shovelUntil = 0; setBaseWalls('brick'); }

                // Spawning
                if (S.spawn.totalSpawned < TOTAL_BASIC + TOTAL_ARMORED && S.spawn.active < MAX_ACTIVE_ENEMIES && now >= S.spawn.next) {
                    let type = null; if (S.spawn.preferred && S.spawn[S.spawn.preferred === 'basic' ? 'basicLeft' : 'armoredLeft'] > 0) { type = S.spawn.preferred; S.spawn.preferred = null; }
                    else { const ops = []; if (S.spawn.basicLeft > 0) ops.push('basic'); if (S.spawn.armoredLeft > 0) ops.push('armored'); if (ops.length) type = choice(ops); }
                    if (type) { const e = newEnemy(type); if (e) { S.tanks.push(e); S.spawn.totalSpawned++; S.spawn.active++; if (type === 'basic') S.spawn.basicLeft--; else S.spawn.armoredLeft--; } S.spawn.next = performance.now() + S.spawn.cooldown; }
                }

                // Update player
                if (pl) { let dx = 0, dy = 0; if (S.keys.up) { dy -= 1; pl.dir = 'up'; } if (S.keys.down) { dy += 1; pl.dir = 'down'; } if (S.keys.left) { dx -= 1; pl.dir = 'left'; } if (S.keys.right) { dx += 1; pl.dir = 'right'; } const len = Math.hypot(dx, dy) || 1; const step = (pl.speed * dt) / len; tryMove(pl, dx * step, dy * step); if (S.keys.shoot) shoot(pl); }

                // Update enemies
                for (const t of S.tanks) {
                    if (!t.active || t.isPlayer) continue; if (now >= t.ai.next) { t.ai.next = now + t.ai.think; const pl = getPlayer(); if (pl && Math.random() < 0.6) { const pg = toGrid(pl.x, pl.y), eg = toGrid(t.x, t.y); if (pg.gx === eg.gx) t.dir = (pg.gy < eg.gy ? 'up' : 'down'); else if (pg.gy === eg.gy) t.dir = (pg.gx < eg.gx ? 'left' : 'right'); else if (Math.random() < 0.5) t.dir = (pg.gx < eg.gx ? 'left' : 'right'); else t.dir = (pg.gy < eg.gy ? 'up' : 'down'); } else if (Math.random() < 0.4) { t.dir = choice(DIRS); } if (Math.random() < 0.55) shoot(t); }
                    const step = t.speed * dt; const moved = tryMove(t, (t.dir === 'left' ? -step : (t.dir === 'right' ? step : 0)), (t.dir === 'up' ? -step : (t.dir === 'down' ? step : 0))); if (!moved) t.dir = choice(DIRS);
                }

                // Update bullets
                for (const b of S.bullets) {
                    if (!b.active) continue; const dist = b.speed * dt; if (b.dir === 'up') b.y -= dist; if (b.dir === 'down') b.y += dist; if (b.dir === 'left') b.x -= dist; if (b.dir === 'right') b.x += dist; if (b.x < 0 || b.y < 0 || b.x > W || b.y > H) { b.active = false; releaseOwner(b.owner); continue; } const g = toGrid(b.x, b.y); if (within(g.gx, g.gy)) { const tt = S.map[g.gy][g.gx]; if (tt.type === 'brick' || tt.type === 'steel' || tt.type === 'base') { damageTile(g.gx, g.gy, b.power); b.active = false; releaseOwner(b.owner); continue; } }
                    for (const t of S.tanks) { if (!t.active) continue; if (t.id === b.owner) continue; if (rectOverlap(b.x, b.y, 6, 6, t.x, t.y, t.size, t.size)) { t.hp -= b.power; b.active = false; releaseOwner(b.owner); if (t.hp <= 0) killTank(t); else if (t.isPlayer) { S.playerHP = t.hp; syncUI(); } break; } }
                }
            }

            function releaseOwner(id) { const o = S.tanks.find(t => t.id === id); if (o) o.hasBullet = false; }

            function tryMove(t, dx, dy) { if (!dx && !dy) return false; const nx = clamp(t.x + dx, t.size / 2, W - t.size / 2), ny = clamp(t.y + dy, t.size / 2, H - t.size / 2); if (blockedForTank(nx, ny, t.size)) return false; for (const o of S.tanks) { if (!o.active || o.id === t.id) continue; if (rectOverlap(nx, ny, t.size, t.size, o.x, o.y, o.size, o.size)) return false; } t.x = nx; t.y = ny; return true; }

            // ===== Render =====
            function roundRect(x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); }
            function drawStar(cx, cy, spikes, outer, inner) { let rot = Math.PI / 2 * 3, x = cx, y = cy; ctx.beginPath(); ctx.moveTo(cx, cy - outer); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outer; y = cy + Math.sin(rot) * outer; ctx.lineTo(x, y); rot += Math.PI / spikes; x = cx + Math.cos(rot) * inner; y = cy + Math.sin(rot) * inner; ctx.lineTo(x, y); rot += Math.PI / spikes; } ctx.lineTo(cx, cy - outer); ctx.closePath(); }
            function draw() {
                ctx.clearRect(0, 0, W, H); ctx.fillStyle = '#0b3d2e'; ctx.fillRect(0, 0, W, H);
                for (let gy = 0; gy < GRID; gy++) {
                    for (let gx = 0; gx < GRID; gx++) {
                        const t = S.map[gy][gx]; const x = gx * TILE, y = gy * TILE;
                        if (t.type === 'empty') { if (((gx + gy) & 1) === 0) { ctx.globalAlpha = .05; ctx.fillStyle = '#fff'; ctx.fillRect(x, y, TILE, TILE); ctx.globalAlpha = 1; } }
                        else if (t.type === 'brick') { ctx.fillStyle = '#b55239'; ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4); ctx.strokeStyle = '#8a3f2b'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(x + 2, y + TILE / 2); ctx.lineTo(x + TILE - 2, y + TILE / 2); ctx.moveTo(x + TILE / 2, y + 2); ctx.lineTo(x + TILE / 2, y + TILE - 2); ctx.stroke(); }
                        else if (t.type === 'steel') { ctx.fillStyle = '#9aa3ad'; roundRect(x + 2, y + 2, TILE - 4, TILE - 4, 4); ctx.fill(); ctx.strokeStyle = '#6b7680'; ctx.lineWidth = 2; ctx.stroke(); }
                        else if (t.type === 'river') { ctx.fillStyle = '#2aa1d3'; ctx.fillRect(x, y, TILE, TILE); ctx.globalAlpha = .35; ctx.fillStyle = '#bfe7fa'; ctx.fillRect(x, y + 10, TILE, 4); ctx.fillRect(x, y + 20, TILE, 3); ctx.globalAlpha = 1; }
                        else if (t.type === 'base') { ctx.fillStyle = S.base.alive ? '#ffd54d' : '#333'; roundRect(x + 6, y + 6, TILE - 12, TILE - 12, 6); ctx.fill(); ctx.strokeStyle = '#8a6a1f'; ctx.lineWidth = 2; ctx.stroke(); }
                    }
                }
                // items
                for (const it of S.items) { if (!it.active) continue; const x = it.x - TILE / 2, y = it.y - TILE / 2; if (it.kind === 'star') { ctx.fillStyle = '#ffd700'; drawStar(it.x, it.y, 5, TILE / 2 - 4, 6); ctx.fill(); ctx.strokeStyle = '#9e7b00'; ctx.lineWidth = 2; ctx.stroke(); } else { ctx.fillStyle = '#c0c0c0'; roundRect(x + 4, y + 4, TILE - 8, (TILE - 8) * .55, 6); ctx.fill(); ctx.fillStyle = '#9a9a9a'; ctx.fillRect(x + (TILE - 8) * .46, y + 4 + (TILE - 8) * .55, (TILE - 8) * .08, (TILE - 8) * .4); } }
                // bullets
                for (const b of S.bullets) { if (!b.active) continue; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(b.x, b.y, 3, 0, Math.PI * 2); ctx.fill(); }
                // tanks
                for (const t of S.tanks) { if (!t.active) continue; const x = t.x - t.size / 2, y = t.y - t.size / 2; ctx.fillStyle = t.isPlayer ? '#66ff66' : (t.kind === 'armored' ? '#ff6b6b' : '#f0ad4e'); roundRect(x, y, t.size, t.size, 6); ctx.fill(); ctx.fillStyle = '#333'; const barrel = 10; if (t.dir === 'up') ctx.fillRect(t.x - 3, y - 6, 6, barrel); if (t.dir === 'down') ctx.fillRect(t.x - 3, y + t.size - barrel + 6, 6, barrel); if (t.dir === 'left') ctx.fillRect(x - 6, t.y - 3, barrel, 6); if (t.dir === 'right') ctx.fillRect(x + t.size - barrel + 6, t.y - 3, barrel, 6); ctx.fillStyle = '#000'; for (let i = 0; i < t.hp; i++) ctx.fillRect(x + 4 + i * 6, y + t.size - 10, 4, 6); }
                // bushes on top
                for (const key of S.bushSet) { const [gx, gy] = key.split(',').map(Number); const x = gx * TILE, y = gy * TILE; ctx.fillStyle = '#3fa34d'; roundRect(x + 2, y + 2, TILE - 4, TILE - 4, 6); ctx.fill(); ctx.globalAlpha = .25; ctx.fillStyle = '#fff'; ctx.fillRect(x + 6, y + 6, TILE - 12, TILE - 12); ctx.globalAlpha = 1; }
                if (S.status === 'won' || S.status === 'lost') { /* overlay already shows text */ }
            }

            // ===== Buttons =====
            btnStart.onclick = () => resetGame();
            btnRestart.onclick = () => resetGame();

            // Pre-draw map for menu
            setupLevel(); draw();
            requestAnimationFrame(loop);
        })();
    </script>
</body>

</html>