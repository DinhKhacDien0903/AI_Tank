<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>81 ng√†y ƒë√™m b·∫£o v·ªá th√†nh c·ªï Qu·∫£ng Tr·ªã</title>
    <style>
      :root {
        --bg: #0b1220;
        --panel: #0f172a;
        --text: #e5e7eb;
        --muted: #94a3b8;
        --accent: #22c55e;
        --accent2: #6366f1;
        --danger: #ef4444;
        --steel: #38bdf8;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: linear-gradient(180deg, #0b1220, #0b3d2e);
        color: var(--text);
        font: 14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial;
      }

      .wrap {
        max-width: 900px;
        margin: 24px auto;
        padding: 16px;
      }

      h1 {
        font-size: 24px;
        margin: 0 0 12px;
      }

      .hud {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: var(--panel);
        border: 1px solid #1f2937;
        border-radius: 16px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }

      .row {
        display: flex;
        gap: 16px;
        align-items: center;
      }

      .pill {
        background: #1f2937;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
      }
      .pill.btn {
        cursor: pointer;
        user-select: none;
      }
      .pill.off {
        background: #374151;
      }
      /* slider trong pill √¢m l∆∞·ª£ng */
      #uiVol input[type="range"] {
        width: 120px;
        accent-color: var(--accent2);
        vertical-align: middle;
      }
      #uiVol.off input[type="range"] {
        opacity: 0.5;
        pointer-events: none;
      }

      .pill.steel {
        background: #0c4a6e;
      }

      .frame {
        position: relative;
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .board {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid #0f172a;
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4);
      }

      canvas {
        display: block;
        width: 480px;
        height: 480px;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        gap: 12px;
        text-align: center;
      }

      .overlay h2 {
        margin: 0;
        font-size: 28px;
      }

      .btns {
        display: flex;
        gap: 10px;
      }

      .btn {
        appearance: none;
        border: none;
        border-radius: 12px;
        padding: 10px 14px;
        font-weight: 700;
        cursor: pointer;
        transition: 0.2s transform, 0.2s opacity;
      }

      .btn:active {
        transform: translateY(1px);
      }

      .btn.start {
        background: var(--accent);
        color: #001507;
      }

      .btn.restart {
        background: var(--accent2);
        color: white;
      }

      .muted {
        color: var(--muted);
      }

      .tips {
        font-size: 12px;
        color: var(--muted);
      }

      @media (min-width: 720px) {
        .frame {
          grid-template-columns: 480px 1fr;
          align-items: start;
        }
      }

      .card {
        background: var(--panel);
        border: 1px solid #1f2937;
        border-radius: 16px;
        padding: 12px;
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>Tank 1990 ‚Äî Single Level (Vanilla JS)</h1>
      <div class="hud">
        <div class="row">
          <span class="pill">Lives: <b id="uiLives">3</b></span>
          <span class="pill">HP: <b id="uiHP">3</b></span>
          <span class="pill">Power: <b id="uiPower">1</b></span>
          <span class="pill">Level: <b>1</b></span>
        </div>
        <div class="row">
          <span class="pill">Enemies Left: <b id="uiEnemies">20</b></span>
          <span class="pill">Score: <b id="uiScore">0</b></span>
          <span class="pill">Time: <b id="uiTime">3:00</b></span>
          <span id="uiBaseState" class="pill">Base: BRICK</span>
          <span id="uiSound" class="pill" role="button" tabindex="0"
            >üîä Sound: ON</span
          >
          <span id="uiVol" class="pill">
            Vol:
            <input
              id="uiVolSlider"
              type="range"
              min="0"
              max="100"
              value="25"
              style="vertical-align: middle; width: 100px"
            />
          </span>
        </div>
      </div>

      <div class="frame">
        <div class="board">
          <canvas id="game" width="480" height="480"></canvas>
          <div id="overlay" class="overlay">
            <p>Ph√≠m ƒëi·ªÅu khi·ªÉn: ‚Üê ‚Üí ‚Üë ‚Üì, b·∫Øn: Space</p>
            <div class="btns">
              <button id="btnStart" class="btn start">Start</button>
            </div>
          </div>
        </div>

        <div class="card">
          <b>Lu·∫≠t ch∆°i</b>
          <ul>
            <li>Di·ªát 20 xe ƒë·ªãch (10 Basic, 10 Armored) trong 3 ph√∫t.</li>
            <li>
              B·∫£o v·ªá cƒÉn c·ª© ƒë·∫°i b√†ng (2 l·ªõp g·∫°ch). Shovel bi·∫øn t∆∞·ªùng th√†nh th√©p
              20s v√† t·ª± h·ªìi ph·ª•c.
            </li>
            <li>
              Star tƒÉng s·ª©c m·∫°nh ƒë·∫°n +1 (t·ªëi ƒëa 3). M·ªói v·∫≠t ph·∫©m +50 ƒëi·ªÉm.
            </li>
            <li>
              Thua khi h·∫øt 3 m·∫°ng ho·∫∑c cƒÉn c·ª© b·ªã ph√°. H·∫øt gi·ªù m√† cƒÉn c·ª© c√≤n &
              c√≤n m·∫°ng ‚áí Th·∫Øng.
            </li>
          </ul>
          <p class="tips">
            G·ª£i √Ω: Ch·∫∑n ƒë∆∞·ªùng h·∫πp, t·∫≠n d·ª•ng s√¥ng & b·ª•i c√¢y ƒë·ªÉ √°p s√°t!
          </p>
          <div class="btns" style="margin-top: 8px">
            <button id="btnRestart" class="btn restart" style="display: none">
              Restart
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        "use strict";
        // ===== Constants =====
        const TILE = 32,
          GRID = 15,
          W = TILE * GRID,
          H = TILE * GRID;
        const PLAY_SECONDS = 180; // 3 minutes
        const MAX_ACTIVE_ENEMIES = 4,
          TOTAL_BASIC = 10,
          TOTAL_ARMORED = 10;
        const DEV_GOD_MODE = true; // <- b·∫≠t/t·∫Øt b·∫•t t·ª≠ cho ng∆∞·ªùi ch∆°i
        // ===== Vietnam scheme colors =====
        const VN_COL = {
          green: "#2d4b2b", // olive green
          green2: "#3a5b37", // nh·∫°t h∆°n 1 ch√∫t cho m·∫£ng r·∫±n ri
          dark: "#1d3320", // vi·ªÅn t·ªëi
          star: "#ffd34d", // v√†ng ng√¥i sao
          flagR: "#d62828", // ƒë·ªè c·ªù
        };

        // ===== Sound toggle helpers =====
        function loadSoundPref() {
          try {
            const saved = localStorage.getItem("soundEnabled");
            if (saved !== null) AUDIO.enabled = saved === "1";
          } catch (e) {}
        }
        function saveSoundPref() {
          try {
            localStorage.setItem("soundEnabled", AUDIO.enabled ? "1" : "0");
          } catch (e) {}
        }
        function updateSoundUI() {
          if (!btnSound) return;
          btnSound.textContent = AUDIO.enabled
            ? "üîä Sound: ON"
            : "üîá Sound: OFF";
          btnSound.className = "pill" + (AUDIO.enabled ? "" : " off");
          updateVolumeUI && updateVolumeUI();
        }
        // ===== Smoke helpers =====
        // ===== Smoke helpers (player-only, realistic) =====
        // H·∫°t kh√≥i: l·ªõn d·∫ßn, bay ng∆∞·ª£c h∆∞·ªõng xe + n·ªïi l√™n (buoyancy).
        // M·ªói h·∫°t c√≥ 2‚Äì3 l·ªõp m√†u ƒë·ªÉ nh√¨n ‚Äúm·ªÅm‚Äù h∆°n.
        function spawnPlayerSmoke(tank) {
          // 2 ·ªëng x·∫£ ·ªü cu·ªëi th√¢n, l·ªách 2 b√™n
          const back = tank.size * 0.38; // l√πi v·ªÅ ph√≠a sau th√°p/xe
          const offset = tank.size * 0.18; // l·ªách tr√°i/ph·∫£i
          const spots = [];

          if (tank.dir === "up") {
            spots.push({ x: tank.x - offset, y: tank.y + back });
            spots.push({ x: tank.x + offset, y: tank.y + back });
          } else if (tank.dir === "down") {
            spots.push({ x: tank.x - offset, y: tank.y - back });
            spots.push({ x: tank.x + offset, y: tank.y - back });
          } else if (tank.dir === "left") {
            spots.push({ x: tank.x + back, y: tank.y - offset });
            spots.push({ x: tank.x + back, y: tank.y + offset });
          } else {
            // right
            spots.push({ x: tank.x - back, y: tank.y - offset });
            spots.push({ x: tank.x - back, y: tank.y + offset });
          }

          // h∆∞·ªõng kh√≥i b·∫Øn ra theo chi·ªÅu ng∆∞·ª£c c·ªßa xe + nhi·ªÖu nh·∫π
          for (const sp of spots) {
            // Gi·∫£m th·ªùi gian t·ªìn t·∫°i: ~0.30‚Äì0.50s (tr∆∞·ªõc ~0.55‚Äì0.8s)
            const life = 0.3 + Math.random() * 0.2;
            const baseSpeed = 26 + Math.random() * 10;
            let vx = 0,
              vy = 0;
            if (tank.dir === "up") {
              vx = (Math.random() - 0.5) * 10;
              vy = baseSpeed;
            }
            if (tank.dir === "down") {
              vx = (Math.random() - 0.5) * 10;
              vy = -baseSpeed;
            }
            if (tank.dir === "left") {
              vx = baseSpeed;
              vy = (Math.random() - 0.5) * 10;
            }
            if (tank.dir === "right") {
              vx = -baseSpeed;
              vy = (Math.random() - 0.5) * 10;
            }

            S.smokes.push({
              x: sp.x,
              y: sp.y,
              vx,
              vy,
              ax: (Math.random() - 0.5) * 3.2, // nhi·ªÖu ngang nh·∫π h∆°n ch√∫t
              ay: -18, // n·ªïi l√™n
              life,
              max: life,
              // Thu h·∫πp b√°n k√≠nh & t·ªëc ƒë·ªô n·ªü
              r: 1.8 + Math.random() * 1.2, // tr∆∞·ªõc: 3‚Äì5
              grow: 8 + Math.random() * 6, // tr∆∞·ªõc: 16‚Äì26
              layers: 3,
              // M√†u x√°m nh·∫π h∆°n (kh√¥ng c√≤n ƒëen s·∫´m)
              c0: "rgba(70,70,70,",
              c1: "rgba(160,165,170,",
              c2: "rgba(220,225,230,",
            });
          }
        }

        function updateSmokes(dt) {
          for (let i = S.smokes.length - 1; i >= 0; i--) {
            const s = S.smokes[i];
            s.life -= dt;
            // v·∫≠n t·ªëc + n·ªïi l√™n
            s.vx += s.ax * dt;
            s.vy += s.ay * dt;
            s.x += s.vx * dt;
            s.y += s.vy * dt;
            s.r += s.grow * dt; // l·ªõn d·∫ßn
            // gi·∫£m nhi·ªÖu theo th·ªùi gian
            s.ax *= 1 - 1.8 * dt;
            if (s.life <= 0) S.smokes.splice(i, 1);
          }
        }

        // ===== Volume helpers =====
        function getSavedVolume() {
          try {
            const s = localStorage.getItem("soundVolume");
            if (s !== null) {
              const v = parseFloat(s);
              if (!isNaN(v)) return Math.max(0, Math.min(1, v));
            }
          } catch (e) {}
          return null; // ch∆∞a c√≥ -> d√πng m·∫∑c ƒë·ªãnh
        }
        function loadVolumePref() {
          // ƒë·∫∑t slider theo pref (n·∫øu c√≥)
          const v = getSavedVolume();
          if (volSlider) {
            const use = v != null ? v : 0.25;
            volSlider.value = Math.round(use * 100);
          }
          return v;
        }
        function saveVolumePref(v) {
          // v: 0..1
          try {
            localStorage.setItem("soundVolume", String(v));
          } catch (e) {}
        }
        function updateVolumeUI() {
          // t·∫Øt/kh√≥a slider n·∫øu Sound OFF
          if (!volWrap || !volSlider) return;
          if (AUDIO.enabled) {
            volWrap.classList.remove("off");
            volSlider.disabled = false;
          } else {
            volWrap.classList.add("off");
            volSlider.disabled = true;
          }
        }

        // ===== AUDIO (Web Audio API) =====
        let AUDIO = {
          ctx: null,
          master: null,
          enabled: true,
        };

        function ensureAudio() {
          if (AUDIO.ctx) return;
          AUDIO.ctx = new (window.AudioContext || window.webkitAudioContext)();
          AUDIO.master = AUDIO.ctx.createGain();
          const savedVol = getSavedVolume();
          AUDIO.master.gain.value = savedVol != null ? savedVol : 0.25; // set theo pref
          AUDIO.master.connect(AUDIO.ctx.destination);
          // ƒë·ªìng b·ªô UI (n·∫øu slider ƒë√£ render)
          if (volSlider)
            volSlider.value = Math.round(AUDIO.master.gain.value * 100);
          updateVolumeUI && updateVolumeUI();
        }

        // node ti·ªán l·ª£i
        function gain(v = 1) {
          const g = AUDIO.ctx.createGain();
          g.gain.value = v;
          g.connect(AUDIO.master);
          return g;
        }

        // noise burst
        function noise(duration = 0.2, vol = 1, lpFreq = 2000) {
          const sr = AUDIO.ctx.sampleRate;
          const buffer = AUDIO.ctx.createBuffer(1, sr * duration, sr);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++)
            data[i] = (Math.random() * 2 - 1) * 0.9;
          const src = AUDIO.ctx.createBufferSource();
          src.buffer = buffer;

          // l·ªçc lowpass cho ƒë·ª° ch√≥i
          const lp = AUDIO.ctx.createBiquadFilter();
          lp.type = "lowpass";
          lp.frequency.value = lpFreq;

          const g = gain(vol);
          src.connect(lp);
          lp.connect(g);

          src.start();
          return g; // tr·∫£ gain ƒë·ªÉ c√≥ th·ªÉ envelope
        }

        function tone(type = "square", freq = 440, duration = 0.12, vol = 0.8) {
          const o = AUDIO.ctx.createOscillator();
          const g = gain(vol);
          o.type = type;
          o.frequency.setValueAtTime(freq, AUDIO.ctx.currentTime);
          o.connect(g);
          o.start();
          o.stop(AUDIO.ctx.currentTime + duration);
          return g;
        }

        // ti·ªán: v·∫Ω envelope nhanh
        function env(g, a = 0.005, d = 0.15) {
          const t = AUDIO.ctx.currentTime;
          g.gain.cancelScheduledValues(t);
          g.gain.setValueAtTime(0.0001, t);
          g.gain.linearRampToValueAtTime(g.gain.value || 1, t + a);
          g.gain.exponentialRampToValueAtTime(0.0001, t + a + d);
        }

        // SFX theo t√™n
        function playSfx(name) {
          if (!AUDIO.enabled || !AUDIO.ctx) return;

          switch (name) {
            case "shoot": {
              // beep ng·∫Øn c√≥ pitch l√™n nh·∫π
              const g = tone("square", 800, 0.08, 0.6);
              env(g, 0.002, 0.08);
              break;
            }
            case "shoot_enemy": {
              const g = tone("square", 700, 0.06, 0.35);
              env(g, 0.002, 0.06);
              break;
            }
            case "explode_wall": {
              const g = noise(0.18, 0.6, 1800);
              env(g, 0.005, 0.16);
              break;
            }
            case "explode_tank": {
              const g = noise(0.28, 0.8, 2400);
              env(g, 0.006, 0.24);
              // th√™m sub boom
              const sub = tone("sine", 90, 0.22, 0.4);
              env(sub, 0.003, 0.2);
              break;
            }
            case "base_destroyed": {
              // ti·∫øng r∆°i pitch + noise
              const o = AUDIO.ctx.createOscillator();
              const g = gain(0.8);
              o.type = "sawtooth";
              const t = AUDIO.ctx.currentTime;
              o.frequency.setValueAtTime(600, t);
              o.frequency.exponentialRampToValueAtTime(70, t + 0.6);
              o.connect(g);
              o.start(t);
              o.stop(t + 0.6);
              env(g, 0.005, 0.6);
              const n = noise(0.35, 0.7, 1800);
              env(n, 0.01, 0.3);
              break;
            }
            case "win": {
              // arpeggio ng·∫Øn
              const base = 523.25; // C5
              [1, 1.25, 1.5, 2].forEach((m, i) => {
                const when = AUDIO.ctx.currentTime + i * 0.09;
                const o = AUDIO.ctx.createOscillator();
                o.type = "triangle";
                o.frequency.setValueAtTime(base * m, when);
                const g = gain(0.6);
                o.connect(g);
                o.start(when);
                o.stop(when + 0.16);
                // envelope th·ªß c√¥ng
                g.gain.setValueAtTime(0.0001, when);
                g.gain.linearRampToValueAtTime(0.7, when + 0.02);
                g.gain.exponentialRampToValueAtTime(0.0001, when + 0.16);
              });
              break;
            }
            case "lose": {
              const o = AUDIO.ctx.createOscillator();
              const g = gain(0.7);
              o.type = "square";
              const t = AUDIO.ctx.currentTime;
              o.frequency.setValueAtTime(220, t);
              o.frequency.exponentialRampToValueAtTime(90, t + 0.5);
              o.connect(g);
              o.start(t);
              o.stop(t + 0.5);
              env(g, 0.005, 0.5);
              break;
            }
          }
        }

        const DIRS = ["up", "down", "left", "right"];
        const rand = (n) => Math.floor(Math.random() * n);
        const choice = (arr) => arr[rand(arr.length)];
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

        // ===== DOM =====
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const uiLives = document.getElementById("uiLives");
        const uiHP = document.getElementById("uiHP");
        const uiPower = document.getElementById("uiPower");
        const uiEnemies = document.getElementById("uiEnemies");
        const uiScore = document.getElementById("uiScore");
        const uiTime = document.getElementById("uiTime");
        const uiBaseState = document.getElementById("uiBaseState");
        const overlay = document.getElementById("overlay");
        const btnStart = document.getElementById("btnStart");
        const btnRestart = document.getElementById("btnRestart");
        const btnSound = document.getElementById("uiSound");
        const volWrap = document.getElementById("uiVol");
        const volSlider = document.getElementById("uiVolSlider");

        // ===== Game State =====
        const S = {
          map: [], // grid of tiles
          explosions: [], // danh s√°ch hi·ªáu ·ª©ng n·ªï
          smokes: [],
          bushSet: new Set(),
          base: { gx: 7, gy: 13, alive: true },
          baseRings: [],
          tanks: [], // player + enemies
          bullets: [],
          keys: {
            up: false,
            down: false,
            left: false,
            right: false,
            shoot: false,
          },
          running: false,
          spawn: {
            active: 0,
            basicLeft: TOTAL_BASIC,
            armoredLeft: TOTAL_ARMORED,
            totalSpawned: 0,
            cooldown: 1200,
            next: 0,
            preferred: null,
            points: [
              { gx: 1, gy: 1 },
              { gx: 7, gy: 1 },
              { gx: 13, gy: 1 },
            ],
          },
          items: [], // {kind:'star'|'shovel', x,y, expiresAt, active}
          itemPlan: { stars: [], shovels: [] },
          playerId: "",
          lastTime: 0,
          elapsed: 0,
          shovelUntil: 0,
          // UI mirrored
          lives: 3,
          playerHP: 3,
          playerPower: 1,
          enemiesRemaining: TOTAL_BASIC + TOTAL_ARMORED,
          score: 0,
          timeLeft: PLAY_SECONDS,
          status: "menu", // 'menu'|'playing'|'won'|'lost'
        };

        function tile(type, hp) {
          return { type, hp };
        }
        function emptyMap() {
          const m = [];
          for (let y = 0; y < GRID; y++) {
            const r = [];
            for (let x = 0; x < GRID; x++) {
              r.push(tile("empty"));
            }
            m.push(r);
          }
          return m;
        }
        function within(x, y) {
          return x >= 0 && y >= 0 && x < GRID && y < GRID;
        }
        function toPx(gx, gy) {
          return { x: gx * TILE + TILE / 2, y: gy * TILE + TILE / 2 };
        }
        function toGrid(px, py) {
          return { gx: Math.floor(px / TILE), gy: Math.floor(py / TILE) };
        }

        // ===== Map Setup =====
        function setupLevel() {
          S.map = emptyMap();
          S.bushSet = new Set();
          // Rivers
          [5, 9].forEach((rx) => {
            for (let y = 3; y <= 11; y++) S.map[y][rx] = tile("river");
          });
          // Steel clusters
          [
            [2, 2],
            [12, 2],
            [2, 7],
            [12, 7],
            [2, 11],
            [12, 11],
          ].forEach(([x, y]) => (S.map[y][x] = tile("steel", 3)));
          // Brick clusters
          [
            [4, 4],
            [10, 4],
            [4, 10],
            [10, 10],
            [7, 6],
            [7, 8],
          ].forEach(([x, y]) => (S.map[y][x] = tile("brick", 1)));
          // Bush overlays
          [
            [3, 5],
            [11, 5],
            [3, 9],
            [11, 9],
            [7, 4],
            [7, 9],
          ].forEach(([x, y]) => S.bushSet.add(`${x},${y}`));
          // Base
          S.base = { gx: 7, gy: 13, alive: true };
          S.map[S.base.gy][S.base.gx] = tile("base");
          S.baseRings = buildBaseRings(S.base.gx, S.base.gy);
          setBaseWalls("brick");
        }
        function buildBaseRings(cx, cy) {
          const coords = [];
          const add = (gx, gy) => {
            if (within(gx, gy) && !(gx === cx && gy === cy))
              coords.push({ gx, gy });
          };
          for (let y = cy - 1; y <= cy + 1; y++) {
            for (let x = cx - 1; x <= cx + 1; x++) {
              if (x === cx && y === cy) continue;
              add(x, y);
            }
          }
          for (let y = cy - 2; y <= cy + 2; y++) {
            for (let x = cx - 2; x <= cx + 2; x++) {
              const d = Math.max(Math.abs(x - cx), Math.abs(y - cy));
              if (d === 2) add(x, y);
            }
          }
          return coords;
        }
        function setBaseWalls(mode) {
          for (const { gx, gy } of S.baseRings) {
            if (!within(gx, gy)) continue;
            S.map[gy][gx] =
              mode === "steel" ? tile("steel", 3) : tile("brick", 1);
          }
          uiBaseState.textContent =
            "Base: " + (mode === "steel" ? "STEEL" : "BRICK");
          uiBaseState.className = "pill" + (mode === "steel" ? " steel" : "");
        }

        // ===== Tanks & Bullets =====
        function newPlayer() {
          const p = toPx(7, 10); // m·ªõi: ngay tr√™n cƒÉn c·ª© nh∆∞ng ngo√†i t∆∞·ªùng
          return {
            id: "P-" + Math.random().toString(36).slice(2),
            x: p.x,
            y: p.y,
            dir: "up",
            speed: 100,
            size: TILE - 6,
            hp: 3,
            power: 1,
            cd: 320,
            last: 0,
            isPlayer: true,
            active: true,
            hasBullet: false,
            trackPhase: 0, // pha x√≠ch (0..1)
            trackOn: false, // c√≥ ƒëang ch·∫°y kh√¥ng
            _smokeTimer: 0,
          };
        }

        function newEnemy(kind) {
          const sp = choice(S.spawn.points);
          let gx = sp.gx,
            gy = sp.gy,
            tries = 5;
          let pos = toPx(gx, gy);
          while (tries--) {
            if (
              !blockedForTank(pos.x, pos.y, TILE - 6) &&
              !overlapAnyTank(pos.x, pos.y, TILE - 6)
            )
              break;
            const alt = choice(S.spawn.points);
            gx = alt.gx;
            gy = alt.gy;
            pos = toPx(gx, gy);
          }
          if (blockedForTank(pos.x, pos.y, TILE - 6)) return null;
          const armored = kind === "armored";
          return {
            id: "E-" + kind + "-" + Math.random().toString(36).slice(2),
            x: pos.x,
            y: pos.y,
            dir: "down",
            speed: 80,
            size: TILE - 6,
            hp: armored ? 3 : 1,
            power: armored ? 2 : 1,
            cd: armored ? 600 : 800,
            last: 0,
            isPlayer: false,
            active: true,
            kind,
            ai: { next: performance.now() + 300, think: 500 },
            hasBullet: false,
            trackPhase: 0,
            trackOn: false,
          };
        }
        function blockedForTank(x, y, size) {
          const half = size / 2;
          const left = Math.floor((x - half) / TILE),
            right = Math.floor((x + half) / TILE),
            top = Math.floor((y - half) / TILE),
            bottom = Math.floor((y + half) / TILE);
          for (let gy = top; gy <= bottom; gy++) {
            for (let gx = left; gx <= right; gx++) {
              if (!within(gx, gy)) return true;
              const t = S.map[gy][gx];
              if (
                t &&
                (t.type === "brick" ||
                  t.type === "steel" ||
                  t.type === "river" ||
                  t.type === "base")
              )
                return true;
            }
          }
          return false;
        }
        function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
          return (
            Math.abs(ax - bx) * 2 < aw + bw && Math.abs(ay - by) * 2 < ah + bh
          );
        }
        function overlapAnyTank(x, y, size) {
          return S.tanks.some(
            (t) =>
              t.active &&
              rectOverlap(x, y, size, size, t.x, t.y, t.size, t.size)
          );
        }

        function shoot(t) {
          const now = performance.now();
          if (now - t.last < t.cd) return;
          if (t.hasBullet) return;
          const half = t.size / 2;
          let bx = t.x,
            by = t.y;
          const muzz = half + 6;
          if (t.dir === "up") by -= muzz;
          if (t.dir === "down") by += muzz;
          if (t.dir === "left") bx -= muzz;
          if (t.dir === "right") bx += muzz;
          S.bullets.push({
            x: bx,
            y: by,
            dir: t.dir,
            speed: 320,
            power: t.power,
            owner: t.id,
            active: true,
          });
          t.last = now;
          t.hasBullet = true;
          if (t.isPlayer) playSfx("shoot");
          else playSfx("shoot_enemy");
        }

        function damageTile(gx, gy, power) {
          const tile = S.map[gy][gx];
          if (tile.type === "brick" || tile.type === "steel") {
            tile.hp = (tile.hp || (tile.type === "brick" ? 1 : 3)) - power;
            if ((tile.hp || 0) <= 0) {
              S.map[gy][gx] = { type: "empty" };
              const c = toPx(gx, gy);
              spawnExplosion(c.x, c.y, false);
              try {
                playSfx("explode_wall");
              } catch (e) {}
            }
          }
          if (tile.type === "base") {
            S.base.alive = false;
            const c = toPx(gx, gy);
            spawnExplosion(c.x, c.y, true);
            try {
              playSfx("base_destroyed");
            } catch (e) {}
            endGame(false);
          }
        }

        function killTank(t) {
          t.active = false;
          try {
            playSfx("explode_tank");
          } catch (e) {}
          //   if (t.isPlayer) {
          //     S.lives = Math.max(0, S.lives - 1);
          //     if (S.lives <= 0) {
          //       endGame(false);
          //       return;
          //     }
          //     const np = newPlayer();
          //     S.playerId = np.id;
          //     replacePlayer(t, np);
          //     S.playerHP = np.hp;
          //     S.playerPower = np.power;

          //TODO: b·∫•t t·ª≠
          if (t.isPlayer) {
            // Player b·∫•t t·ª≠: kh√¥ng tr·ª´ m·∫°ng, kh√¥ng respawn
            t.active = true;
            return;
          } else {
            S.spawn.active = Math.max(0, S.spawn.active - 1);
            S.enemiesRemaining = Math.max(0, S.enemiesRemaining - 1);
            S.score += t.kind === "basic" ? 100 : 200;
            const key = t.kind === "basic" ? "basicLeft" : "armoredLeft";
            if (S.spawn[key] > 0) S.spawn.preferred = t.kind;
          }
          syncUI();
        }
        function replacePlayer(oldT, np) {
          S.tanks = S.tanks.filter((z) => z !== oldT);
          S.tanks.push(np);
        }

        // ===== Items =====
        function planItems() {
          const now = performance.now();
          const plan = (count, minS, maxS) => {
            const a = [];
            for (let i = 0; i < count; i++) {
              a.push(now + (minS + Math.random() * (maxS - minS)) * 1000);
            }
            return a.sort((a, b) => a - b);
          };
          S.itemPlan.stars = plan(3, 10, PLAY_SECONDS - 10);
          S.itemPlan.shovels = plan(2, 15, PLAY_SECONDS - 15);
        }
        function spawnItem(kind) {
          let tries = 50;
          while (tries--) {
            const gx = rand(GRID),
              gy = rand(GRID);
            const t = S.map[gy][gx];
            const key = `${gx},${gy}`;
            if (t.type === "empty" && key !== `${S.base.gx},${S.base.gy}`) {
              const p = toPx(gx, gy);
              S.items.push({
                kind,
                x: p.x,
                y: p.y,
                expiresAt: performance.now() + 12000,
                active: true,
              });
              break;
            }
          }
        }

        // ===== Game Flow =====
        function resetGame() {
          setupLevel();
          S.tanks = [];
          S.bullets = [];
          S.items = [];
          S.spawn = {
            active: 0,
            basicLeft: TOTAL_BASIC,
            armoredLeft: TOTAL_ARMORED,
            totalSpawned: 0,
            cooldown: 1200,
            next: 0,
            preferred: null,
            points: [
              { gx: 1, gy: 1 },
              { gx: 7, gy: 1 },
              { gx: 13, gy: 1 },
            ],
          };
          const p = newPlayer();
          S.playerId = p.id;
          S.tanks.push(p);
          S.lives = 3;
          S.playerHP = 3;
          S.playerPower = 1;
          S.enemiesRemaining = TOTAL_BASIC + TOTAL_ARMORED;
          S.score = 0;
          S.timeLeft = PLAY_SECONDS;
          S.elapsed = 0;
          S.lastTime = 0;
          S.shovelUntil = 0;
          S.status = "playing";
          S.running = true;
          planItems();
          syncUI();
          overlay.style.display = "none";
          btnRestart.style.display = "none";
        }
        function endGame(win) {
          if (!S.running) return;
          S.running = false;
          S.status = win ? "won" : "lost";
          try {
            playSfx(win ? "win" : "lose");
          } catch (e) {}
          overlay.innerHTML = `<h2>${
            win ? "YOU WIN" : "GAME OVER"
          }</h2><p>Score: ${
            S.score
          }</p><div class="btns"><button class="btn restart" id="ovRestart">Restart</button></div>`;
          overlay.style.display = "flex";
          btnRestart.style.display = "inline-block";
          setTimeout(() => {
            const ov = document.getElementById("ovRestart");
            if (ov) ov.onclick = () => resetGame();
          }, 0);
        }

        function syncUI() {
          uiLives.textContent = S.lives;
          uiHP.textContent = getPlayer()?.hp ?? 0;
          uiPower.textContent = getPlayer()?.power ?? 1;
          uiEnemies.textContent = S.enemiesRemaining;
          uiScore.textContent = S.score;
          const mm = Math.floor(S.timeLeft / 60),
            ss = (S.timeLeft % 60).toString().padStart(2, "0");
          uiTime.textContent = `${mm}:${ss}`;
        }

        function getPlayer() {
          return S.tanks.find((t) => t.isPlayer && t.active);
        }

        // ===== Input =====
        window.addEventListener("keydown", (e) => {
          if (S.status !== "playing") return;
          if (e.key === "ArrowUp") {
            S.keys.up = true;
            e.preventDefault();
          } else if (e.key === "ArrowDown") {
            S.keys.down = true;
            e.preventDefault();
          } else if (e.key === "ArrowLeft") {
            S.keys.left = true;
            e.preventDefault();
          } else if (e.key === "ArrowRight") {
            S.keys.right = true;
            e.preventDefault();
          } else if (e.key === " ") {
            S.keys.shoot = true;
            e.preventDefault();
          }
        });
        window.addEventListener("keyup", (e) => {
          if (e.key === "ArrowUp") S.keys.up = false;
          else if (e.key === "ArrowDown") S.keys.down = false;
          else if (e.key === "ArrowLeft") S.keys.left = false;
          else if (e.key === "ArrowRight") S.keys.right = false;
          else if (e.key === " ") S.keys.shoot = false;
        });

        // ===== Loop =====
        function loop(now) {
          if (S.lastTime === 0) S.lastTime = now;
          const dt = (now - S.lastTime) / 1000;
          S.lastTime = now;
          if (S.status === "playing" && S.running) {
            S.elapsed += dt;
            const remain = Math.max(0, PLAY_SECONDS - Math.floor(S.elapsed));
            if (remain !== S.timeLeft) {
              S.timeLeft = remain;
              syncUI();
            }
            if (remain <= 0) {
              if (S.base.alive && S.lives > 0) endGame(true);
              else endGame(false);
            }
            update(dt, now);
            draw();
          } else {
            draw();
          }
          requestAnimationFrame(loop);
        }

        function update(dt, now) {
          // Items schedule
          if (S.itemPlan.stars.length && now >= S.itemPlan.stars[0]) {
            S.itemPlan.stars.shift();
            spawnItem("star");
          }
          if (S.itemPlan.shovels.length && now >= S.itemPlan.shovels[0]) {
            S.itemPlan.shovels.shift();
            spawnItem("shovel");
          }
          // expire items
          for (const it of S.items) {
            if (it.active && it.expiresAt && now >= it.expiresAt)
              it.active = false;
          }
          // player pickup
          const pl = getPlayer();
          if (pl) {
            for (const it of S.items) {
              if (!it.active) continue;
              if (
                rectOverlap(
                  pl.x,
                  pl.y,
                  pl.size,
                  pl.size,
                  it.x,
                  it.y,
                  TILE,
                  TILE
                )
              ) {
                it.active = false;
                if (it.kind === "star") {
                  S.score += 50;
                  pl.power = Math.min(3, pl.power + 1);
                  S.playerPower = pl.power;
                } else {
                  S.score += 50;
                  setBaseWalls("steel");
                  S.shovelUntil = performance.now() + 20000;
                }
                syncUI();
              }
            }
          }

          // shovel timer
          if (S.shovelUntil && now >= S.shovelUntil) {
            S.shovelUntil = 0;
            setBaseWalls("brick");
          }

          // Spawning
          if (
            S.spawn.totalSpawned < TOTAL_BASIC + TOTAL_ARMORED &&
            S.spawn.active < MAX_ACTIVE_ENEMIES &&
            now >= S.spawn.next
          ) {
            let type = null;
            if (
              S.spawn.preferred &&
              S.spawn[
                S.spawn.preferred === "basic" ? "basicLeft" : "armoredLeft"
              ] > 0
            ) {
              type = S.spawn.preferred;
              S.spawn.preferred = null;
            } else {
              const ops = [];
              if (S.spawn.basicLeft > 0) ops.push("basic");
              if (S.spawn.armoredLeft > 0) ops.push("armored");
              if (ops.length) type = choice(ops);
            }
            if (type) {
              const e = newEnemy(type);
              if (e) {
                S.tanks.push(e);
                S.spawn.totalSpawned++;
                S.spawn.active++;
                if (type === "basic") S.spawn.basicLeft--;
                else S.spawn.armoredLeft--;
              }
              S.spawn.next = performance.now() + S.spawn.cooldown;
            }
          }

          // Update player
          if (pl) {
            let dx = 0,
              dy = 0;

            // ∆Øu ti√™n tr·ª•c d·ªçc n·∫øu ƒëang gi·ªØ Up/Down; n·∫øu kh√¥ng th√¨ x√©t Left/Right.
            if (S.keys.up || S.keys.down) {
              dy = S.keys.up ? -1 : 1;
              pl.dir = S.keys.up ? "up" : "down";
            } else if (S.keys.left || S.keys.right) {
              dx = S.keys.left ? -1 : 1;
              pl.dir = S.keys.left ? "left" : "right";
            }

            const step = pl.speed * dt;
            tryMove(pl, dx * step, dy * step);
            // ƒë√°nh d·∫•u ƒëang ch·∫°y & c·∫≠p nh·∫≠t pha x√≠ch
            pl.trackOn = dx !== 0 || dy !== 0;
            if (pl.trackOn) {
              pl.trackPhase =
                (pl.trackPhase + (pl.speed * dt) / (TILE * 0.5)) % 1;

              // Sinh kh√≥i theo nh·ªãp ƒë·ªÅu (m·∫∑c ƒë·ªãnh ~16 fps): m·ªói 0.06s m·ªôt ƒë·ª£t 2 h·∫°t t·ª´ 2 ·ªëng x·∫£
              pl._smokeTimer += dt;
              const cadence = 0.06; // ch·ªânh d√†y/lo√£ng kh√≥i
              while (pl._smokeTimer >= cadence) {
                pl._smokeTimer -= cadence;
                spawnPlayerSmoke(pl);
              }
            } else {
              pl._smokeTimer = 0;
              pl.trackPhase = pl.trackPhase * 0.9;
            }

            if (S.keys.shoot) shoot(pl);
          }
          // Update enemies
          for (const t of S.tanks) {
            if (!t.active || t.isPlayer) continue;
            if (now >= t.ai.next) {
              t.ai.next = now + t.ai.think;
              const pl = getPlayer();
              if (pl && Math.random() < 0.6) {
                const pg = toGrid(pl.x, pl.y),
                  eg = toGrid(t.x, t.y);
                if (pg.gx === eg.gx) t.dir = pg.gy < eg.gy ? "up" : "down";
                else if (pg.gy === eg.gy)
                  t.dir = pg.gx < eg.gx ? "left" : "right";
                else if (Math.random() < 0.5)
                  t.dir = pg.gx < eg.gx ? "left" : "right";
                else t.dir = pg.gy < eg.gy ? "up" : "down";
              } else if (Math.random() < 0.4) {
                t.dir = choice(DIRS);
              }
              if (Math.random() < 0.55) shoot(t);
            }
            const step = t.speed * dt;
            const moved = tryMove(
              t,
              t.dir === "left" ? -step : t.dir === "right" ? step : 0,
              t.dir === "up" ? -step : t.dir === "down" ? step : 0
            );
            t.trackOn = moved;
            if (t.trackOn) {
              t.trackPhase = (t.trackPhase + (t.speed * dt) / (TILE * 0.5)) % 1;
            } else {
              t.trackPhase = t.trackPhase * 0.9;
            }

            if (!moved) t.dir = choice(DIRS);
          }

          // Update bullets
          for (const b of S.bullets) {
            if (!b.active) continue;
            const dist = b.speed * dt;
            if (b.dir === "up") b.y -= dist;
            if (b.dir === "down") b.y += dist;
            if (b.dir === "left") b.x -= dist;
            if (b.dir === "right") b.x += dist;
            if (b.x < 0 || b.y < 0 || b.x > W || b.y > H) {
              b.active = false;
              releaseOwner(b.owner);
              continue;
            }
            const g = toGrid(b.x, b.y);
            if (within(g.gx, g.gy)) {
              const tt = S.map[g.gy][g.gx];
              if (
                tt.type === "brick" ||
                tt.type === "steel" ||
                tt.type === "base"
              ) {
                //TODO: note add more line
                damageTile(g.gx, g.gy, b.power);
                spawnExplosion(b.x, b.y, false);
                try {
                  playSfx("explode_wall");
                } catch (e) {}

                b.active = false;
                releaseOwner(b.owner);
                continue;
              }
            }
            // for (const t of S.tanks) {
            //   if (!t.active) continue;
            //   if (t.id === b.owner) continue;
            //   if (rectOverlap(b.x, b.y, 6, 6, t.x, t.y, t.size, t.size)) {
            //     t.hp -= b.power;
            //     b.active = false;
            //     releaseOwner(b.owner);
            //     if (t.hp <= 0) killTank(t);
            //     else if (t.isPlayer) {
            //       S.playerHP = t.hp;
            //       syncUI();
            //     }
            //     break;
            //   }
            // }

            //TODO: set god mode
            for (const t of S.tanks) {
              if (!t.active) continue;
              if (t.id === b.owner) continue;
              if (!rectOverlap(b.x, b.y, 6, 6, t.x, t.y, t.size, t.size))
                continue;

              // Ai l√† ch·ªß vi√™n ƒë·∫°n?
              const owner = S.tanks.find((z) => z.id === b.owner);
              const ownerIsPlayer = !!(owner && owner.isPlayer);

              // T·∫ÆT FRIENDLY FIRE:
              // - ƒê·∫°n ng∆∞·ªùi ch∆°i ch·ªâ l√†m ƒëau ƒë·ªãch (kh√¥ng bao gi·ªù tr√∫ng player).
              // - ƒê·∫°n ƒë·ªãch ch·ªâ l√†m ƒëau ng∆∞·ªùi ch∆°i (ƒëi xuy√™n qua xe ƒë·ªãch kh√°c).
              if (ownerIsPlayer && t.isPlayer) {
                // ƒë·∫°n c·ªßa m√¨nh ch·∫°m ch√≠nh m√¨nh -> b·ªè qua
                continue;
              }
              if (!ownerIsPlayer && !t.isPlayer) {
                // ƒë·∫°n ƒë·ªãch ch·∫°m xe ƒë·ªãch -> b·ªè qua (cho ƒë·∫°n ƒëi ti·∫øp)
                continue;
              }

              // √Åp d·ª•ng s√°t th∆∞∆°ng b√¨nh th∆∞·ªùng
              t.hp -= b.power;
              b.active = false;
              releaseOwner(b.owner);
              if (t.hp <= 0) {
                killTank(t);
              } else if (t.isPlayer) {
                S.playerHP = t.hp;
                syncUI();
              }
              break; // ƒë√£ x·ª≠ l√Ω va ch·∫°m cho vi√™n ƒë·∫°n n√†y
            }
          }
          // c·∫≠p nh·∫≠t explosions
          S.explosions = S.explosions.filter((e) => now - e.start < e.duration);
          updateSmokes(dt);
        }

        function releaseOwner(id) {
          const o = S.tanks.find((t) => t.id === id);
          if (o) o.hasBullet = false;
        }

        function tryMove(t, dx, dy) {
          if (!dx && !dy) return false;
          const nx = clamp(t.x + dx, t.size / 2, W - t.size / 2),
            ny = clamp(t.y + dy, t.size / 2, H - t.size / 2);
          if (blockedForTank(nx, ny, t.size)) return false;
          for (const o of S.tanks) {
            if (!o.active || o.id === t.id) continue;
            if (rectOverlap(nx, ny, t.size, t.size, o.x, o.y, o.size, o.size))
              return false;
          }
          t.x = nx;
          t.y = ny;
          return true;
        }
        function spawnExplosion(x, y, big = false) {
          S.explosions.push({
            x,
            y,
            big,
            start: performance.now(),
            duration: big ? 600 : 300,
          });
        }

        // ===== Render =====
        function roundRect(x, y, w, h, r) {
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
        }
        function drawStar(cx, cy, spikes, outer, inner) {
          let rot = (Math.PI / 2) * 3,
            x = cx,
            y = cy;
          ctx.beginPath();
          ctx.moveTo(cx, cy - outer);
          for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outer;
            y = cy + Math.sin(rot) * outer;
            ctx.lineTo(x, y);
            rot += Math.PI / spikes;
            x = cx + Math.cos(rot) * inner;
            y = cy + Math.sin(rot) * inner;
            ctx.lineTo(x, y);
            rot += Math.PI / spikes;
          }
          ctx.lineTo(cx, cy - outer);
          ctx.closePath();
        }

        // ===== Player Vietnam decals (star & flag) =====
        function drawVNDecals(t, x, y) {
          // x,y: g√≥c tr√°i‚Äìtr√™n c·ªßa th√¢n (ƒë√£ tr·ª´ gap ·ªü ph·∫ßn body)
          const bodyW = t.size - 2 * Math.max(4, Math.floor(t.size * 0.14)); // ƒë√∫ng b·∫±ng kh·ªëi th√¢n b·∫°n v·∫Ω
          const bodyH = bodyW;

          // 1) Ng√¥i sao v√†ng ·ªü h√¥ng (c·ªë ƒë·ªãnh, kh√¥ng xoay theo n√≤ng)
          const cx = x + bodyW * 0.3;
          const cy = y + bodyH * 0.5;
          const starOuter = Math.max(6, Math.floor(t.size * 0.12));
          const starInner = Math.max(3, Math.floor(starOuter * 0.45));
          // vi·ªÅn t·ªëi nh·ªè
          ctx.fillStyle = VN_COL.dark;
          drawStar(cx, cy, 5, starOuter + 2, starInner + 1);
          ctx.fill();
          // sao v√†ng
          ctx.fillStyle = VN_COL.star;
          drawStar(cx, cy, 5, starOuter, starInner);
          ctx.fill();

          // 2) C·ªù ƒë·ªè sao v√†ng tr√™n c·ªôt ƒÉng-ten ph√≠a sau
          const poleH = Math.max(18, Math.floor(t.size * 0.85));
          const poleX = x + bodyW * 0.82;
          const poleY = y - Math.max(6, Math.floor(t.size * 0.18));
          // c·ªôt
          ctx.strokeStyle = "#bfbfbf";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(poleX, poleY);
          ctx.lineTo(poleX, poleY - poleH);
          ctx.stroke();

          // c·ªù (ph·∫•p ph·ªõi nh·∫π theo th·ªùi gian)
          const now = performance.now() / 1000;
          const wave = Math.sin(now * 6) * 3; // bi√™n ƒë·ªô s√≥ng
          const fw = Math.max(16, Math.floor(t.size * 0.9));
          const fh = Math.max(10, Math.floor(t.size * 0.45));
          const fx = poleX + 2;
          const fy = poleY - poleH + fh / 2;

          ctx.fillStyle = VN_COL.flagR;
          ctx.beginPath();
          ctx.moveTo(fx, fy - fh / 2);
          ctx.lineTo(fx + fw * 0.5, fy - fh / 2 + wave);
          ctx.lineTo(fx + fw, fy + fh / 2 - wave);
          ctx.lineTo(fx + fw * 0.5, fy + fh / 2);
          ctx.closePath();
          ctx.fill();

          // sao nh·ªè tr√™n n·ªÅn c·ªù
          ctx.fillStyle = VN_COL.star;
          drawStar(
            fx + fw * 0.45,
            fy,
            5,
            Math.max(5, Math.floor(fh * 0.35)),
            Math.max(2, Math.floor(fh * 0.17))
          );
          ctx.fill();
        }

        function draw() {
          ctx.clearRect(0, 0, W, H);
          ctx.fillStyle = "#0b3d2e";
          ctx.fillRect(0, 0, W, H);
          for (let gy = 0; gy < GRID; gy++) {
            for (let gx = 0; gx < GRID; gx++) {
              const t = S.map[gy][gx];
              const x = gx * TILE,
                y = gy * TILE;
              if (t.type === "empty") {
                if (((gx + gy) & 1) === 0) {
                  ctx.globalAlpha = 0.05;
                  ctx.fillStyle = "#fff";
                  ctx.fillRect(x, y, TILE, TILE);
                  ctx.globalAlpha = 1;
                }
              } else if (t.type === "brick") {
                ctx.fillStyle = "#b55239";
                ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
                ctx.strokeStyle = "#8a3f2b";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 2, y + TILE / 2);
                ctx.lineTo(x + TILE - 2, y + TILE / 2);
                ctx.moveTo(x + TILE / 2, y + 2);
                ctx.lineTo(x + TILE / 2, y + TILE - 2);
                ctx.stroke();
              } else if (t.type === "steel") {
                ctx.fillStyle = "#9aa3ad";
                roundRect(x + 2, y + 2, TILE - 4, TILE - 4, 4);
                ctx.fill();
                ctx.strokeStyle = "#6b7680";
                ctx.lineWidth = 2;
                ctx.stroke();
              } else if (t.type === "river") {
                ctx.fillStyle = "#2aa1d3";
                ctx.fillRect(x, y, TILE, TILE);
                ctx.globalAlpha = 0.35;
                ctx.fillStyle = "#bfe7fa";
                ctx.fillRect(x, y + 10, TILE, 4);
                ctx.fillRect(x, y + 20, TILE, 3);
                ctx.globalAlpha = 1;
              } else if (t.type === "base") {
                ctx.fillStyle = S.base.alive ? "#ffd54d" : "#333";
                roundRect(x + 6, y + 6, TILE - 12, TILE - 12, 6);
                ctx.fill();
                ctx.strokeStyle = "#8a6a1f";
                ctx.lineWidth = 2;
                ctx.stroke();
              }
            }
          }
          // items
          for (const it of S.items) {
            if (!it.active) continue;
            const x = it.x - TILE / 2,
              y = it.y - TILE / 2;
            if (it.kind === "star") {
              ctx.fillStyle = "#ffd700";
              drawStar(it.x, it.y, 5, TILE / 2 - 4, 6);
              ctx.fill();
              ctx.strokeStyle = "#9e7b00";
              ctx.lineWidth = 2;
              ctx.stroke();
            } else {
              ctx.fillStyle = "#c0c0c0";
              roundRect(x + 4, y + 4, TILE - 8, (TILE - 8) * 0.55, 6);
              ctx.fill();
              ctx.fillStyle = "#9a9a9a";
              ctx.fillRect(
                x + (TILE - 8) * 0.46,
                y + 4 + (TILE - 8) * 0.55,
                (TILE - 8) * 0.08,
                (TILE - 8) * 0.4
              );
            }
          }
          // bullets
          for (const b of S.bullets) {
            if (!b.active) continue;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
            ctx.fill();
          }

          // smokes (player only) ‚Äî v·∫Ω d∆∞·ªõi xe
          for (const s of S.smokes) {
            const k = Math.max(0, s.life / s.max); // 1 -> 0
            const baseR = Math.max(2, s.r);
            const R = baseR * (1 + 0.6 * (1 - k)); // l·ªõn d·∫ßn √≠t h∆°n
            const squash = 1 + 0.25 * (1 - k); // elip nh·∫π

            // L·ªõp 1: l√µi t·ªëi
            ctx.globalAlpha = 0.18 + 0.22 * k;
            ctx.fillStyle = s.c0 + (0.8 * k + 0.1) + ")";
            ctx.beginPath();
            ctx.ellipse(s.x, s.y, R * 0.7, R * 0.7 * squash, 0, 0, Math.PI * 2);
            ctx.fill();

            // L·ªõp 2: x√°m xanh
            ctx.globalAlpha = 0.15 + 0.18 * k;
            ctx.fillStyle = s.c1 + (0.5 * k + 0.1) + ")";
            ctx.beginPath();
            ctx.ellipse(s.x, s.y, R, R * squash, 0, 0, Math.PI * 2);
            ctx.fill();

            // L·ªõp 3: vi·ªÅn s√°ng nh·∫°t
            ctx.globalAlpha = 0.1 + 0.12 * k;
            ctx.fillStyle = s.c2 + 0.35 * k + ")";
            ctx.beginPath();
            ctx.ellipse(
              s.x,
              s.y,
              R * 1.25,
              R * 1.25 * squash,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            ctx.globalAlpha = 1;
          }

          // tanks (x√≠ch h√†i h√≤a + th√¢n + th√°p ph√°o tr√≤n + decal Vi·ªát Nam cho player)
          for (const t of S.tanks) {
            if (!t.active) continue;

            const x = t.x - t.size / 2;
            const y = t.y - t.size / 2;

            // m√†u th√¢n cho ƒë·ªãch (player s·∫Ω override b·∫±ng VN_COL)
            const enemyBody = t.kind === "armored" ? "#ff6b6b" : "#f0ad4e";

            // ---------- X√çCH (m√†u h√†i h√≤a) ----------
            const trackW = Math.max(6, Math.floor(t.size * 0.22));
            const rungStep = 6;
            const rungOffset = Math.floor((t.trackPhase || 0) * rungStep);
            const trackBase = t.isPlayer ? VN_COL.dark : "#2b2b2b";
            const trackRung = t.isPlayer ? "#2f4030" : "#444";

            ctx.fillStyle = trackBase;

            if (t.dir === "up" || t.dir === "down") {
              // d·ªçc: x√≠ch tr√°i/ph·∫£i
              ctx.fillRect(x, y, trackW, t.size);
              ctx.fillRect(x + t.size - trackW, y, trackW, t.size);

              // rƒÉng x√≠ch cu·ªôn
              ctx.fillStyle = trackRung;
              for (
                let yy = y - rungOffset;
                yy < y + t.size + rungStep;
                yy += rungStep
              ) {
                ctx.fillRect(x + 1, yy, trackW - 2, 2); // tr√°i
                ctx.fillRect(x + t.size - trackW + 1, yy, trackW - 2, 2); // ph·∫£i
              }
            } else {
              // ngang: x√≠ch tr√™n/d∆∞·ªõi
              ctx.fillRect(x, y, t.size, trackW);
              ctx.fillRect(x, y + t.size - trackW, t.size, trackW);

              ctx.fillStyle = trackRung;
              for (
                let xx = x - rungOffset;
                xx < x + t.size + rungStep;
                xx += rungStep
              ) {
                ctx.fillRect(xx, y + 1, 2, trackW - 2); // tr√™n
                ctx.fillRect(xx, y + t.size - trackW + 1, 2, trackW - 2); // d∆∞·ªõi
              }
            }

            // ---------- TH√ÇN ----------
            const gap = Math.max(4, Math.floor(t.size * 0.14)); // l·ªÅ v√†o th√¢n
            const bx = x + gap,
              by = y + gap,
              bw = t.size - gap * 2,
              bh = bw;

            if (t.isPlayer) {
              // n·ªÅn olive VN + r·∫±n ri
              ctx.fillStyle = VN_COL.green;
              roundRect(bx, by, bw, bh, 6);
              ctx.fill();

              ctx.fillStyle = VN_COL.green2; // 2 m·∫£ng r·∫±n ri nh·∫π
              ctx.beginPath();
              ctx.moveTo(bx, by + bh * 0.26);
              ctx.lineTo(bx + bw * 0.52, by + bh * 0.06);
              ctx.lineTo(bx + bw * 0.84, by + bh * 0.2);
              ctx.lineTo(bx + bw * 0.34, by + bh * 0.4);
              ctx.closePath();
              ctx.fill();

              ctx.beginPath();
              ctx.moveTo(bx + bw * 0.12, by + bh * 0.7);
              ctx.lineTo(bx + bw * 0.68, by + bh * 0.48);
              ctx.lineTo(bx + bw * 0.94, by + bh * 0.63);
              ctx.lineTo(bx + bw * 0.36, by + bh * 0.86);
              ctx.closePath();
              ctx.fill();

              // ----- Ng√¥i sao cƒÉn gi·ªØa th√¢n -----
              const cx = bx + bw * 0.5;
              const cy = by + bh * 0.5;
              const starOuter = Math.max(6, Math.floor(t.size * 0.12));
              const starInner = Math.max(3, Math.floor(starOuter * 0.45));
              // vi·ªÅn t·ªëi m·∫£nh ƒë·ªÉ n·ªïi b·∫≠t
              ctx.fillStyle = VN_COL.dark;
              drawStar(cx, cy, 5, starOuter + 2, starInner + 1);
              ctx.fill();
              // sao v√†ng
              ctx.fillStyle = VN_COL.star;
              drawStar(cx, cy, 5, starOuter, starInner);
              ctx.fill();

              // ----- C·ªôt c·ªù ph√≠a sau‚Äìtr√°i (v·ªã tr√≠ h·ª£p l√Ω h∆°n) -----
              const poleH = Math.max(18, Math.floor(t.size * 0.85));
              const poleX = bx + bw * 0.12; // s√°t g√≥c sau‚Äìtr√°i
              const poleY = by - Math.max(6, Math.floor(t.size * 0.18));
              ctx.strokeStyle = "#bfbfbf";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(poleX, poleY);
              ctx.lineTo(poleX, poleY - poleH);
              ctx.stroke();

              // L√° c·ªù ph·∫•p ph·ªõi
              const now = performance.now() / 1000;
              const wave = Math.sin(now * 6) * 3;
              const fw = Math.max(16, Math.floor(t.size * 0.9));
              const fh = Math.max(10, Math.floor(t.size * 0.45));
              const fx = poleX + 2;
              const fy = poleY - poleH + fh / 2;

              ctx.fillStyle = VN_COL.flagR;
              ctx.beginPath();
              ctx.moveTo(fx, fy - fh / 2);
              ctx.lineTo(fx + fw * 0.5, fy - fh / 2 + wave);
              ctx.lineTo(fx + fw, fy + fh / 2 - wave);
              ctx.lineTo(fx + fw * 0.5, fy + fh / 2);
              ctx.closePath();
              ctx.fill();

              ctx.fillStyle = VN_COL.star;
              drawStar(
                fx + fw * 0.45,
                fy,
                5,
                Math.max(5, Math.floor(fh * 0.35)),
                Math.max(2, Math.floor(fh * 0.17))
              );
              ctx.fill();
            } else {
              // ƒë·ªãch gi·ªØ m√†u c≈©
              ctx.fillStyle = enemyBody;
              roundRect(bx, by, bw, bh, 6);
              ctx.fill();
            }

            // ---------- TH√ÅP PH√ÅO TR√íN + N√íNG S√öNG ----------
            // th√°p ph√°o n·∫±m tr√™n th√¢n, n√≤ng xu·∫•t ph√°t t·ª´ t√¢m th√°p ph√°o (t.x, t.y)
            const turretOuter = t.size * 0.28;
            const turretInner = t.size * 0.22;
            const barrelLen = Math.max(12, Math.floor(t.size * 0.35));

            // vi·ªÅn t·ªëi c·ªßa th√°p
            ctx.fillStyle = t.isPlayer ? VN_COL.dark : "#333";
            ctx.beginPath();
            ctx.arc(t.x, t.y, turretOuter, 0, Math.PI * 2);
            ctx.fill();
            // m·∫∑t th√°p
            ctx.fillStyle = t.isPlayer ? VN_COL.green : enemyBody;
            ctx.beginPath();
            ctx.arc(t.x, t.y, turretInner, 0, Math.PI * 2);
            ctx.fill();

            // n√≤ng s√∫ng (d√†y nh·∫π ƒë·ªÉ c√¢n ƒë·ªëi)
            ctx.fillStyle = "#2e2e2e";
            const bwid = 6;
            if (t.dir === "up")
              ctx.fillRect(t.x - bwid / 2, t.y - barrelLen, bwid, barrelLen);
            if (t.dir === "down")
              ctx.fillRect(t.x - bwid / 2, t.y, bwid, barrelLen);
            if (t.dir === "left")
              ctx.fillRect(t.x - barrelLen, t.y - bwid / 2, barrelLen, bwid);
            if (t.dir === "right")
              ctx.fillRect(t.x, t.y - bwid / 2, barrelLen, bwid);

            // ---------- HP nh·ªè ·ªü ƒëu√¥i ----------
            ctx.fillStyle = "#000";
            for (let i = 0; i < t.hp; i++)
              ctx.fillRect(x + 4 + i * 6, y + t.size - 10, 4, 6);
          }

          // explosions
          for (const e of S.explosions) {
            const age = performance.now() - e.start;
            const ratio = age / e.duration;
            const maxR = e.big ? 32 : 16;
            const r = maxR * ratio;
            ctx.globalAlpha = 1 - ratio;
            ctx.fillStyle = e.big ? "#ff9933" : "#ffff66";
            ctx.beginPath();
            ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }

          // bushes on top
          for (const key of S.bushSet) {
            const [gx, gy] = key.split(",").map(Number);
            const x = gx * TILE,
              y = gy * TILE;
            ctx.fillStyle = "#3fa34d";
            roundRect(x + 2, y + 2, TILE - 4, TILE - 4, 6);
            ctx.fill();
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = "#fff";
            ctx.fillRect(x + 6, y + 6, TILE - 12, TILE - 12);
            ctx.globalAlpha = 1;
          }
          if (S.status === "won" || S.status === "lost") {
            /* overlay already shows text */
          }
        }

        // ===== Buttons =====
        btnStart.onclick = () => {
          ensureAudio();
          AUDIO.ctx.resume(); // Chrome y√™u c·∫ßu c√≥ gesture
          resetGame();
        };
        btnRestart.onclick = () => {
          ensureAudio();
          AUDIO.ctx.resume();
          resetGame();
        };
        // ===== Sound UI init & events =====
        (function initSoundUI() {
          // ƒë·ªçc prefs ƒë√£ l∆∞u
          loadSoundPref(); // ON/OFF
          loadVolumePref(); // slider (0..100 hi·ªÉn th·ªã)
          updateSoundUI(); // c·∫≠p nh·∫≠t pill Sound
          updateVolumeUI(); // ƒë·ªìng b·ªô tr·∫°ng th√°i slider

          // Toggle Sound ON/OFF (click + keyboard)
          if (btnSound) {
            const toggleSound = () => {
              ensureAudio();
              AUDIO.enabled = !AUDIO.enabled;
              try {
                if (AUDIO.ctx)
                  AUDIO.enabled ? AUDIO.ctx.resume() : AUDIO.ctx.suspend();
              } catch (e) {}
              saveSoundPref();
              updateSoundUI();
              updateVolumeUI();
            };
            btnSound.addEventListener("click", toggleSound);
            btnSound.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                toggleSound();
              }
            });
          }

          // Slider volume (0..100 -> 0..1)
          if (volSlider) {
            const onSlide = (val) => {
              const v = Math.max(0, Math.min(100, Number(val))) / 100;
              // n·∫øu ch∆∞a c√≥ ctx, ch·ªâ l∆∞u pref; khi Start m·ªõi apply
              if (AUDIO.ctx && AUDIO.master) AUDIO.master.gain.value = v;
              saveVolumePref(v);
            };
            volSlider.addEventListener("input", (e) => onSlide(e.target.value));
            volSlider.addEventListener("change", (e) =>
              onSlide(e.target.value)
            );
          }
        })();

        // Pre-draw map for menu
        setupLevel();
        draw();
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
