<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>üî• 81 Ng√†y ƒê√™m B·∫£o V·ªá Th√†nh C·ªï Qu·∫£ng Tr·ªã 1972</title>
    <style>
      :root {
        --bg: #0b1220;
        --panel: #0f172a;
        --text: #e5e7eb;
        --muted: #94a3b8;
        --accent: #22c55e;
        --accent2: #6366f1;
        --danger: #ef4444;
        --steel: #38bdf8;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        /* N·ªÅn ho√†ng h√¥n kh√≥i b·ª•i: n√¢u ƒë·∫≠m -> n√¢u ƒë·∫•t */
        background: linear-gradient(180deg, #11100e, #2a261b);
        color: var(--text);
        font: 14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial;
      }

      .wrap {
        max-width: 900px;
        margin: 24px auto;
        padding: 16px;
      }

      h1 {
        font-size: 24px;
        margin: 0 0 12px;
      }

      .hud {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        background: var(--panel);
        border: 1px solid #1f2937;
        border-radius: 16px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
      }

      .row {
        display: flex;
        gap: 16px;
        align-items: center;
      }

      .pill {
        background: #1f2937;
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
      }
      .pill.btn {
        cursor: pointer;
        user-select: none;
      }
      .pill.off {
        background: #374151;
      }
      /* slider trong pill √¢m l∆∞·ª£ng */
      #uiVol input[type="range"] {
        width: 120px;
        accent-color: var(--accent2);
        vertical-align: middle;
      }
      #uiVol.off input[type="range"] {
        opacity: 0.5;
        pointer-events: none;
      }

      .pill.steel {
        background: #0c4a6e;
      }

      .frame {
        position: relative;
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .board {
        position: relative;
        border-radius: 16px;
        overflow: hidden;
        border: 1px solid #0f172a;
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4);
      }

      canvas {
        display: block;
        width: 480px;
        height: 480px;
      }

      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.6);
        gap: 12px;
        text-align: center;
      }

      .overlay h2 {
        margin: 0;
        font-size: 28px;
      }

      .btns {
        display: flex;
        gap: 10px;
      }

      .btn {
        appearance: none;
        border: none;
        border-radius: 12px;
        padding: 10px 14px;
        font-weight: 700;
        cursor: pointer;
        transition: 0.2s transform, 0.2s opacity;
      }

      .btn:active {
        transform: translateY(1px);
      }

      .btn.start {
        background: var(--accent);
        color: #001507;
      }

      .btn.restart {
        background: var(--accent2);
        color: white;
      }

      .muted {
        color: var(--muted);
      }

      .tips {
        font-size: 12px;
        color: var(--muted);
      }

      @media (min-width: 720px) {
        .frame {
          grid-template-columns: 480px 1fr;
          align-items: start;
        }
      }

      .card {
        background: var(--panel);
        border: 1px solid #1f2937;
        border-radius: 16px;
        padding: 12px;
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <h1>üî• 81 Ng√†y ƒê√™m B·∫£o V·ªá Th√†nh C·ªï Qu·∫£ng Tr·ªã 1972</h1>
      <div class="hud">
        <div class="row">
          <span class="pill">Lives: <b id="uiLives">3</b></span>
          <span class="pill">HP: <b id="uiHP">3</b></span>
          <span class="pill">Power: <b id="uiPower">1</b></span>
          <span class="pill">Level: <b>1</b></span>
        </div>
        <div class="row">
          <span class="pill">Enemies Left: <b id="uiEnemies">20</b></span>
          <span class="pill">Score: <b id="uiScore">0</b></span>
          <span class="pill">Time: <b id="uiTime">3:00</b></span>
          <span id="uiBaseState" class="pill">Base: BRICK</span>
          <span id="uiSound" class="pill" role="button" tabindex="0"
            >üîä Sound: ON</span
          >
          <span id="uiVol" class="pill">
            Vol:
            <input
              id="uiVolSlider"
              type="range"
              min="0"
              max="100"
              value="25"
              style="vertical-align: middle; width: 100px"
            />
          </span>
        </div>
      </div>

      <div class="frame">
        <div class="board">
          <canvas id="game" width="480" height="480"></canvas>
          <div id="overlay" class="overlay">
            <p>Ph√≠m ƒëi·ªÅu khi·ªÉn: ‚Üê ‚Üí ‚Üë ‚Üì, b·∫Øn: Space</p>
            <div class="btns">
              <button id="btnStart" class="btn start">Start</button>
            </div>
          </div>
        </div>

        <div class="card">
          <b>Lu·∫≠t ch∆°i</b>
          <ul>
            <li>Di·ªát 20 xe ƒë·ªãch (10 Basic, 10 Armored) trong 3 ph√∫t.</li>
            <li>
              B·∫£o v·ªá cƒÉn c·ª© ƒë·∫°i b√†ng (2 l·ªõp g·∫°ch). Shovel bi·∫øn t∆∞·ªùng th√†nh th√©p
              20s v√† t·ª± h·ªìi ph·ª•c.
            </li>
            <li>
              Star tƒÉng s·ª©c m·∫°nh ƒë·∫°n +1 (t·ªëi ƒëa 3). M·ªói v·∫≠t ph·∫©m +50 ƒëi·ªÉm.
            </li>
            <li>
              Thua khi h·∫øt 3 m·∫°ng ho·∫∑c cƒÉn c·ª© b·ªã ph√°. H·∫øt gi·ªù m√† cƒÉn c·ª© c√≤n &
              c√≤n m·∫°ng ‚áí Th·∫Øng.
            </li>
          </ul>
          <p class="tips">
            G·ª£i √Ω: Ch·∫∑n ƒë∆∞·ªùng h·∫πp, t·∫≠n d·ª•ng s√¥ng & b·ª•i c√¢y ƒë·ªÉ √°p s√°t!
          </p>
          <div class="btns" style="margin-top: 8px">
            <button id="btnRestart" class="btn restart" style="display: none">
              Restart
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        "use strict";
        // ===== Constants =====
        const TILE = 32,
          GRID = 15,
          W = TILE * GRID,
          H = TILE * GRID;
        const PLAY_SECONDS = 180; // 3 minutes
        const MAX_ACTIVE_ENEMIES = 4,
          TOTAL_BASIC = 10,
          TOTAL_ARMORED = 10;
        const DEV_GOD_MODE = true; // <- b·∫≠t/t·∫Øt b·∫•t t·ª≠ cho ng∆∞·ªùi ch∆°i
        // ===== Vietnam scheme colors =====
        const VN_COL = {
          green: "#2d4b2b", // olive green
          green2: "#3a5b37", // nh·∫°t h∆°n 1 ch√∫t cho m·∫£ng r·∫±n ri
          dark: "#1d3320", // vi·ªÅn t·ªëi
          star: "#ffd34d", // v√†ng ng√¥i sao
          flagR: "#d62828", // ƒë·ªè c·ªù
        };

        // ===== Ground pattern (ƒë·∫•t tr·∫≠n ƒë·ªãa) =====
        let GROUND_PATTERN = null;
        function getGroundPattern(ctx) {
          if (GROUND_PATTERN) return GROUND_PATTERN;

          // T·∫°o 1 tile 64x64 r·ªìi l·∫∑p
          const p = document.createElement("canvas");
          p.width = p.height = 64;
          const pc = p.getContext("2d");

          // N√¢u ƒë·∫•t n·ªÅn
          pc.fillStyle = "#2a261b";
          pc.fillRect(0, 0, 64, 64);

          // H·∫°t b·ª•i v√†ng c√°t r·∫•t m·ªù r·∫£i ng·∫´u nhi√™n
          pc.globalAlpha = 0.06;
          pc.fillStyle = "#b8a76a";
          for (let i = 0; i < 120; i++) {
            pc.fillRect(Math.random() * 64, Math.random() * 64, 1, 1);
          }
          pc.globalAlpha = 1;

          GROUND_PATTERN = ctx.createPattern(p, "repeat");
          return GROUND_PATTERN;
        }

        // Vignette t·ªëi g√≥c cho c·∫£m gi√°c kh√≥i b·ª•i ƒë·∫≠m ·ªü r√¨a
        function drawVignette(ctx, w, h) {
          const rg = ctx.createRadialGradient(
            w / 2,
            h * 0.55,
            w * 0.2,
            w / 2,
            h * 0.55,
            w * 0.85
          );
          rg.addColorStop(0, "rgba(0,0,0,0)");
          rg.addColorStop(1, "rgba(0,0,0,0.35)");
          ctx.fillStyle = rg;
          ctx.fillRect(0, 0, w, h);
        }

        // ===== Th·∫°ch H√£n River: carve tiles by a horizontal sine-band =====
        // ===== Curved River: build a smooth ribbon path (no tile marking) =====
        function carveCurvedRiver(opts = {}) {
          // Tham s·ªë theo TILE ƒë·ªÉ d·ªÖ h√¨nh dung
          const baseY = opts.baseY ?? 7; // ƒë∆∞·ªùng trung t√¢m (ƒë∆°n v·ªã h√†ng tile)
          const amp = opts.amp ?? 1.5; // ƒë·ªô u·ªën (tile)
          const freq = opts.freq ?? 0.55; // nh·ªãp u·ªën theo c·ªôt gx
          const phase = opts.phase ?? 0.0; // d·ªãch pha
          const visualWidth = opts.visualWidth ?? TILE * 1.2; // b·ªÅ r·ªông v·∫Ω (px), m·∫£nh

          // L·∫•y m·∫´u theo px ƒë·ªÉ t·∫°o polyline cong m∆∞·ª£t ch·∫°y ngang b·∫£n ƒë·ªì
          const pts = [];
          const stepPx = 8; // 8px/m·∫´u l√† ƒë·ªß m∆∞·ª£t
          for (let x = 0; x <= W; x += stepPx) {
            const gx = x / TILE;
            const yTiles = baseY + Math.sin(phase + gx * freq) * amp;
            const y = yTiles * TILE + TILE / 2;
            pts.push({ x, y });
          }
          S.riverPath = {
            points: pts,
            width: visualWidth,
            wave: { amplitude: 1.0, spacing: 36, speed: 0.35 },
          };
        }
        // T·∫°o m·ªôt c√¢y c·∫ßu vu√¥ng g√≥c v·ªõi d√≤ng ch·∫£y t·∫°i ƒëi·ªÉm gi·ªØa ƒëo·∫°n i..i+1 c·ªßa path
        function makeBridgeAt(pts, i, walkWidth = TILE * 1.25, span = null) {
          const a = pts[i],
            b = pts[i + 1];
          if (!a || !b) return null;
          let dx = b.x - a.x,
            dy = b.y - a.y;
          const len = Math.hypot(dx, dy) || 1;
          dx /= len;
          dy /= len;
          let nx = -dy,
            ny = dx;

          const riverW = (S.riverPath?.width || TILE) * 1.1; // tr√πm m√©p nhi·ªÅu h∆°n
          const L = span ?? riverW + TILE * 1.6; // d√†i h∆°n ƒë·ªÉ nh√¨n c√¢n

          const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
          const p1 = { x: mid.x - (nx * L) / 2, y: mid.y - (ny * L) / 2 };
          const p2 = { x: mid.x + (nx * L) / 2, y: mid.y + (ny * L) / 2 };
          return { a: p1, b: p2, width: walkWidth };
        }

        // Th√™m v√†i c√¢y c·∫ßu r·∫£i d·ªçc s√¥ng
        function buildRiverBridges() {
          S.bridges = [];
          if (!S.riverPath?.points?.length) return;
          const pts = S.riverPath.points;
          const idx = [
            Math.floor(pts.length * 0.15), // c·∫ßu ƒë·∫ßu xa h∆°n v·ªÅ b√™n tr√°i
            Math.floor(pts.length * 0.5), // c·∫ßu gi·ªØa trung t√¢m
            Math.floor(pts.length * 0.85),
          ];
          for (const i of idx) {
            const br = makeBridgeAt(
              pts,
              Math.max(0, Math.min(pts.length - 2, i))
            );
            if (br) S.bridges.push(br);
          }
        }

        // V·∫Ω c·∫ßu (v√°n g·ªó + c·ªçc)
        function drawBridges() {
          if (!S.bridges?.length) return;
          ctx.save();
          ctx.lineCap = "round";
          for (const br of S.bridges) {
            // vector c·∫ßu
            const vx = br.b.x - br.a.x,
              vy = br.b.y - br.a.y;
            const ang = Math.atan2(vy, vx);
            const L = Math.hypot(vx, vy);

            ctx.translate(br.a.x, br.a.y);
            ctx.rotate(ang);

            // b√≥ng c·∫ßu
            ctx.fillStyle = "rgba(0,0,0,0.25)";
            roundRect(0, -br.width * 0.55, L, br.width * 1.1, 6);
            ctx.fill();

            // m·∫∑t v√°n
            const g = ctx.createLinearGradient(
              0,
              -br.width / 2,
              0,
              br.width / 2
            );
            g.addColorStop(0, "#9c7b52");
            g.addColorStop(1, "#6f5236");
            ctx.fillStyle = g;
            roundRect(0, -br.width / 2, L, br.width, 8);
            ctx.lineWidth = 2.5;
            ctx.fill();

            // c√°c nan v√°n
            ctx.strokeStyle = "rgba(0,0,0,0.25)";
            ctx.lineWidth = 2;
            for (let x = 10; x < L; x += 12) {
              ctx.beginPath();
              ctx.moveTo(x, -br.width / 2 + 3);
              ctx.lineTo(x, br.width / 2 - 3);
              ctx.stroke();
            }

            // c·ªçc nh·ªè hai ƒë·∫ßu
            ctx.fillStyle = "#5a402c";
            const peg = br.width * 0.25;
            roundRect(-4, -peg / 2, 8, peg, 3);
            ctx.fill();
            roundRect(L - 4, -peg / 2, 8, peg, 3);
            ctx.fill();

            ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform cho c·∫ßu k·∫ø
          }
          ctx.restore();
        }

        // --- Geometry helpers ---
        function distPointToSegment(px, py, ax, ay, bx, by) {
          const abx = bx - ax,
            aby = by - ay;
          const apx = px - ax,
            apy = py - ay;
          const ab2 = abx * abx + aby * aby || 1;
          let t = (apx * abx + apy * aby) / ab2;
          t = Math.max(0, Math.min(1, t));
          const cx = ax + abx * t,
            cy = ay + aby * t;
          return Math.hypot(px - cx, py - cy);
        }

        // ƒêi·ªÉm (px,py) c√≥ n·∫±m TRONG d·∫£i s√¥ng cong?
        function isInRiver(px, py) {
          const rp = S.riverPath;
          if (!rp || !rp.points || rp.points.length < 2) return false;
          const halfW = (rp.width || 24) / 2;
          for (let i = 0; i < rp.points.length - 1; i++) {
            const a = rp.points[i],
              b = rp.points[i + 1];
            if (distPointToSegment(px, py, a.x, a.y, b.x, b.y) <= halfW)
              return true;
          }
          return false;
        }

        // C·∫ßu (bridge) ‚Äì danh s√°ch ƒëo·∫°n th·∫≥ng + b·ªÅ r·ªông cho ph√©p ƒëi qua
        // S.bridges = S.bridges || [];
        function isOnBridge(px, py) {
          for (const br of S.bridges) {
            const d = distPointToSegment(
              px,
              py,
              br.a.x,
              br.a.y,
              br.b.x,
              br.b.y
            );
            if (d <= br.width / 2) return true;
          }
          return false;
        }

        // --- Sample points along a tank's rectangular hitbox perimeter ---
        function sampleRectPerimeter(cx, cy, size) {
          const half = size / 2;
          const left = cx - half,
            right = cx + half;
          const top = cy - half,
            bottom = cy + half;

          // M·∫≠t ƒë·ªô m·∫´u v·ª´a ph·∫£i: m·ªói ~1/4 c·∫°nh + 4 g√≥c
          const step = Math.max(6, Math.floor(size / 4));
          const pts = [];

          // Tr√™n & d∆∞·ªõi (bao g·ªìm g√≥c)
          for (let x = left; x <= right; x += step) {
            pts.push([x, top], [x, bottom]);
          }
          // Tr√°i & ph·∫£i (b·ªè g√≥c v√¨ ƒë√£ c√≥, n√™n b·∫Øt ƒë·∫ßu t·ª´ top+step)
          for (let y = top + step; y < bottom; y += step) {
            pts.push([left, y], [right, y]);
          }
          // ƒë·∫£m b·∫£o 4 g√≥c c√≥ m·∫∑t (ph√≤ng khi step kh√¥ng tr√πng bi√™n ch√≠nh x√°c)
          pts.push([left, top], [right, top], [left, bottom], [right, bottom]);

          return pts;
        }

        // C√≥ ƒëi·ªÉm n√†o c·ªßa hitbox r∆°i v√†o s√¥ng KH√îNG n·∫±m tr√™n c·∫ßu?
        function rectTouchesRiver(cx, cy, size) {
          const pts = sampleRectPerimeter(cx, cy, size);
          for (const [px, py] of pts) {
            if (isInRiver(px, py) && !isOnBridge(px, py)) return true;
          }
          return false;
        }

        // ===== V·∫Ω 1 tile s√¥ng v·ªõi s√≥ng NGANG (foam) ƒë·ªông =====
        function drawThachHanRiverTile(gx, gy, x, y, size) {
          const t = performance.now() / 1000;

          // N∆∞·ªõc: xanh s√¢u -> xanh s√°ng (theo chi·ªÅu d·ªçc tile)
          const g = ctx.createLinearGradient(x, y, x, y + size);
          g.addColorStop(0, "#144b63");
          g.addColorStop(1, "#2aa1d3");
          ctx.fillStyle = g;
          ctx.fillRect(x, y, size, size);

          // 3 ‚Äúc·ªôt‚Äù s√≥ng ch·∫°y NGANG trong m·ªôt tile
          // Pha l·ªách theo (gx,gy) ƒë·ªÉ tr√°nh ƒë·ªìng b·ªô c·ª©ng
          const basePhase = t * 1.0 + gx * 0.25 + gy * 0.15;
          ctx.lineWidth = 2;

          for (let i = 0; i < 3; i++) {
            const colX = x + size * (0.2 + i * 0.3); // 3 d·∫£i trong 1 tile
            const amp = 2 + i * 0.7; // bi√™n ƒë·ªô nh·∫π
            const k = 0.085; // m·∫≠t ƒë·ªô s√≥ng theo tr·ª•c Y

            ctx.beginPath();
            for (let j = 0; j <= 6; j++) {
              const py = y + (size / 6) * j;
              const wave = Math.sin(basePhase + py * k + i * 0.9) * amp;
              const px = colX + wave; // L·ªÜCH THEO TR·ª§C X => s√≥ng NGANG
              if (j === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.strokeStyle = "rgba(191,231,250,0.60)"; // b·ªçt s√°ng
            ctx.stroke();
          }

          // v·ªát b·ªçt m·∫£nh tr√¥i theo chi·ªÅu n∆∞·ªõc (tr√°i -> ph·∫£i)
          const drift = (t * 36 + gy * 11) % size;
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = "rgba(255,255,255,0.18)";
          ctx.fillRect(x + drift, y + size * 0.3, 2, size * 0.4);
          ctx.globalAlpha = 1;

          // vi·ªÅn t·ªëi nh·∫π
          ctx.strokeStyle = "rgba(0,0,0,0.15)";
          ctx.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);
        }

        // ===== V·∫Ω d·∫£i s√¥ng cong theo S.riverPath =====
        function drawRiverLabel() {
          const rp = S.riverPath;
          if (!rp?.points || rp.points.length < 4) return;

          const text = "S√îNG TH·∫†CH H√ÉN";
          const pts = rp.points;

          // K√≠ch th∆∞·ªõc nh·ªè h∆°n, font bo tr√≤n
          const fontSize = Math.max(12, Math.floor((rp.width || TILE) * 0.35));
          ctx.font = `700 ${fontSize}px "Baloo 2","Nunito", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
          ctx.textBaseline = "middle";
          ctx.fillStyle = "rgba(233,246,255,0.88)";
          ctx.strokeStyle = "rgba(0,0,0,0.40)";
          ctx.lineWidth = Math.max(1.5, fontSize * 0.1);

          // T√≠nh t·ªïng chi·ªÅu d√†i ƒëo·∫°n path (theo to√†n s√¥ng)
          let total = 0;
          const segLen = [];
          for (let i = 0; i < pts.length - 1; i++) {
            const L = Math.hypot(
              pts[i + 1].x - pts[i].x,
              pts[i + 1].y - pts[i].y
            );
            segLen.push(L);
            total += L;
          }

          // V·ªã tr√≠ trung t√¢m ch·ªØ theo t·ªâ l·ªá (0..1) ‚Äî c√≥ clamp ƒë·ªÉ tr√°nh s√°t m√©p
          const margin = Math.max(40, ctx.measureText(text).width * 0.6);
          const minPos = margin / total;
          const maxPos = 1 - minPos;
          const tCenter = Math.max(
            minPos,
            Math.min(maxPos, S.riverLabelPos ?? 0.5)
          );

          // H√†m l·∫•y ƒëi·ªÉm t·∫°i kho·∫£ng c√°ch d·ªçc path
          function pointAtDist(dist) {
            let acc = 0;
            for (let i = 0; i < segLen.length; i++) {
              const L = segLen[i];
              if (acc + L >= dist) {
                const t = (dist - acc) / L;
                const a = pts[i],
                  b = pts[i + 1];
                return {
                  x: a.x + (b.x - a.x) * t,
                  y: a.y + (b.y - a.y) * t,
                  ang: Math.atan2(b.y - a.y, b.x - a.x),
                };
              }
              acc += L;
            }
            const a = pts[pts.length - 2],
              b = pts[pts.length - 1];
            return { x: b.x, y: b.y, ang: Math.atan2(b.y - a.y, b.x - a.x) };
          }

          // V·∫Ω ch·ªØ u·ªën theo s√¥ng: ƒëi t·ª´ng k√Ω t·ª± theo path
          const textW = ctx.measureText(text).width;
          const startDist = tCenter * total - textW / 2;
          let d = startDist;
          for (const ch of text) {
            const w = ctx.measureText(ch).width;
            const mid = pointAtDist(d + w / 2);
            ctx.save();
            ctx.translate(mid.x, mid.y);
            ctx.rotate(mid.ang);
            ctx.strokeText(ch, 0, 0);
            ctx.fillText(ch, 0, 0);
            ctx.restore();
            d += w;
          }
        }

        function drawCurvedRiverRibbon() {
          if (
            !S.riverPath ||
            !S.riverPath.points ||
            S.riverPath.points.length < 2
          )
            return;
          const t = performance.now() / 1000;

          const pts = S.riverPath.points;
          const width = S.riverPath.width;

          // 1) Th√¢n n∆∞·ªõc: stroke m·ªôt ƒë∆∞·ªùng cong v·ªõi lineWidth l·ªõn
          ctx.save();
          ctx.lineCap = "round";
          ctx.lineJoin = "round";

          // Gradient d·ªçc canvas nh·∫π (xanh s√¢u -> xanh s√°ng)
          const g = ctx.createLinearGradient(0, 0, 0, H);
          g.addColorStop(0, "#18506a");
          g.addColorStop(1, "#2497c6");
          ctx.strokeStyle = g;
          ctx.lineWidth = width;

          ctx.beginPath();
          ctx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
          ctx.stroke();

          // 2) S√≥ng t∆∞·ª£ng tr∆∞ng THEO ƒê∆Ø·ªúNG CONG:
          //    d√πng nhi·ªÅu n√©t dashed m·∫£nh ch·∫°y d·ªçc theo path, offset theo th·ªùi gian.
          const { amplitude, spacing, speed } = S.riverPath.wave;
          ctx.setLineDash([spacing, spacing]);
          ctx.lineDashOffset = -t * speed * 60; // tr√¥i t·ª´ tr√°i -> ph·∫£i

          // V·∫Ω 3 d·∫£i highlight song song v·ªõi th√¢n n∆∞·ªõc (d·ªãch l·ªách v√†o/ra)
          const waveWidths = [1.6, 1.2];
          const waveAlpha = [0.26, 0.18];
          const offsets = [-width * 0.16, width * 0.16]; // l·ªách sang 2 b√™n b·ªù + gi·ªØa

          for (let k = 0; k < offsets.length; k++) {
            ctx.beginPath();
            // ƒëi l·∫°i to√†n b·ªô path, nh∆∞ng d·ªãch nh·∫π theo ph√°p tuy·∫øn
            for (let i = 0; i < pts.length; i++) {
              const p = pts[i];
              // ph√°p tuy·∫øn x·∫•p x·ªâ t·ª´ ƒëo·∫°n (i-1 -> i+1)
              const a = pts[Math.max(0, i - 1)];
              const b = pts[Math.min(pts.length - 1, i + 1)];
              let nx = b.y - a.y,
                ny = -(b.x - a.x); // normal ~ (dy, -dx)
              const len = Math.hypot(nx, ny) || 1;
              nx /= len;
              ny /= len;

              // rung nh√® nh·∫π theo sin ƒë·ªÉ s√≥ng ‚Äúg·ª£n‚Äù
              const wiggle =
                Math.sin(i * 0.12 + t * 1.4 + k) * (amplitude * 0.7);
              const ox = nx * (offsets[k] + wiggle);
              const oy = ny * (offsets[k] + wiggle);
              if (i === 0) ctx.moveTo(p.x + ox, p.y + oy);
              else ctx.lineTo(p.x + ox, p.y + oy);
            }
            ctx.strokeStyle = `rgba(191,231,250,${waveAlpha[k]})`;
            ctx.lineWidth = waveWidths[k];
            ctx.stroke();
          }

          ctx.restore();
        }
        // ===== Sound toggle helpers =====
        function loadSoundPref() {
          try {
            const saved = localStorage.getItem("soundEnabled");
            if (saved !== null) AUDIO.enabled = saved === "1";
          } catch (e) {}
        }
        function saveSoundPref() {
          try {
            localStorage.setItem("soundEnabled", AUDIO.enabled ? "1" : "0");
          } catch (e) {}
        }
        function updateSoundUI() {
          if (!btnSound) return;
          btnSound.textContent = AUDIO.enabled
            ? "üîä Sound: ON"
            : "üîá Sound: OFF";
          btnSound.className = "pill" + (AUDIO.enabled ? "" : " off");
          updateVolumeUI && updateVolumeUI();
        }
        // ===== Smoke helpers =====
        // ===== Smoke helpers (player-only, realistic) =====
        // H·∫°t kh√≥i: l·ªõn d·∫ßn, bay ng∆∞·ª£c h∆∞·ªõng xe + n·ªïi l√™n (buoyancy).
        // M·ªói h·∫°t c√≥ 2‚Äì3 l·ªõp m√†u ƒë·ªÉ nh√¨n ‚Äúm·ªÅm‚Äù h∆°n.
        function spawnPlayerSmoke(tank) {
          // 2 ·ªëng x·∫£ ·ªü cu·ªëi th√¢n, l·ªách 2 b√™n
          const back = tank.size * 0.38; // l√πi v·ªÅ ph√≠a sau th√°p/xe
          const offset = tank.size * 0.18; // l·ªách tr√°i/ph·∫£i
          const spots = [];

          if (tank.dir === "up") {
            spots.push({ x: tank.x - offset, y: tank.y + back });
            spots.push({ x: tank.x + offset, y: tank.y + back });
          } else if (tank.dir === "down") {
            spots.push({ x: tank.x - offset, y: tank.y - back });
            spots.push({ x: tank.x + offset, y: tank.y - back });
          } else if (tank.dir === "left") {
            spots.push({ x: tank.x + back, y: tank.y - offset });
            spots.push({ x: tank.x + back, y: tank.y + offset });
          } else {
            // right
            spots.push({ x: tank.x - back, y: tank.y - offset });
            spots.push({ x: tank.x - back, y: tank.y + offset });
          }

          // h∆∞·ªõng kh√≥i b·∫Øn ra theo chi·ªÅu ng∆∞·ª£c c·ªßa xe + nhi·ªÖu nh·∫π
          for (const sp of spots) {
            // Gi·∫£m th·ªùi gian t·ªìn t·∫°i: ~0.30‚Äì0.50s (tr∆∞·ªõc ~0.55‚Äì0.8s)
            const life = 0.3 + Math.random() * 0.2;
            const baseSpeed = 26 + Math.random() * 10;
            let vx = 0,
              vy = 0;
            if (tank.dir === "up") {
              vx = (Math.random() - 0.5) * 10;
              vy = baseSpeed;
            }
            if (tank.dir === "down") {
              vx = (Math.random() - 0.5) * 10;
              vy = -baseSpeed;
            }
            if (tank.dir === "left") {
              vx = baseSpeed;
              vy = (Math.random() - 0.5) * 10;
            }
            if (tank.dir === "right") {
              vx = -baseSpeed;
              vy = (Math.random() - 0.5) * 10;
            }

            S.smokes.push({
              x: sp.x,
              y: sp.y,
              vx,
              vy,
              ax: (Math.random() - 0.5) * 3.2, // nhi·ªÖu ngang nh·∫π h∆°n ch√∫t
              ay: -18, // n·ªïi l√™n
              life,
              max: life,
              // Thu h·∫πp b√°n k√≠nh & t·ªëc ƒë·ªô n·ªü
              r: 1.8 + Math.random() * 1.2, // tr∆∞·ªõc: 3‚Äì5
              grow: 8 + Math.random() * 6, // tr∆∞·ªõc: 16‚Äì26
              layers: 3,
              // M√†u x√°m nh·∫π h∆°n (kh√¥ng c√≤n ƒëen s·∫´m)
              c0: "rgba(70,70,70,",
              c1: "rgba(160,165,170,",
              c2: "rgba(220,225,230,",
            });
          }
        }

        function updateSmokes(dt) {
          for (let i = S.smokes.length - 1; i >= 0; i--) {
            const s = S.smokes[i];
            s.life -= dt;
            // v·∫≠n t·ªëc + n·ªïi l√™n
            s.vx += s.ax * dt;
            s.vy += s.ay * dt;
            s.x += s.vx * dt;
            s.y += s.vy * dt;
            s.r += s.grow * dt; // l·ªõn d·∫ßn
            // gi·∫£m nhi·ªÖu theo th·ªùi gian
            s.ax *= 1 - 1.8 * dt;
            if (s.life <= 0) S.smokes.splice(i, 1);
          }
        }
        // ===== Th·∫°ch H√£n River Tile (animated) =====
        function drawThachHanRiverTile(gx, gy, x, y, size) {
          const t = performance.now() / 1000;

          // L·ªõp n∆∞·ªõc n·ªÅn: xanh s√¢u -> xanh s√°ng (c·∫£m gi√°c d√≤ng ch·∫£y)
          const g = ctx.createLinearGradient(x, y, x, y + size);
          g.addColorStop(0, "#144b63");
          g.addColorStop(1, "#2aa1d3");
          ctx.fillStyle = g;
          ctx.fillRect(x, y, size, size);

          // C√°c g·ª£n s√≥ng s√°ng (foam) l∆∞·ª£n nh·∫π theo gi√≥, tr√¥i theo d√≤ng
          // S√≥ng ch·∫°y ngang
          const basePhase = t * 1.1 + gy * 0.35 + gx * 0.15;
          for (let i = 0; i < 3; i++) {
            const colX = x + size * (0.22 + i * 0.28);
            const amp = 2.0 + i * 0.6;
            const k = 0.085;

            ctx.beginPath();
            for (let j = 0; j <= 6; j++) {
              const py = y + (size / 6) * j;
              const wave = Math.sin(basePhase + py * k + i * 0.8) * amp;
              const px = colX + wave;
              if (j === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.strokeStyle = "rgba(191,231,250,0.60)";
            ctx.stroke();
          }

          // V·ªát b·ªçt m·∫£nh tr√¥i theo d√≤ng (theo tr·ª•c d·ªçc), t·∫°o c·∫£m gi√°c c√≥ d√≤ng ch·∫£y
          const drift = (t * 28 + gx * 9) % size;
          ctx.globalAlpha = 0.28;
          ctx.fillStyle = "rgba(255,255,255,0.18)";
          ctx.fillRect(x, y + drift, size, 2);
          ctx.globalAlpha = 1;

          // Vi·ªÅn t·ªëi nh·∫π ƒë·ªÉ ‚Äúgi·ªØ n∆∞·ªõc‚Äù trong l√≤ng s√¥ng
          ctx.strokeStyle = "rgba(0,0,0,0.15)";
          ctx.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);
        }

        // ===== Volume helpers =====
        function getSavedVolume() {
          try {
            const s = localStorage.getItem("soundVolume");
            if (s !== null) {
              const v = parseFloat(s);
              if (!isNaN(v)) return Math.max(0, Math.min(1, v));
            }
          } catch (e) {}
          return null; // ch∆∞a c√≥ -> d√πng m·∫∑c ƒë·ªãnh
        }
        function loadVolumePref() {
          // ƒë·∫∑t slider theo pref (n·∫øu c√≥)
          const v = getSavedVolume();
          if (volSlider) {
            const use = v != null ? v : 0.25;
            volSlider.value = Math.round(use * 100);
          }
          return v;
        }
        function saveVolumePref(v) {
          // v: 0..1
          try {
            localStorage.setItem("soundVolume", String(v));
          } catch (e) {}
        }
        function updateVolumeUI() {
          // t·∫Øt/kh√≥a slider n·∫øu Sound OFF
          if (!volWrap || !volSlider) return;
          if (AUDIO.enabled) {
            volWrap.classList.remove("off");
            volSlider.disabled = false;
          } else {
            volWrap.classList.add("off");
            volSlider.disabled = true;
          }
        }

        // ===== AUDIO (Web Audio API) =====
        let AUDIO = {
          ctx: null,
          master: null,
          enabled: true,
        };

        function ensureAudio() {
          if (AUDIO.ctx) return;
          AUDIO.ctx = new (window.AudioContext || window.webkitAudioContext)();
          AUDIO.master = AUDIO.ctx.createGain();
          const savedVol = getSavedVolume();
          AUDIO.master.gain.value = savedVol != null ? savedVol : 0.25; // set theo pref
          AUDIO.master.connect(AUDIO.ctx.destination);
          // ƒë·ªìng b·ªô UI (n·∫øu slider ƒë√£ render)
          if (volSlider)
            volSlider.value = Math.round(AUDIO.master.gain.value * 100);
          updateVolumeUI && updateVolumeUI();
        }

        // node ti·ªán l·ª£i
        function gain(v = 1) {
          const g = AUDIO.ctx.createGain();
          g.gain.value = v;
          g.connect(AUDIO.master);
          return g;
        }

        // noise burst
        function noise(duration = 0.2, vol = 1, lpFreq = 2000) {
          const sr = AUDIO.ctx.sampleRate;
          const buffer = AUDIO.ctx.createBuffer(1, sr * duration, sr);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < data.length; i++)
            data[i] = (Math.random() * 2 - 1) * 0.9;
          const src = AUDIO.ctx.createBufferSource();
          src.buffer = buffer;

          // l·ªçc lowpass cho ƒë·ª° ch√≥i
          const lp = AUDIO.ctx.createBiquadFilter();
          lp.type = "lowpass";
          lp.frequency.value = lpFreq;

          const g = gain(vol);
          src.connect(lp);
          lp.connect(g);

          src.start();
          return g; // tr·∫£ gain ƒë·ªÉ c√≥ th·ªÉ envelope
        }

        function tone(type = "square", freq = 440, duration = 0.12, vol = 0.8) {
          const o = AUDIO.ctx.createOscillator();
          const g = gain(vol);
          o.type = type;
          o.frequency.setValueAtTime(freq, AUDIO.ctx.currentTime);
          o.connect(g);
          o.start();
          o.stop(AUDIO.ctx.currentTime + duration);
          return g;
        }

        // ti·ªán: v·∫Ω envelope nhanh
        function env(g, a = 0.005, d = 0.15) {
          const t = AUDIO.ctx.currentTime;
          g.gain.cancelScheduledValues(t);
          g.gain.setValueAtTime(0.0001, t);
          g.gain.linearRampToValueAtTime(g.gain.value || 1, t + a);
          g.gain.exponentialRampToValueAtTime(0.0001, t + a + d);
        }

        // SFX theo t√™n
        function playSfx(name) {
          if (!AUDIO.enabled || !AUDIO.ctx) return;

          switch (name) {
            case "shoot": {
              // beep ng·∫Øn c√≥ pitch l√™n nh·∫π
              const g = tone("square", 800, 0.08, 0.6);
              env(g, 0.002, 0.08);
              break;
            }
            case "shoot_enemy": {
              const g = tone("square", 700, 0.06, 0.35);
              env(g, 0.002, 0.06);
              break;
            }
            case "explode_wall": {
              const g = noise(0.18, 0.6, 1800);
              env(g, 0.005, 0.16);
              break;
            }
            case "explode_tank": {
              const g = noise(0.28, 0.8, 2400);
              env(g, 0.006, 0.24);
              // th√™m sub boom
              const sub = tone("sine", 90, 0.22, 0.4);
              env(sub, 0.003, 0.2);
              break;
            }
            case "base_destroyed": {
              // ti·∫øng r∆°i pitch + noise
              const o = AUDIO.ctx.createOscillator();
              const g = gain(0.8);
              o.type = "sawtooth";
              const t = AUDIO.ctx.currentTime;
              o.frequency.setValueAtTime(600, t);
              o.frequency.exponentialRampToValueAtTime(70, t + 0.6);
              o.connect(g);
              o.start(t);
              o.stop(t + 0.6);
              env(g, 0.005, 0.6);
              const n = noise(0.35, 0.7, 1800);
              env(n, 0.01, 0.3);
              break;
            }
            case "win": {
              // arpeggio ng·∫Øn
              const base = 523.25; // C5
              [1, 1.25, 1.5, 2].forEach((m, i) => {
                const when = AUDIO.ctx.currentTime + i * 0.09;
                const o = AUDIO.ctx.createOscillator();
                o.type = "triangle";
                o.frequency.setValueAtTime(base * m, when);
                const g = gain(0.6);
                o.connect(g);
                o.start(when);
                o.stop(when + 0.16);
                // envelope th·ªß c√¥ng
                g.gain.setValueAtTime(0.0001, when);
                g.gain.linearRampToValueAtTime(0.7, when + 0.02);
                g.gain.exponentialRampToValueAtTime(0.0001, when + 0.16);
              });
              break;
            }
            case "lose": {
              const o = AUDIO.ctx.createOscillator();
              const g = gain(0.7);
              o.type = "square";
              const t = AUDIO.ctx.currentTime;
              o.frequency.setValueAtTime(220, t);
              o.frequency.exponentialRampToValueAtTime(90, t + 0.5);
              o.connect(g);
              o.start(t);
              o.stop(t + 0.5);
              env(g, 0.005, 0.5);
              break;
            }
          }
        }

        const DIRS = ["up", "down", "left", "right"];
        const rand = (n) => Math.floor(Math.random() * n);
        const choice = (arr) => arr[rand(arr.length)];
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

        // ===== DOM =====
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const uiLives = document.getElementById("uiLives");
        const uiHP = document.getElementById("uiHP");
        const uiPower = document.getElementById("uiPower");
        const uiEnemies = document.getElementById("uiEnemies");
        const uiScore = document.getElementById("uiScore");
        const uiTime = document.getElementById("uiTime");
        const uiBaseState = document.getElementById("uiBaseState");
        const overlay = document.getElementById("overlay");
        const btnStart = document.getElementById("btnStart");
        const btnRestart = document.getElementById("btnRestart");
        const btnSound = document.getElementById("uiSound");
        const volWrap = document.getElementById("uiVol");
        const volSlider = document.getElementById("uiVolSlider");

        // ===== Game State =====
        const S = {
          map: [], // grid of tiles
          explosions: [], // danh s√°ch hi·ªáu ·ª©ng n·ªï
          smokes: [],
          bushSet: new Set(),
          base: { gx: 7, gy: 13, alive: true },
          baseRings: [],
          tanks: [], // player + enemies
          bullets: [],
          bridges: [],
          riverLabelPos: 0.32,
          wind: {
            // tr·∫°ng th√°i gi√≥ to√†n c·ª•c
            phase: 0, // pha ch·∫°y
            value: 0, // gi√° tr·ªã gi√≥ hi·ªán t·∫°i (px d·ªãch ngang)
            speed: 0.65, // t·ªëc ƒë·ªô gi√≥ (ƒëi·ªÅu ch·ªânh nhanh/ch·∫≠m)
            base: 5.0, // bi√™n ƒë·ªô gi√≥ c∆° b·∫£n (px)
            gusting: false, // c√≥ ƒëang c√≥ ‚Äúc∆°n gi√≥ m·∫°nh‚Äù kh√¥ng
            gustUntil: 0, // th·ªùi ƒëi·ªÉm k·∫øt th√∫c gust
          },
          keys: {
            up: false,
            down: false,
            left: false,
            right: false,
            shoot: false,
          },
          running: false,
          spawn: {
            active: 0,
            basicLeft: TOTAL_BASIC,
            armoredLeft: TOTAL_ARMORED,
            totalSpawned: 0,
            cooldown: 1200,
            next: 0,
            preferred: null,
            points: [
              { gx: 1, gy: 1 },
              { gx: 7, gy: 1 },
              { gx: 13, gy: 1 },
            ],
          },
          items: [], // {kind:'star'|'shovel', x,y, expiresAt, active}
          itemPlan: { stars: [], shovels: [] },
          playerId: "",
          lastTime: 0,
          elapsed: 0,
          shovelUntil: 0,
          // UI mirrored
          lives: 3,
          playerHP: 3,
          playerPower: 1,
          enemiesRemaining: TOTAL_BASIC + TOTAL_ARMORED,
          score: 0,
          timeLeft: PLAY_SECONDS,
          status: "menu", // 'menu'|'playing'|'won'|'lost'
        };

        function tile(type, hp) {
          return { type, hp };
        }
        function emptyMap() {
          const m = [];
          for (let y = 0; y < GRID; y++) {
            const r = [];
            for (let x = 0; x < GRID; x++) {
              r.push(tile("empty"));
            }
            m.push(r);
          }
          return m;
        }
        function within(x, y) {
          return x >= 0 && y >= 0 && x < GRID && y < GRID;
        }
        function toPx(gx, gy) {
          return { x: gx * TILE + TILE / 2, y: gy * TILE + TILE / 2 };
        }
        function toGrid(px, py) {
          return { gx: Math.floor(px / TILE), gy: Math.floor(py / TILE) };
        }

        // ===== Map Setup =====
        function setupLevel() {
          S.map = emptyMap();
          S.bushSet = new Set();
          // Rivers
          // River (curved, horizontal)
          carveCurvedRiver({
            baseY: 7,
            amp: 1.3, // u·ªën d·ªãu
            band: 1.2, // collision h·∫πp (~2.4 tiles t·ªïng)
            freq: 0.55,
            phase: 0.0,
            visualWidth: TILE * 1.25, // d·∫£i v·∫Ω m·∫£nh h∆°n tile-band
          });
          S.bridges = [];
          buildRiverBridges();
          // Steel clusters
          [
            [2, 2],
            [12, 2],
            [2, 7],
            [12, 7],
            [2, 11],
            [12, 11],
          ].forEach(([x, y]) => (S.map[y][x] = tile("steel", 3)));
          // Brick clusters
          [
            [4, 4],
            [10, 4],
            [4, 10],
            [10, 10],
            [7, 6],
            [7, 8],
          ].forEach(([x, y]) => (S.map[y][x] = tile("brick", 1)));
          // Bush overlays
          [
            [3, 5],
            [11, 5],
            [3, 9],
            [11, 9],
            [7, 4],
            [7, 9],
          ].forEach(([x, y]) => S.bushSet.add(`${x},${y}`));
          // Base
          S.base = { gx: 7, gy: 13, alive: true };
          S.map[S.base.gy][S.base.gx] = tile("base");
          S.baseRings = buildBaseRings(S.base.gx, S.base.gy);
          setBaseWalls("brick");
        }
        function buildBaseRings(cx, cy) {
          const coords = [];
          const add = (gx, gy) => {
            if (within(gx, gy) && !(gx === cx && gy === cy))
              coords.push({ gx, gy });
          };
          for (let y = cy - 1; y <= cy + 1; y++) {
            for (let x = cx - 1; x <= cx + 1; x++) {
              if (x === cx && y === cy) continue;
              add(x, y);
            }
          }
          for (let y = cy - 2; y <= cy + 2; y++) {
            for (let x = cx - 2; x <= cx + 2; x++) {
              const d = Math.max(Math.abs(x - cx), Math.abs(y - cy));
              if (d === 2) add(x, y);
            }
          }
          return coords;
        }
        function setBaseWalls(mode) {
          for (const { gx, gy } of S.baseRings) {
            if (!within(gx, gy)) continue;
            S.map[gy][gx] =
              mode === "steel" ? tile("steel", 3) : tile("brick", 1);
          }
          uiBaseState.textContent =
            "Base: " + (mode === "steel" ? "STEEL" : "BRICK");
          uiBaseState.className = "pill" + (mode === "steel" ? " steel" : "");
        }

        // ===== Tanks & Bullets =====
        function newPlayer() {
          const p = toPx(7, 10); // m·ªõi: ngay tr√™n cƒÉn c·ª© nh∆∞ng ngo√†i t∆∞·ªùng
          return {
            id: "P-" + Math.random().toString(36).slice(2),
            x: p.x,
            y: p.y,
            dir: "up",
            speed: 100,
            size: TILE - 6,
            hp: 3,
            power: 1,
            cd: 320,
            last: 0,
            isPlayer: true,
            active: true,
            hasBullet: false,
            trackPhase: 0, // pha x√≠ch (0..1)
            trackOn: false, // c√≥ ƒëang ch·∫°y kh√¥ng
            _smokeTimer: 0,
          };
        }

        function newEnemy(kind) {
          const sp = choice(S.spawn.points);
          let gx = sp.gx,
            gy = sp.gy,
            tries = 5;
          let pos = toPx(gx, gy);
          while (tries--) {
            if (
              !blockedForTank(pos.x, pos.y, TILE - 6) &&
              !overlapAnyTank(pos.x, pos.y, TILE - 6)
            )
              break;
            const alt = choice(S.spawn.points);
            gx = alt.gx;
            gy = alt.gy;
            pos = toPx(gx, gy);
          }
          if (blockedForTank(pos.x, pos.y, TILE - 6)) return null;
          const armored = kind === "armored";
          return {
            id: "E-" + kind + "-" + Math.random().toString(36).slice(2),
            x: pos.x,
            y: pos.y,
            dir: "down",
            speed: 80,
            size: TILE - 6,
            hp: armored ? 3 : 1,
            power: armored ? 2 : 1,
            cd: armored ? 600 : 800,
            last: 0,
            isPlayer: false,
            active: true,
            kind,
            ai: { next: performance.now() + 300, think: 500 },
            hasBullet: false,
            trackPhase: 0,
            trackOn: false,
          };
        }
        function blockedForTank(x, y, size) {
          const half = size / 2;
          const left = Math.floor((x - half) / TILE),
            right = Math.floor((x + half) / TILE),
            top = Math.floor((y - half) / TILE),
            bottom = Math.floor((y + half) / TILE);

          // 1) N·∫øu b·∫•t k·ª≥ ph·∫ßn n√†o c·ªßa hitbox ch·∫°m s√¥ng (kh√¥ng tr√™n c·∫ßu) => CH·∫∂N
          if (rectTouchesRiver(x, y, size)) return true;

          // 2) C√°c ch∆∞·ªõng ng·∫°i tile-based kh√°c v·∫´n gi·ªØ nguy√™n
          for (let gy = top; gy <= bottom; gy++) {
            for (let gx = left; gx <= right; gx++) {
              if (!within(gx, gy)) return true;
              const t = S.map[gy][gx];
              if (
                t &&
                (t.type === "brick" || t.type === "steel" || t.type === "base")
              ) {
                return true;
              }
            }
          }
          return false;
        }

        function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
          return (
            Math.abs(ax - bx) * 2 < aw + bw && Math.abs(ay - by) * 2 < ah + bh
          );
        }
        function overlapAnyTank(x, y, size) {
          return S.tanks.some(
            (t) =>
              t.active &&
              rectOverlap(x, y, size, size, t.x, t.y, t.size, t.size)
          );
        }

        function shoot(t) {
          const now = performance.now();
          if (now - t.last < t.cd) return;
          if (t.hasBullet) return;
          const half = t.size / 2;
          let bx = t.x,
            by = t.y;
          const muzz = half + 6;
          if (t.dir === "up") by -= muzz;
          if (t.dir === "down") by += muzz;
          if (t.dir === "left") bx -= muzz;
          if (t.dir === "right") bx += muzz;
          S.bullets.push({
            x: bx,
            y: by,
            dir: t.dir,
            speed: 320,
            power: t.power,
            owner: t.id,
            active: true,
          });
          t.last = now;
          t.hasBullet = true;
          if (t.isPlayer) playSfx("shoot");
          else playSfx("shoot_enemy");
        }

        function damageTile(gx, gy, power) {
          const tile = S.map[gy][gx];
          if (tile.type === "brick" || tile.type === "steel") {
            tile.hp = (tile.hp || (tile.type === "brick" ? 1 : 3)) - power;
            if ((tile.hp || 0) <= 0) {
              S.map[gy][gx] = { type: "empty" };
              const c = toPx(gx, gy);
              spawnExplosion(c.x, c.y, false);
              try {
                playSfx("explode_wall");
              } catch (e) {}
            }
          }
          if (tile.type === "base") {
            S.base.alive = false;
            const c = toPx(gx, gy);
            spawnExplosion(c.x, c.y, true);
            try {
              playSfx("base_destroyed");
            } catch (e) {}
            endGame(false);
          }
        }

        function killTank(t) {
          t.active = false;
          try {
            playSfx("explode_tank");
          } catch (e) {}
          //   if (t.isPlayer) {
          //     S.lives = Math.max(0, S.lives - 1);
          //     if (S.lives <= 0) {
          //       endGame(false);
          //       return;
          //     }
          //     const np = newPlayer();
          //     S.playerId = np.id;
          //     replacePlayer(t, np);
          //     S.playerHP = np.hp;
          //     S.playerPower = np.power;

          //TODO: b·∫•t t·ª≠
          if (t.isPlayer) {
            // Player b·∫•t t·ª≠: kh√¥ng tr·ª´ m·∫°ng, kh√¥ng respawn
            t.active = true;
            return;
          } else {
            S.spawn.active = Math.max(0, S.spawn.active - 1);
            S.enemiesRemaining = Math.max(0, S.enemiesRemaining - 1);
            S.score += t.kind === "basic" ? 100 : 200;
            const key = t.kind === "basic" ? "basicLeft" : "armoredLeft";
            if (S.spawn[key] > 0) S.spawn.preferred = t.kind;
          }
          syncUI();
        }
        function replacePlayer(oldT, np) {
          S.tanks = S.tanks.filter((z) => z !== oldT);
          S.tanks.push(np);
        }

        // ===== Items =====
        function planItems() {
          const now = performance.now();
          const plan = (count, minS, maxS) => {
            const a = [];
            for (let i = 0; i < count; i++) {
              a.push(now + (minS + Math.random() * (maxS - minS)) * 1000);
            }
            return a.sort((a, b) => a - b);
          };
          S.itemPlan.stars = plan(3, 10, PLAY_SECONDS - 10);
          S.itemPlan.shovels = plan(2, 15, PLAY_SECONDS - 15);
        }
        function spawnItem(kind) {
          let tries = 50;
          while (tries--) {
            const gx = rand(GRID),
              gy = rand(GRID);
            const t = S.map[gy][gx];
            const key = `${gx},${gy}`;
            if (t.type === "empty" && key !== `${S.base.gx},${S.base.gy}`) {
              const p = toPx(gx, gy);
              S.items.push({
                kind,
                x: p.x,
                y: p.y,
                expiresAt: performance.now() + 12000,
                active: true,
              });
              break;
            }
          }
        }

        // ===== Game Flow =====
        function resetGame() {
          setupLevel();
          S.tanks = [];
          S.bullets = [];
          S.items = [];
          S.spawn = {
            active: 0,
            basicLeft: TOTAL_BASIC,
            armoredLeft: TOTAL_ARMORED,
            totalSpawned: 0,
            cooldown: 1200,
            next: 0,
            preferred: null,
            points: [
              { gx: 1, gy: 1 },
              { gx: 7, gy: 1 },
              { gx: 13, gy: 1 },
            ],
          };
          const p = newPlayer();
          S.playerId = p.id;
          S.tanks.push(p);
          S.lives = 3;
          S.playerHP = 3;
          S.playerPower = 1;
          S.enemiesRemaining = TOTAL_BASIC + TOTAL_ARMORED;
          S.score = 0;
          S.timeLeft = PLAY_SECONDS;
          S.elapsed = 0;
          S.lastTime = 0;
          S.shovelUntil = 0;
          S.status = "playing";
          S.running = true;
          planItems();
          syncUI();
          overlay.style.display = "none";
          btnRestart.style.display = "none";
        }
        function endGame(win) {
          if (!S.running) return;
          S.running = false;
          S.status = win ? "won" : "lost";
          try {
            playSfx(win ? "win" : "lose");
          } catch (e) {}
          overlay.innerHTML = `<h2>${
            win ? "YOU WIN" : "GAME OVER"
          }</h2><p>Score: ${
            S.score
          }</p><div class="btns"><button class="btn restart" id="ovRestart">Restart</button></div>`;
          overlay.style.display = "flex";
          btnRestart.style.display = "inline-block";
          setTimeout(() => {
            const ov = document.getElementById("ovRestart");
            if (ov) ov.onclick = () => resetGame();
          }, 0);
        }

        function syncUI() {
          uiLives.textContent = S.lives;
          uiHP.textContent = getPlayer()?.hp ?? 0;
          uiPower.textContent = getPlayer()?.power ?? 1;
          uiEnemies.textContent = S.enemiesRemaining;
          uiScore.textContent = S.score;
          const mm = Math.floor(S.timeLeft / 60),
            ss = (S.timeLeft % 60).toString().padStart(2, "0");
          uiTime.textContent = `${mm}:${ss}`;
        }

        function getPlayer() {
          return S.tanks.find((t) => t.isPlayer && t.active);
        }

        // ===== Input =====
        window.addEventListener("keydown", (e) => {
          if (S.status !== "playing") return;
          if (e.key === "ArrowUp") {
            S.keys.up = true;
            e.preventDefault();
          } else if (e.key === "ArrowDown") {
            S.keys.down = true;
            e.preventDefault();
          } else if (e.key === "ArrowLeft") {
            S.keys.left = true;
            e.preventDefault();
          } else if (e.key === "ArrowRight") {
            S.keys.right = true;
            e.preventDefault();
          } else if (e.key === " ") {
            S.keys.shoot = true;
            e.preventDefault();
          }
        });
        window.addEventListener("keyup", (e) => {
          if (e.key === "ArrowUp") S.keys.up = false;
          else if (e.key === "ArrowDown") S.keys.down = false;
          else if (e.key === "ArrowLeft") S.keys.left = false;
          else if (e.key === "ArrowRight") S.keys.right = false;
          else if (e.key === " ") S.keys.shoot = false;
        });

        // ===== Loop =====
        function loop(now) {
          if (S.lastTime === 0) S.lastTime = now;
          const dt = (now - S.lastTime) / 1000;
          S.lastTime = now;
          if (S.status === "playing" && S.running) {
            S.elapsed += dt;
            const remain = Math.max(0, PLAY_SECONDS - Math.floor(S.elapsed));
            if (remain !== S.timeLeft) {
              S.timeLeft = remain;
              syncUI();
            }
            if (remain <= 0) {
              if (S.base.alive && S.lives > 0) endGame(true);
              else endGame(false);
            }
            update(dt, now);
            draw();
          } else {
            draw();
          }
          requestAnimationFrame(loop);
        }
        function updateWind(dt, now) {
          const W = S.wind;
          W.phase += dt * W.speed;

          // th·ªânh tho·∫£ng th·ªïi gi√≥ m·∫°nh 1.5‚Äì3 gi√¢y
          if (!W.gusting && Math.random() < dt * 0.05) {
            W.gusting = true;
            W.gustUntil = now + 1500 + Math.random() * 1500;
          }
          if (W.gusting && now >= W.gustUntil) W.gusting = false;

          const base = Math.sin(W.phase) * W.base;
          const gust = W.gusting ? Math.sin(W.phase * 2.2) * (W.base * 0.9) : 0;
          W.value = base + gust; // gi√° tr·ªã gi√≥ d√πng ƒë·ªÉ l·∫Øc b·ª•i c√¢y
        }

        // gi√≥ t·∫°i m·ªôt √¥ nh·∫•t ƒë·ªãnh (cho c·∫£m gi√°c nhi·ªÖu nh·∫π theo v·ªã tr√≠)
        function windAtTile(gx, gy, layer = 1) {
          // l·ªách pha theo grid ƒë·ªÉ b·ª•i kh√¥ng l·∫Øc y h·ªát nhau
          const phaseJitter = gx * 0.35 + gy * 0.22 + layer * 0.9;
          return (
            S.wind.value * (0.6 + 0.4 * Math.sin(S.wind.phase + phaseJitter))
          );
        }

        function update(dt, now) {
          updateWind(dt, now);
          // Items schedule
          if (S.itemPlan.stars.length && now >= S.itemPlan.stars[0]) {
            S.itemPlan.stars.shift();
            spawnItem("star");
          }
          if (S.itemPlan.shovels.length && now >= S.itemPlan.shovels[0]) {
            S.itemPlan.shovels.shift();
            spawnItem("shovel");
          }
          // expire items
          for (const it of S.items) {
            if (it.active && it.expiresAt && now >= it.expiresAt)
              it.active = false;
          }
          // player pickup
          const pl = getPlayer();
          if (pl) {
            for (const it of S.items) {
              if (!it.active) continue;
              if (
                rectOverlap(
                  pl.x,
                  pl.y,
                  pl.size,
                  pl.size,
                  it.x,
                  it.y,
                  TILE,
                  TILE
                )
              ) {
                it.active = false;
                if (it.kind === "star") {
                  S.score += 50;
                  pl.power = Math.min(3, pl.power + 1);
                  S.playerPower = pl.power;
                } else {
                  S.score += 50;
                  setBaseWalls("steel");
                  S.shovelUntil = performance.now() + 20000;
                }
                syncUI();
              }
            }
          }

          // shovel timer
          if (S.shovelUntil && now >= S.shovelUntil) {
            S.shovelUntil = 0;
            setBaseWalls("brick");
          }

          // Spawning
          if (
            S.spawn.totalSpawned < TOTAL_BASIC + TOTAL_ARMORED &&
            S.spawn.active < MAX_ACTIVE_ENEMIES &&
            now >= S.spawn.next
          ) {
            let type = null;
            if (
              S.spawn.preferred &&
              S.spawn[
                S.spawn.preferred === "basic" ? "basicLeft" : "armoredLeft"
              ] > 0
            ) {
              type = S.spawn.preferred;
              S.spawn.preferred = null;
            } else {
              const ops = [];
              if (S.spawn.basicLeft > 0) ops.push("basic");
              if (S.spawn.armoredLeft > 0) ops.push("armored");
              if (ops.length) type = choice(ops);
            }
            if (type) {
              const e = newEnemy(type);
              if (e) {
                S.tanks.push(e);
                S.spawn.totalSpawned++;
                S.spawn.active++;
                if (type === "basic") S.spawn.basicLeft--;
                else S.spawn.armoredLeft--;
              }
              S.spawn.next = performance.now() + S.spawn.cooldown;
            }
          }

          // Update player
          if (pl) {
            let dx = 0,
              dy = 0;

            // ∆Øu ti√™n tr·ª•c d·ªçc n·∫øu ƒëang gi·ªØ Up/Down; n·∫øu kh√¥ng th√¨ x√©t Left/Right.
            if (S.keys.up || S.keys.down) {
              dy = S.keys.up ? -1 : 1;
              pl.dir = S.keys.up ? "up" : "down";
            } else if (S.keys.left || S.keys.right) {
              dx = S.keys.left ? -1 : 1;
              pl.dir = S.keys.left ? "left" : "right";
            }

            const step = pl.speed * dt;
            tryMove(pl, dx * step, dy * step);
            // ƒë√°nh d·∫•u ƒëang ch·∫°y & c·∫≠p nh·∫≠t pha x√≠ch
            pl.trackOn = dx !== 0 || dy !== 0;
            if (pl.trackOn) {
              pl.trackPhase =
                (pl.trackPhase + (pl.speed * dt) / (TILE * 0.5)) % 1;

              // Sinh kh√≥i theo nh·ªãp ƒë·ªÅu (m·∫∑c ƒë·ªãnh ~16 fps): m·ªói 0.06s m·ªôt ƒë·ª£t 2 h·∫°t t·ª´ 2 ·ªëng x·∫£
              pl._smokeTimer += dt;
              const cadence = 0.06; // ch·ªânh d√†y/lo√£ng kh√≥i
              while (pl._smokeTimer >= cadence) {
                pl._smokeTimer -= cadence;
                spawnPlayerSmoke(pl);
              }
            } else {
              pl._smokeTimer = 0;
              pl.trackPhase = pl.trackPhase * 0.9;
            }

            if (S.keys.shoot) shoot(pl);
          }
          // Update enemies
          for (const t of S.tanks) {
            if (!t.active || t.isPlayer) continue;
            if (now >= t.ai.next) {
              t.ai.next = now + t.ai.think;
              const pl = getPlayer();
              if (pl && Math.random() < 0.6) {
                const pg = toGrid(pl.x, pl.y),
                  eg = toGrid(t.x, t.y);
                if (pg.gx === eg.gx) t.dir = pg.gy < eg.gy ? "up" : "down";
                else if (pg.gy === eg.gy)
                  t.dir = pg.gx < eg.gx ? "left" : "right";
                else if (Math.random() < 0.5)
                  t.dir = pg.gx < eg.gx ? "left" : "right";
                else t.dir = pg.gy < eg.gy ? "up" : "down";
              } else if (Math.random() < 0.4) {
                t.dir = choice(DIRS);
              }
              if (Math.random() < 0.55) shoot(t);
            }
            const step = t.speed * dt;
            const moved = tryMove(
              t,
              t.dir === "left" ? -step : t.dir === "right" ? step : 0,
              t.dir === "up" ? -step : t.dir === "down" ? step : 0
            );
            t.trackOn = moved;
            if (t.trackOn) {
              t.trackPhase = (t.trackPhase + (t.speed * dt) / (TILE * 0.5)) % 1;
            } else {
              t.trackPhase = t.trackPhase * 0.9;
            }

            if (!moved) t.dir = choice(DIRS);
          }

          // Update bullets
          for (const b of S.bullets) {
            if (!b.active) continue;
            const dist = b.speed * dt;
            if (b.dir === "up") b.y -= dist;
            if (b.dir === "down") b.y += dist;
            if (b.dir === "left") b.x -= dist;
            if (b.dir === "right") b.x += dist;
            if (b.x < 0 || b.y < 0 || b.x > W || b.y > H) {
              b.active = false;
              releaseOwner(b.owner);
              continue;
            }
            const g = toGrid(b.x, b.y);
            if (within(g.gx, g.gy)) {
              const tt = S.map[g.gy][g.gx];
              if (
                tt.type === "brick" ||
                tt.type === "steel" ||
                tt.type === "base"
              ) {
                //TODO: note add more line
                damageTile(g.gx, g.gy, b.power);
                spawnExplosion(b.x, b.y, false);
                try {
                  playSfx("explode_wall");
                } catch (e) {}

                b.active = false;
                releaseOwner(b.owner);
                continue;
              }
            }
            // for (const t of S.tanks) {
            //   if (!t.active) continue;
            //   if (t.id === b.owner) continue;
            //   if (rectOverlap(b.x, b.y, 6, 6, t.x, t.y, t.size, t.size)) {
            //     t.hp -= b.power;
            //     b.active = false;
            //     releaseOwner(b.owner);
            //     if (t.hp <= 0) killTank(t);
            //     else if (t.isPlayer) {
            //       S.playerHP = t.hp;
            //       syncUI();
            //     }
            //     break;
            //   }
            // }

            //TODO: set god mode
            for (const t of S.tanks) {
              if (!t.active) continue;
              if (t.id === b.owner) continue;
              if (!rectOverlap(b.x, b.y, 6, 6, t.x, t.y, t.size, t.size))
                continue;

              // Ai l√† ch·ªß vi√™n ƒë·∫°n?
              const owner = S.tanks.find((z) => z.id === b.owner);
              const ownerIsPlayer = !!(owner && owner.isPlayer);

              // T·∫ÆT FRIENDLY FIRE:
              // - ƒê·∫°n ng∆∞·ªùi ch∆°i ch·ªâ l√†m ƒëau ƒë·ªãch (kh√¥ng bao gi·ªù tr√∫ng player).
              // - ƒê·∫°n ƒë·ªãch ch·ªâ l√†m ƒëau ng∆∞·ªùi ch∆°i (ƒëi xuy√™n qua xe ƒë·ªãch kh√°c).
              if (ownerIsPlayer && t.isPlayer) {
                // ƒë·∫°n c·ªßa m√¨nh ch·∫°m ch√≠nh m√¨nh -> b·ªè qua
                continue;
              }
              if (!ownerIsPlayer && !t.isPlayer) {
                // ƒë·∫°n ƒë·ªãch ch·∫°m xe ƒë·ªãch -> b·ªè qua (cho ƒë·∫°n ƒëi ti·∫øp)
                continue;
              }

              // √Åp d·ª•ng s√°t th∆∞∆°ng b√¨nh th∆∞·ªùng
              t.hp -= b.power;
              b.active = false;
              releaseOwner(b.owner);
              if (t.hp <= 0) {
                killTank(t);
              } else if (t.isPlayer) {
                S.playerHP = t.hp;
                syncUI();
              }
              break; // ƒë√£ x·ª≠ l√Ω va ch·∫°m cho vi√™n ƒë·∫°n n√†y
            }
          }
          // c·∫≠p nh·∫≠t explosions
          S.explosions = S.explosions.filter((e) => now - e.start < e.duration);
          updateSmokes(dt);
        }

        function releaseOwner(id) {
          const o = S.tanks.find((t) => t.id === id);
          if (o) o.hasBullet = false;
        }

        function tryMove(t, dx, dy) {
          if (!dx && !dy) return false;
          const nx = clamp(t.x + dx, t.size / 2, W - t.size / 2),
            ny = clamp(t.y + dy, t.size / 2, H - t.size / 2);
          if (blockedForTank(nx, ny, t.size)) return false;
          for (const o of S.tanks) {
            if (!o.active || o.id === t.id) continue;
            if (rectOverlap(nx, ny, t.size, t.size, o.x, o.y, o.size, o.size))
              return false;
          }
          t.x = nx;
          t.y = ny;
          return true;
        }
        function spawnExplosion(x, y, big = false) {
          S.explosions.push({
            x,
            y,
            big,
            start: performance.now(),
            duration: big ? 600 : 300,
          });
        }

        // ===== Render =====
        function roundRect(x, y, w, h, r) {
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
        }
        function drawStar(cx, cy, spikes, outer, inner) {
          let rot = (Math.PI / 2) * 3,
            x = cx,
            y = cy;
          ctx.beginPath();
          ctx.moveTo(cx, cy - outer);
          for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outer;
            y = cy + Math.sin(rot) * outer;
            ctx.lineTo(x, y);
            rot += Math.PI / spikes;
            x = cx + Math.cos(rot) * inner;
            y = cy + Math.sin(rot) * inner;
            ctx.lineTo(x, y);
            rot += Math.PI / spikes;
          }
          ctx.lineTo(cx, cy - outer);
          ctx.closePath();
        }

        // ===== Player Vietnam decals (star & flag) =====

        function drawFlag(
          ctx,
          x,
          y,
          fw,
          fh,
          time,
          amplitude = 2.5,
          wavelengthFactor = 2
        ) {
          const wavelength = fw / wavelengthFactor;

          ctx.beginPath();
          ctx.moveTo(x, y);
          for (let i = 0; i <= 40; i++) {
            const px = x + (fw / 40) * i;
            const wave = Math.sin(time + px / wavelength) * amplitude;
            const py = y + wave;
            ctx.lineTo(px, py);
          }
          for (let i = 40; i >= 0; i--) {
            const px = x + (fw / 40) * i;
            const wave = Math.sin(time + px / wavelength + 0.3) * amplitude;
            const py = y + fh + wave;
            ctx.lineTo(px, py);
          }
          ctx.closePath();

          ctx.fillStyle = "#d62828";
          ctx.fill();

          // Sao v√†ng ·ªü ch√≠nh gi·ªØa c·ªù (theo s√≥ng)
          const midX = x + fw * 0.5;
          const waveTop = Math.sin(time + midX / wavelength) * amplitude;
          const waveBot = Math.sin(time + midX / wavelength + 0.3) * amplitude;
          const midY = y + fh * 0.5 + (waveTop + waveBot) / 2;

          ctx.fillStyle = "#ffd54d";
          drawStar(midX, midY, 5, fh * 0.35, fh * 0.15);
          ctx.fill();
        }

        function drawVNDecals(t, x, y) {
          // x,y: g√≥c tr√°i‚Äìtr√™n c·ªßa th√¢n (ƒë√£ tr·ª´ gap ·ªü ph·∫ßn body)
          const bodyW = t.size - 2 * Math.max(4, Math.floor(t.size * 0.14)); // ƒë√∫ng b·∫±ng kh·ªëi th√¢n b·∫°n v·∫Ω
          const bodyH = bodyW;

          // 1) Ng√¥i sao v√†ng ·ªü h√¥ng (c·ªë ƒë·ªãnh, kh√¥ng xoay theo n√≤ng)
          const cx = x + bodyW * 0.3;
          const cy = y + bodyH * 0.5;
          const starOuter = Math.max(6, Math.floor(t.size * 0.12));
          const starInner = Math.max(3, Math.floor(starOuter * 0.45));
          // vi·ªÅn t·ªëi nh·ªè
          ctx.fillStyle = VN_COL.dark;
          drawStar(cx, cy, 5, starOuter + 2, starInner + 1);
          ctx.fill();
          // sao v√†ng
          ctx.fillStyle = VN_COL.star;
          drawStar(cx, cy, 5, starOuter, starInner);
          ctx.fill();

          // 2) C·ªù ƒë·ªè sao v√†ng tr√™n c·ªôt ƒÉng-ten ph√≠a sau
          const poleH = Math.max(18, Math.floor(t.size * 0.85));
          const poleX = x + bodyW * 0.82;
          const poleY = y - Math.max(6, Math.floor(t.size * 0.18));
          // c·ªôt
          ctx.strokeStyle = "#bfbfbf";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(poleX, poleY);
          ctx.lineTo(poleX, poleY - poleH);
          ctx.stroke();

          // c·ªù (ph·∫•p ph·ªõi nh·∫π theo th·ªùi gian)
          const now = performance.now() / 1000;
          const wave = Math.sin(now * 6) * 3; // bi√™n ƒë·ªô s√≥ng
          const fw = Math.max(16, Math.floor(t.size * 0.9));
          const fh = Math.max(10, Math.floor(t.size * 0.45));
          const fx = poleX + 2;
          const fy = poleY - poleH + fh / 2;

          ctx.fillStyle = VN_COL.flagR;
          ctx.beginPath();
          ctx.moveTo(fx, fy - fh / 2);
          ctx.lineTo(fx + fw * 0.5, fy - fh / 2 + wave);
          ctx.lineTo(fx + fw, fy + fh / 2 - wave);
          ctx.lineTo(fx + fw * 0.5, fy + fh / 2);
          ctx.closePath();
          ctx.fill();

          // sao nh·ªè tr√™n n·ªÅn c·ªù
          ctx.fillStyle = VN_COL.star;
          drawStar(
            fx + fw * 0.45,
            fy,
            5,
            Math.max(5, Math.floor(fh * 0.35)),
            Math.max(2, Math.floor(fh * 0.17))
          );
          ctx.fill();
        }

        function drawThanhCoFlat(x, y, size, alive) {
          if (!alive) {
            // N·∫øu base ƒë√£ b·ªã ph√° -> kh·ªëi x√°m
            ctx.fillStyle = "#444";
            roundRect(x + 4, y + 4, size - 8, size - 8, 6);
            ctx.fill();
            return;
          }

          const towerH = size * 0.9;
          const towerW = size * 0.9;
          const tx = x + (size - towerW) / 2;
          const ty = y + (size - towerH) / 2;

          // === Th√¢n th√†nh c·ªï (nhi·ªÅu t·∫ßng, m√†u ƒë·∫•t ƒë·ªè cam loang) ===
          function fillWall(color1, color2, rx, ry, rw, rh) {
            // gradient d·ªçc nh·∫π
            const g = ctx.createLinearGradient(rx, ry, rx, ry + rh);
            g.addColorStop(0, color1);
            g.addColorStop(1, color2);
            ctx.fillStyle = g;
            ctx.fillRect(rx, ry, rw, rh);
            // ƒëi·ªÉm loang ng·∫´u nhi√™n
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            for (let i = 0; i < 4; i++) {
              ctx.fillRect(
                rx + Math.random() * rw,
                ry + Math.random() * rh,
                2,
                2
              );
            }
          }

          // t·∫ßng d∆∞·ªõi
          fillWall(
            "#c96e35",
            "#a85728",
            tx,
            ty + towerH * 0.55,
            towerW,
            towerH * 0.45
          );
          // t·∫ßng gi·ªØa
          fillWall(
            "#d87c40",
            "#b4652f",
            tx + towerW * 0.1,
            ty + towerH * 0.35,
            towerW * 0.8,
            towerH * 0.25
          );
          // t·∫ßng tr√™n
          fillWall(
            "#e2924d",
            "#c67a35",
            tx + towerW * 0.25,
            ty + towerH * 0.15,
            towerW * 0.5,
            towerH * 0.2
          );

          // === M√°i ng√≥i ƒë·ªè c√≥ highlight ===
          ctx.beginPath();
          ctx.moveTo(tx + towerW * 0.25, ty + towerH * 0.15);
          ctx.lineTo(tx + towerW * 0.75, ty + towerH * 0.15);
          ctx.lineTo(tx + towerW * 0.65, ty);
          ctx.lineTo(tx + towerW * 0.35, ty);
          ctx.closePath();
          const roofGrad = ctx.createLinearGradient(
            tx,
            ty,
            tx,
            ty + towerH * 0.15
          );
          roofGrad.addColorStop(0, "#b00");
          roofGrad.addColorStop(1, "#800");
          ctx.fillStyle = roofGrad;
          ctx.fill();

          // === C√°c c·ª≠a s·ªï nh·ªè (ch·∫•m ƒëen) ===
          ctx.fillStyle = "#111";
          ctx.fillRect(tx + towerW * 0.2, ty + towerH * 0.6, 4, 6);
          ctx.fillRect(tx + towerW * 0.5, ty + towerH * 0.6, 4, 6);
          ctx.fillRect(tx + towerW * 0.7, ty + towerH * 0.6, 4, 6);

          // === C·ªôt c·ªù ===
          ctx.strokeStyle = "#666";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + size / 2, ty);
          ctx.lineTo(x + size / 2, ty - size * 0.45);
          ctx.stroke();

          const time = performance.now() / 900; // t·ªëc ƒë·ªô ch·∫≠m
          const flagX = x + size / 2; // g√≥c tr√°i‚Äìtr√™n c·ªßa l√° c·ªù
          const flagY = ty - size * 0.45;
          drawFlag(ctx, flagX, flagY, size * 0.55, size * 0.28, time, 3, 2);
        }
        // RNG theo (gx, gy) ƒë·ªÉ b·ª•i c√¢y m·ªói √¥ h∆°i kh√°c nhau nh∆∞ng c·ªë ƒë·ªãnh
        function rngFromGrid(gx, gy) {
          let s = (gx * 73856093) ^ (gy * 19349663);
          s ^= s << 13;
          s ^= s >>> 17;
          s ^= s << 5;
          return function () {
            s ^= s << 13;
            s ^= s >>> 17;
            s ^= s << 5;
            return (s >>> 0) / 4294967295;
          };
        }
        // V·∫Ω 1 ‚Äúl√°/lobe‚Äù m·ªÅm theo h∆∞·ªõng angle
        function drawLeafLobe(cx, cy, r, angle) {
          const w = r * 0.85; // d√†i l√°
          const h = r * 0.55; // b·ªÅ ngang
          const tip = w; // ƒë·∫ßu l√°
          const sway = 0.15 * r; // ƒë·ªô cong th√¢n l√°

          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(angle);

          // b√≥ng d∆∞·ªõi l√° (r·∫•t nh·∫π)
          ctx.fillStyle = "rgba(0,0,0,0.10)";
          ctx.beginPath();
          ctx.ellipse(0, h * 0.4, w * 0.9, h * 0.35, 0, 0, Math.PI * 2);
          ctx.fill();

          // th√¢n l√°: xanh s√°ng -> xanh ƒë·∫≠m
          const grad = ctx.createLinearGradient(0, 0, w, 0);
          grad.addColorStop(0.0, "#b6e07a");
          grad.addColorStop(0.5, "#6fbe56");
          grad.addColorStop(1.0, "#2e7f32");
          ctx.fillStyle = grad;

          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.quadraticCurveTo(w * 0.35, -sway, tip, 0); // m√©p tr√™n
          ctx.quadraticCurveTo(w * 0.35, sway, 0, 0); // m√©p d∆∞·ªõi quay v·ªÅ g·ªëc
          ctx.closePath();
          ctx.fill();

          // g√¢n l√° m·∫£nh
          ctx.strokeStyle = "rgba(255,255,255,0.28)";
          ctx.lineWidth = Math.max(1, r * 0.08);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.quadraticCurveTo(w * 0.45, 0, tip, 0);
          ctx.stroke();

          ctx.restore();
        }

        // V·∫Ω 1 ‚Äúc·ª•m b·ª•i‚Äù (nhi·ªÅu lobe) ‚Äî c√≥ ƒëung ƒë∆∞a theo gi√≥
        function drawBushBlob(cx, cy, r, swayX, rndAngleOffset = 0) {
          // b√≥ng ƒë·ªï c·ªßa c·∫£ c·ª•m
          ctx.fillStyle = "rgba(0,0,0,0.22)";
          ctx.beginPath();
          ctx.ellipse(
            cx + swayX * 0.25,
            cy + r * 0.55,
            r * 1.05,
            r * 0.35,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();

          // nh√≥m l√°: v·∫Ω t·ª´ nh·ªè -> l·ªõn ƒë·ªÉ c√≥ chi·ªÅu s√¢u
          const count = 12; // s·ªë l√°
          for (let i = 0; i < count; i++) {
            const t = (i + 1) / count;
            const rr = r * (0.55 + t * 0.55); // b√°n k√≠nh l√°
            const ang = rndAngleOffset + i * ((Math.PI * 2) / count);
            const localTilt = swayX * 0.02; // xoay nh·∫π theo gi√≥
            drawLeafLobe(
              cx + swayX * (0.25 + 0.35 * t) + Math.cos(ang) * r * 0.06,
              cy - r * 0.08 * (1 - t),
              rr,
              ang + localTilt
            );
          }

          // highlight vi·ªÅn ngo√†i r·∫•t nh·∫π
          ctx.strokeStyle = "rgba(255,255,255,0.20)";
          ctx.lineWidth = Math.max(1, r * 0.1);
          ctx.beginPath();
          ctx.arc(cx + swayX * 0.25, cy - r * 0.1, r * 0.85, -0.2, 1.0);
          ctx.stroke();
        }

        // V·∫Ω 1 tile b·ª•i (g·ªçi nhi·ªÅu blob + sway theo gi√≥ t·ª´ng l·ªõp)
        function drawBushTile(gx, gy, x, y, size) {
          const rnd = rngFromGrid(gx, gy); // ·ªïn ƒë·ªãnh theo √¥
          const cx = x + size * 0.5;
          const cy = y + size * 0.62;

          // gi√≥ t·∫°i tile + nhi·ªÖu nh·ªè gi·ªØa c√°c l·ªõp
          const swayBase = windAtTile(gx, gy, 1); // px
          const sway1 = swayBase * (0.9 + rnd() * 0.2);
          const sway2 = swayBase * (0.6 + rnd() * 0.2);
          const sway3 = swayBase * (0.35 + rnd() * 0.2);

          const R = size * 0.5;

          // c·ª•m sau xa nh·∫•t
          drawBushBlob(
            cx,
            cy - size * 0.08,
            R * (0.7 + rnd() * 0.1),
            sway3,
            rnd() * Math.PI * 2
          );

          // c·ª•m sau
          drawBushBlob(
            cx - size * 0.04,
            cy - size * 0.03,
            R * (0.9 + rnd() * 0.1),
            sway3,
            rnd() * Math.PI * 2
          );

          // c·ª•m gi·ªØa
          drawBushBlob(
            cx + size * 0.06,
            cy + rnd() * size * 0.02,
            R * (1.0 + rnd() * 0.12),
            sway2,
            rnd() * Math.PI * 2
          );

          // c·ª•m tr∆∞·ªõc (to nh·∫•t)
          drawBushBlob(
            cx - size * 0.08,
            cy,
            R * (1.2 + rnd() * 0.15),
            sway1,
            rnd() * Math.PI * 2
          );

          // c·ª•m tr∆∞·ªõc ph·ª• (b·ªï sung cho r·∫≠m)
          drawBushBlob(
            cx + size * 0.04,
            cy + size * 0.05,
            R * (1.1 + rnd() * 0.1),
            sway1,
            rnd() * Math.PI * 2
          );
        }

        function draw() {
          ctx.clearRect(0, 0, W, H);
          // N·ªÅn ƒë·∫•t tr·∫≠n ƒë·ªãa (pattern n√¢u ƒë·∫•t)
          ctx.fillStyle = getGroundPattern(ctx);
          ctx.fillRect(0, 0, W, H);
          drawCurvedRiverRibbon();
          drawRiverLabel();
          drawBridges();
          for (let gy = 0; gy < GRID; gy++) {
            for (let gx = 0; gx < GRID; gx++) {
              const t = S.map[gy][gx];
              const x = gx * TILE,
                y = gy * TILE;
              if (t.type === "empty") {
                if (((gx + gy) & 1) === 0) {
                  ctx.globalAlpha = 0.06;
                  ctx.fillStyle = "#b8a76a"; // nh·∫•n nh√° v√†ng c√°t r·∫•t nh·∫π
                  ctx.fillRect(x, y, TILE, TILE);
                  ctx.globalAlpha = 1;
                }
              } else if (t.type === "brick") {
                ctx.fillStyle = "#b55239";
                ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 4);
                ctx.strokeStyle = "#8a3f2b";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x + 2, y + TILE / 2);
                ctx.lineTo(x + TILE - 2, y + TILE / 2);
                ctx.moveTo(x + TILE / 2, y + 2);
                ctx.lineTo(x + TILE / 2, y + TILE - 2);
                ctx.stroke();
              } else if (t.type === "steel") {
                ctx.fillStyle = "#9aa3ad";
                roundRect(x + 2, y + 2, TILE - 4, TILE - 4, 4);
                ctx.fill();
                ctx.strokeStyle = "#6b7680";
                ctx.lineWidth = 2;
                ctx.stroke();
              } else if (t.type === "river") {
                // River tile no longer painted per-tile (drawn by ribbon). Do nothing here.
              } else if (t.type === "base") {
                drawThanhCoFlat(x, y, TILE, S.base.alive);
              }
            }
          }
          // items
          for (const it of S.items) {
            if (!it.active) continue;
            const x = it.x - TILE / 2,
              y = it.y - TILE / 2;
            if (it.kind === "star") {
              ctx.fillStyle = "#ffd700";
              drawStar(it.x, it.y, 5, TILE / 2 - 4, 6);
              ctx.fill();
              ctx.strokeStyle = "#9e7b00";
              ctx.lineWidth = 2;
              ctx.stroke();
            } else {
              ctx.fillStyle = "#c0c0c0";
              roundRect(x + 4, y + 4, TILE - 8, (TILE - 8) * 0.55, 6);
              ctx.fill();
              ctx.fillStyle = "#9a9a9a";
              ctx.fillRect(
                x + (TILE - 8) * 0.46,
                y + 4 + (TILE - 8) * 0.55,
                (TILE - 8) * 0.08,
                (TILE - 8) * 0.4
              );
            }
          }
          // bullets
          for (const b of S.bullets) {
            if (!b.active) continue;
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
            ctx.fill();
          }

          // smokes (player only) ‚Äî v·∫Ω d∆∞·ªõi xe
          for (const s of S.smokes) {
            const k = Math.max(0, s.life / s.max); // 1 -> 0
            const baseR = Math.max(2, s.r);
            const R = baseR * (1 + 0.6 * (1 - k)); // l·ªõn d·∫ßn √≠t h∆°n
            const squash = 1 + 0.25 * (1 - k); // elip nh·∫π

            // L·ªõp 1: l√µi t·ªëi
            ctx.globalAlpha = 0.18 + 0.22 * k;
            ctx.fillStyle = s.c0 + (0.8 * k + 0.1) + ")";
            ctx.beginPath();
            ctx.ellipse(s.x, s.y, R * 0.7, R * 0.7 * squash, 0, 0, Math.PI * 2);
            ctx.fill();

            // L·ªõp 2: x√°m xanh
            ctx.globalAlpha = 0.15 + 0.18 * k;
            ctx.fillStyle = s.c1 + (0.5 * k + 0.1) + ")";
            ctx.beginPath();
            ctx.ellipse(s.x, s.y, R, R * squash, 0, 0, Math.PI * 2);
            ctx.fill();

            // L·ªõp 3: vi·ªÅn s√°ng nh·∫°t
            ctx.globalAlpha = 0.1 + 0.12 * k;
            ctx.fillStyle = s.c2 + 0.35 * k + ")";
            ctx.beginPath();
            ctx.ellipse(
              s.x,
              s.y,
              R * 1.25,
              R * 1.25 * squash,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            ctx.globalAlpha = 1;
          }

          // tanks (x√≠ch h√†i h√≤a + th√¢n + th√°p ph√°o tr√≤n + decal Vi·ªát Nam cho player)
          for (const t of S.tanks) {
            if (!t.active) continue;

            const x = t.x - t.size / 2;
            const y = t.y - t.size / 2;

            // m√†u th√¢n cho ƒë·ªãch (player s·∫Ω override b·∫±ng VN_COL)
            const enemyBody = t.kind === "armored" ? "#ff6b6b" : "#f0ad4e";

            // ---------- X√çCH (m√†u h√†i h√≤a) ----------
            const trackW = Math.max(6, Math.floor(t.size * 0.22));
            const rungStep = 6;
            const rungOffset = Math.floor((t.trackPhase || 0) * rungStep);
            const trackBase = t.isPlayer ? VN_COL.dark : "#2b2b2b";
            const trackRung = t.isPlayer ? "#2f4030" : "#444";

            ctx.fillStyle = trackBase;

            if (t.dir === "up" || t.dir === "down") {
              // d·ªçc: x√≠ch tr√°i/ph·∫£i
              ctx.fillRect(x, y, trackW, t.size);
              ctx.fillRect(x + t.size - trackW, y, trackW, t.size);

              // rƒÉng x√≠ch cu·ªôn
              ctx.fillStyle = trackRung;
              for (
                let yy = y - rungOffset;
                yy < y + t.size + rungStep;
                yy += rungStep
              ) {
                ctx.fillRect(x + 1, yy, trackW - 2, 2); // tr√°i
                ctx.fillRect(x + t.size - trackW + 1, yy, trackW - 2, 2); // ph·∫£i
              }
            } else {
              // ngang: x√≠ch tr√™n/d∆∞·ªõi
              ctx.fillRect(x, y, t.size, trackW);
              ctx.fillRect(x, y + t.size - trackW, t.size, trackW);

              ctx.fillStyle = trackRung;
              for (
                let xx = x - rungOffset;
                xx < x + t.size + rungStep;
                xx += rungStep
              ) {
                ctx.fillRect(xx, y + 1, 2, trackW - 2); // tr√™n
                ctx.fillRect(xx, y + t.size - trackW + 1, 2, trackW - 2); // d∆∞·ªõi
              }
            }

            // ---------- TH√ÇN ----------
            const gap = Math.max(4, Math.floor(t.size * 0.14)); // l·ªÅ v√†o th√¢n
            const bx = x + gap,
              by = y + gap,
              bw = t.size - gap * 2,
              bh = bw;

            if (t.isPlayer) {
              // n·ªÅn olive VN + r·∫±n ri
              ctx.fillStyle = VN_COL.green;
              roundRect(bx, by, bw, bh, 6);
              ctx.fill();

              ctx.fillStyle = VN_COL.green2; // 2 m·∫£ng r·∫±n ri nh·∫π
              ctx.beginPath();
              ctx.moveTo(bx, by + bh * 0.26);
              ctx.lineTo(bx + bw * 0.52, by + bh * 0.06);
              ctx.lineTo(bx + bw * 0.84, by + bh * 0.2);
              ctx.lineTo(bx + bw * 0.34, by + bh * 0.4);
              ctx.closePath();
              ctx.fill();

              ctx.beginPath();
              ctx.moveTo(bx + bw * 0.12, by + bh * 0.7);
              ctx.lineTo(bx + bw * 0.68, by + bh * 0.48);
              ctx.lineTo(bx + bw * 0.94, by + bh * 0.63);
              ctx.lineTo(bx + bw * 0.36, by + bh * 0.86);
              ctx.closePath();
              ctx.fill();

              // ----- Ng√¥i sao cƒÉn gi·ªØa th√¢n -----
              const cx = bx + bw * 0.5;
              const cy = by + bh * 0.5;
              const starOuter = Math.max(6, Math.floor(t.size * 0.12));
              const starInner = Math.max(3, Math.floor(starOuter * 0.45));
              // vi·ªÅn t·ªëi m·∫£nh ƒë·ªÉ n·ªïi b·∫≠t
              ctx.fillStyle = VN_COL.dark;
              drawStar(cx, cy, 5, starOuter + 2, starInner + 1);
              ctx.fill();
              // sao v√†ng
              ctx.fillStyle = VN_COL.star;
              drawStar(cx, cy, 5, starOuter, starInner);
              ctx.fill();

              // ----- C·ªôt c·ªù ph√≠a sau‚Äìtr√°i (v·ªã tr√≠ h·ª£p l√Ω h∆°n) -----
              const poleH = Math.max(18, Math.floor(t.size * 0.85));
              const poleX = bx + bw * 0.12; // s√°t g√≥c sau‚Äìtr√°i
              const poleY = by - Math.max(6, Math.floor(t.size * 0.18));
              ctx.strokeStyle = "#bfbfbf";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(poleX, poleY);
              ctx.lineTo(poleX, poleY - poleH);
              ctx.stroke();

              const time = performance.now() / 900; // c√πng t·ªëc ƒë·ªô v·ªõi th√†nh c·ªï
              const fw = Math.max(16, Math.floor(t.size * 0.9));
              const fh = Math.max(10, Math.floor(t.size * 0.45));
              const fx = poleX + 2;
              const fy = poleY - poleH; // y l√† m√©p tr√™n c·ªßa c·ªù

              // G·ªçi h√†m c·ªù chung v·ªõi c√πng tham s·ªë chuy·ªÉn ƒë·ªông
              drawFlag(ctx, fx, fy, fw, fh, time, 3, 2);
            } else {
              // ƒë·ªãch gi·ªØ m√†u c≈©
              ctx.fillStyle = enemyBody;
              roundRect(bx, by, bw, bh, 6);
              ctx.fill();
            }

            // ---------- TH√ÅP PH√ÅO TR√íN + N√íNG S√öNG ----------
            // th√°p ph√°o n·∫±m tr√™n th√¢n, n√≤ng xu·∫•t ph√°t t·ª´ t√¢m th√°p ph√°o (t.x, t.y)
            const turretOuter = t.size * 0.28;
            const turretInner = t.size * 0.22;
            const barrelLen = Math.max(12, Math.floor(t.size * 0.35));

            // vi·ªÅn t·ªëi c·ªßa th√°p
            ctx.fillStyle = t.isPlayer ? VN_COL.dark : "#333";
            ctx.beginPath();
            ctx.arc(t.x, t.y, turretOuter, 0, Math.PI * 2);
            ctx.fill();
            // m·∫∑t th√°p
            ctx.fillStyle = t.isPlayer ? VN_COL.green : enemyBody;
            ctx.beginPath();
            ctx.arc(t.x, t.y, turretInner, 0, Math.PI * 2);
            ctx.fill();

            // n√≤ng s√∫ng (d√†y nh·∫π ƒë·ªÉ c√¢n ƒë·ªëi)
            ctx.fillStyle = "#2e2e2e";
            const bwid = 6;
            if (t.dir === "up")
              ctx.fillRect(t.x - bwid / 2, t.y - barrelLen, bwid, barrelLen);
            if (t.dir === "down")
              ctx.fillRect(t.x - bwid / 2, t.y, bwid, barrelLen);
            if (t.dir === "left")
              ctx.fillRect(t.x - barrelLen, t.y - bwid / 2, barrelLen, bwid);
            if (t.dir === "right")
              ctx.fillRect(t.x, t.y - bwid / 2, barrelLen, bwid);

            // ---------- HP nh·ªè ·ªü ƒëu√¥i ----------
            ctx.fillStyle = "#000";
            for (let i = 0; i < t.hp; i++)
              ctx.fillRect(x + 4 + i * 6, y + t.size - 10, 4, 6);
          }

          // explosions
          for (const e of S.explosions) {
            const age = performance.now() - e.start;
            const ratio = age / e.duration;
            const maxR = e.big ? 32 : 16;
            const r = maxR * ratio;
            ctx.globalAlpha = 1 - ratio;
            ctx.fillStyle = e.big ? "#ff9933" : "#ffff66";
            ctx.beginPath();
            ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }

          // bushes on top
          for (const key of S.bushSet) {
            const [gx, gy] = key.split(",").map(Number);
            const x = gx * TILE,
              y = gy * TILE;
            drawBushTile(gx, gy, x, y, TILE);
          }
          if (S.status === "won" || S.status === "lost") {
            /* overlay already shows text */
          }
        }

        // ===== Buttons =====
        btnStart.onclick = () => {
          ensureAudio();
          AUDIO.ctx.resume(); // Chrome y√™u c·∫ßu c√≥ gesture
          resetGame();
        };
        btnRestart.onclick = () => {
          ensureAudio();
          AUDIO.ctx.resume();
          resetGame();
        };
        // ===== Sound UI init & events =====
        (function initSoundUI() {
          // ƒë·ªçc prefs ƒë√£ l∆∞u
          loadSoundPref(); // ON/OFF
          loadVolumePref(); // slider (0..100 hi·ªÉn th·ªã)
          updateSoundUI(); // c·∫≠p nh·∫≠t pill Sound
          updateVolumeUI(); // ƒë·ªìng b·ªô tr·∫°ng th√°i slider

          // Toggle Sound ON/OFF (click + keyboard)
          if (btnSound) {
            const toggleSound = () => {
              ensureAudio();
              AUDIO.enabled = !AUDIO.enabled;
              try {
                if (AUDIO.ctx)
                  AUDIO.enabled ? AUDIO.ctx.resume() : AUDIO.ctx.suspend();
              } catch (e) {}
              saveSoundPref();
              updateSoundUI();
              updateVolumeUI();
            };
            btnSound.addEventListener("click", toggleSound);
            btnSound.addEventListener("keydown", (e) => {
              if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                toggleSound();
              }
            });
          }

          // Slider volume (0..100 -> 0..1)
          if (volSlider) {
            const onSlide = (val) => {
              const v = Math.max(0, Math.min(100, Number(val))) / 100;
              // n·∫øu ch∆∞a c√≥ ctx, ch·ªâ l∆∞u pref; khi Start m·ªõi apply
              if (AUDIO.ctx && AUDIO.master) AUDIO.master.gain.value = v;
              saveVolumePref(v);
            };
            volSlider.addEventListener("input", (e) => onSlide(e.target.value));
            volSlider.addEventListener("change", (e) =>
              onSlide(e.target.value)
            );
          }
        })();

        // Pre-draw map for menu
        setupLevel();
        draw();
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
