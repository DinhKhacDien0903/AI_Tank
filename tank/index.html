<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>üî• 81 Ng√†y ƒê√™m B·∫£o V·ªá Th√†nh C·ªï Qu·∫£ng Tr·ªã 1972</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f172a;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #22c55e;
      --accent2: #6366f1;
      --danger: #ef4444;
      --steel: #38bdf8;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      /* N·ªÅn ho√†ng h√¥n kh√≥i b·ª•i: n√¢u ƒë·∫≠m -> n√¢u ƒë·∫•t */
      background: linear-gradient(180deg, #11100e, #2a261b);
      color: var(--text);
      font: 14px/1.4 system-ui, Segoe UI, Roboto, Helvetica, Arial;
    }

    .wrap {
      max-width: 900px;
      margin: 24px auto;
      padding: 16px;
    }

    h1 {
      font-size: 24px;
      margin: 0 0 12px;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }

    .row {
      display: flex;
      gap: 16px;
      align-items: center;
    }

    .pill {
      background: #1f2937;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 12px;
    }

    .pill.btn {
      cursor: pointer;
      user-select: none;
    }

    .pill.off {
      background: #374151;
    }

    /* slider trong pill √¢m l∆∞·ª£ng */
    #uiVol input[type="range"] {
      width: 120px;
      accent-color: var(--accent2);
      vertical-align: middle;
    }

    #uiVol.off input[type="range"] {
      opacity: 0.5;
      pointer-events: none;
    }

    .pill.steel {
      background: #0c4a6e;
    }

    .frame {
      position: relative;
      margin-top: 12px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    .board {
      position: relative;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid #0f172a;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.4);
    }

    canvas {
      display: block;
      width: 480px;
      height: 480px;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.6);
      gap: 12px;
      text-align: center;
    }

    .overlay h2 {
      margin: 0;
      font-size: 28px;
    }

    .btns {
      display: flex;
      gap: 10px;
    }

    .btn {
      appearance: none;
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
      transition: 0.2s transform, 0.2s opacity;
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn.start {
      background: var(--accent);
      color: #001507;
    }

    .btn.restart {
      background: var(--accent2);
      color: white;
    }

    .muted {
      color: var(--muted);
    }

    .tips {
      font-size: 12px;
      color: var(--muted);
    }

    @media (min-width: 720px) {
      .frame {
        grid-template-columns: 480px 1fr;
        align-items: start;
      }
    }

    .card {
      background: var(--panel);
      border: 1px solid #1f2937;
      border-radius: 16px;
      padding: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>üî• 81 Ng√†y ƒê√™m B·∫£o V·ªá Th√†nh C·ªï Qu·∫£ng Tr·ªã 1972</h1>
    <div class="hud">
      <div class="row">
        <span class="pill">Lives: <b id="uiLives">3</b></span>
        <span class="pill">HP: <b id="uiHP">3</b></span>
        <span class="pill">Power: <b id="uiPower">1</b></span>
        <span class="pill">Level: <b>1</b></span>
      </div>
      <div class="row">
        <span class="pill">Enemies Left: <b id="uiEnemies">20</b></span>
        <span class="pill">Score: <b id="uiScore">0</b></span>
        <span class="pill">Time: <b id="uiTime">3:00</b></span>
        <span id="uiBaseState" class="pill">Base: BRICK</span>
        <span id="uiSound" class="pill" role="button" tabindex="0">üîä Sound: ON</span>
        <span id="uiVol" class="pill">
          Vol:
          <input id="uiVolSlider" type="range" min="0" max="100" value="25"
            style="vertical-align: middle; width: 100px" />
        </span>
      </div>
    </div>

    <div class="frame">
      <div class="board">
        <canvas id="game" width="480" height="480"></canvas>
        <div id="overlay" class="overlay">
          <p>Ph√≠m ƒëi·ªÅu khi·ªÉn: ‚Üê ‚Üí ‚Üë ‚Üì, b·∫Øn: Space</p>
          <div class="btns">
            <button id="btnStart" class="btn start">Start</button>
          </div>
        </div>
      </div>

      <div class="card">
        <b>Lu·∫≠t ch∆°i</b>
        <ul>
          <li>Di·ªát 20 xe ƒë·ªãch (10 Basic, 10 Armored) trong 3 ph√∫t.</li>
          <li>B·∫£o v·ªá cƒÉn c·ª© ƒë·∫°i b√†ng (2 l·ªõp g·∫°ch). Shovel bi·∫øn t∆∞·ªùng th√†nh th√©p 20s; h·∫øt th·ªùi gian t·ª± h·ªìi ph·ª•c t∆∞·ªùng
            g·∫°ch.</li>
          <li>Star: +1 power; xu·∫•t hi·ªán ng·∫´u nhi√™n. M·ªói v·∫≠t ph·∫©m +50 ƒëi·ªÉm.</li>
          <li>M√°y bay: Nhanh h∆°n xe tƒÉng √ó2; ra kh·ªèi b·∫£n ƒë·ªì th√¨ bi·∫øn m·∫•t; kh√¥ng th·ªÉ b·∫Øn h·∫° v√† kh√¥ng t√≠nh v√†o 20 xe ƒë·ªãch.
          </li>
          <li>Bom m√°y bay: m·ªói l·∫ßn ch·ªâ 1 qu·∫£</li>
          <li>Thua khi h·∫øt 3 m·∫°ng ho·∫∑c cƒÉn c·ª© b·ªã ph√°. H·∫øt gi·ªù m√† cƒÉn c·ª© c√≤n & c√≤n m·∫°ng ‚áí Th·∫Øng.</li>
        </ul>

        <p class="tips">
          G·ª£i √Ω: Ch·∫∑n ƒë∆∞·ªùng h·∫πp, t·∫≠n d·ª•ng s√¥ng & b·ª•i c√¢y ƒë·ªÉ √°p s√°t!
        </p>
        <div class="btns" style="margin-top: 8px">
          <button id="btnRestart" class="btn restart" style="display: none">
            Restart
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      "use strict";
      // ===== Constants =====
      const TILE = 32,
        GRID = 15,
        W = TILE * GRID,
        H = TILE * GRID;
      const PLAY_SECONDS = 180; // 3 minutes
      // === Airplane & Bomb config ===
      const PLANE_CFG = {
        startAfter: 25, // xu·∫•t hi·ªán sau 30s
        speed: 170, // nhanh g·∫•p ~2 l·∫ßn tank ng∆∞·ªùi ch∆°i (100)
        dropCount: 6, // m·ªói l·∫ßn bay th·∫£ 5 qu·∫£ bom
        size: 22, // k√≠ch th∆∞·ªõc v·∫Ω m√°y bay (px)
        bombFall: 260, // t·ªëc ƒë·ªô r∆°i c·ªßa bom (px/s)
        killRadius: 14, // r∆°i tr√∫ng (ƒë√® l√™n) -> ch·∫øt lu√¥n
        splashAdjDamage: 1, // n·ªï c·∫°nh 1 √¥ -> -1 HP
        spriteFix: Math.PI, // sprite c·ªßa b·∫°n m≈©i ƒëang h∆∞·ªõng NG∆Ø·ª¢C v·ªõi vector bay => b√π 180¬∞
        flipVertical: true, // NEW: l·∫≠t d·ªçc ƒë·ªÉ kh√¥ng b·ªã "√∫p b·ª•ng"
      };
      const MAX_ACTIVE_ENEMIES = 4,
        TOTAL_BASIC = 10,
        TOTAL_ARMORED = 10;
      const DEV_GOD_MODE = false; // <- b·∫≠t/t·∫Øt b·∫•t t·ª≠ cho ng∆∞·ªùi ch∆°i
      // ===== Vietnam scheme colors =====
      // ===== Vietnam scheme colors =====
      const VN_COL = {
        green: "#2fbf6b", // xanh t∆∞∆°i h∆°n (primary body)
        green2: "#1e8f4d", // m·∫£ng r·∫±n ri ƒë·∫≠m h∆°n
        dark: "#0d3a26", // vi·ªÅn t·ªëi / track
        star: "#ffd34d",
        flagR: "#d62828",
      };
      // Kamehameha bullet colors
      const BULLET_COL = {
        player: {
          // gi·ªØ nguy√™n m√†u ng∆∞·ªùi ch∆°i
          core: "#9be7ff",
          aura: "rgba(80, 180, 255, 0.55)",
        },
        enemyBasic: {
          // ƒë·ªãch power 1
          core: "#ffd06b",
          aura: "rgba(255, 170, 60, 0.55)",
        },
        enemyArmored: {
          // ƒë·ªãch power 2
          core: "#ff6b6b",
          aura: "rgba(255, 70, 70, 0.55)",
        },
      };

      // ===== Ground pattern (ƒë·∫•t tr·∫≠n ƒë·ªãa) =====
      let GROUND_PATTERN = null;
      function getGroundPattern(ctx) {
        if (GROUND_PATTERN) return GROUND_PATTERN;

        // T·∫°o 1 tile 64x64 r·ªìi l·∫∑p
        const p = document.createElement("canvas");
        p.width = p.height = 64;
        const pc = p.getContext("2d");

        // N√¢u ƒë·∫•t n·ªÅn
        pc.fillStyle = "#d2b48c";
        pc.fillRect(0, 0, 64, 64);

        // H·∫°t b·ª•i v√†ng c√°t r·∫•t m·ªù r·∫£i ng·∫´u nhi√™n
        pc.globalAlpha = 0.08;
        pc.fillStyle = "#c2a264";
        for (let i = 0; i < 120; i++) {
          pc.fillRect(Math.random() * 64, Math.random() * 64, 1, 1);
        }
        pc.globalAlpha = 1;

        GROUND_PATTERN = ctx.createPattern(p, "repeat");
        return GROUND_PATTERN;
      }

      // ===== Th·∫°ch H√£n River: carve tiles by a horizontal sine-band =====
      // ===== Curved River: build a smooth ribbon path (no tile marking) =====
      function carveCurvedRiver(opts = {}) {
        // Tham s·ªë theo TILE ƒë·ªÉ d·ªÖ h√¨nh dung
        const baseY = opts.baseY ?? 7; // ƒë∆∞·ªùng trung t√¢m (ƒë∆°n v·ªã h√†ng tile)
        const amp = opts.amp ?? 1.5; // ƒë·ªô u·ªën (tile)
        const freq = opts.freq ?? 0.55; // nh·ªãp u·ªën theo c·ªôt gx
        const phase = opts.phase ?? 0.0; // d·ªãch pha
        const visualWidth = opts.visualWidth ?? TILE * 1.2; // b·ªÅ r·ªông v·∫Ω (px), m·∫£nh

        // L·∫•y m·∫´u theo px ƒë·ªÉ t·∫°o polyline cong m∆∞·ª£t ch·∫°y ngang b·∫£n ƒë·ªì
        const pts = [];
        const stepPx = 8; // 8px/m·∫´u l√† ƒë·ªß m∆∞·ª£t
        for (let x = 0; x <= W; x += stepPx) {
          const gx = x / TILE;
          const yTiles = baseY + Math.sin(phase + gx * freq) * amp;
          const y = yTiles * TILE + TILE / 2;
          pts.push({ x, y });
        }
        S.riverPath = {
          points: pts,
          width: visualWidth,
          wave: { amplitude: 1.0, spacing: 36, speed: 0.35 },
        };
      }
      // T·∫°o m·ªôt c√¢y c·∫ßu vu√¥ng g√≥c v·ªõi d√≤ng ch·∫£y t·∫°i ƒëi·ªÉm gi·ªØa ƒëo·∫°n i..i+1 c·ªßa path
      function makeBridgeAt(pts, i, walkWidth = TILE * 1.5, span = null) {
        const a = pts[i],
          b = pts[i + 1];
        if (!a || !b) return null;
        let dx = b.x - a.x,
          dy = b.y - a.y;
        const len = Math.hypot(dx, dy) || 1;
        dx /= len;
        dy /= len;
        let nx = -dy,
          ny = dx;

        const riverW = (S.riverPath?.width || TILE) * 1.1; // tr√πm m√©p nhi·ªÅu h∆°n
        const L = span ?? riverW + TILE * 1.6; // d√†i h∆°n ƒë·ªÉ nh√¨n c√¢n

        const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
        const p1 = { x: mid.x - (nx * L) / 2, y: mid.y - (ny * L) / 2 };
        const p2 = { x: mid.x + (nx * L) / 2, y: mid.y + (ny * L) / 2 };
        return { a: p1, b: p2, width: walkWidth };
      }

      // Th√™m v√†i c√¢y c·∫ßu r·∫£i d·ªçc s√¥ng
      function buildRiverBridges() {
        S.bridges = [];
        if (!S.riverPath?.points?.length) return;
        const pts = S.riverPath.points;
        const idx = [
          Math.floor(pts.length * 0.12), // c·∫ßu ƒë·∫ßu xa h∆°n v·ªÅ b√™n tr√°i
          Math.floor(pts.length * 0.5), // c·∫ßu gi·ªØa trung t√¢m
          Math.floor(pts.length * 0.85),
        ];
        for (const i of idx) {
          const br = makeBridgeAt(
            pts,
            Math.max(0, Math.min(pts.length - 2, i))
          );
          if (br) S.bridges.push(br);
        }
      }

      // --- C·∫¶U G·ªñ V√íM (deck cong + c·ªôt g·ªó + tay v·ªãn cong) ---
      function drawBridges() {
        if (!S.bridges?.length) return;

        // Tham s·ªë t·∫°o style ‚Äúwooden arch‚Äù
        const POST_SPACING = 28; // kho·∫£ng c√°ch c·ªôt tay v·ªãn
        const RAIL_OFFSET = 0; // tay v·ªãn l·ªách ra ngo√†i m√©p m·∫∑t c·∫ßu
        const RAIL_THICK = 8; // ƒë·ªô d√†y tay v·ªãn
        const SHADOW_OFF = { x: 3, y: 4 }; // b√≥ng ƒë·ªï
        const PLANK_STEP = 12; // kho·∫£ng c√°ch nan v√°n
        const EDGE_STROKE = 2;

        for (const br of S.bridges) {
          // Quy ƒë·ªïi v·ªÅ h·ªá local c·ªßa c·∫ßu
          const vx = br.b.x - br.a.x,
            vy = br.b.y - br.a.y;
          const L = Math.hypot(vx, vy);
          if (L < 2) continue;
          const ang = Math.atan2(vy, vx);
          const W = br.width || 34; // b·ªÅ r·ªông l·ªëi ƒëi
          const halfW = W / 2;

          // ƒê·ªô cong m·∫∑t c·∫ßu: parabol ng·ª≠a (0..L)
          const DECK_ARC = Math.max(5, Math.min(10, L * 0.06)); // cong v·ª´a m·∫Øt
          const arcY = (x) => {
            const t = (x / L) * 2 - 1; // [-1..1]
            return -DECK_ARC * (1 - t * t);
          };

          // Helper stroke tay v·ªãn cong (sign = -1: ph√≠a tr√™n, +1: ph√≠a d∆∞·ªõi)
          function strokeRail(sign, color, width, innerShade = false) {
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.beginPath();
            ctx.moveTo(0, arcY(0) + sign * (halfW + RAIL_OFFSET));
            for (let x = 0; x <= L; x += 6) {
              ctx.lineTo(x, arcY(x) + sign * (halfW + RAIL_OFFSET));
            }
            ctx.stroke();

            // vi·ªÅn t·ªëi nh·∫π ph√≠a trong ƒë·ªÉ tay v·ªãn ‚Äútr√≤n ·ªëng‚Äù
            if (innerShade) {
              ctx.strokeStyle = "rgba(0,0,0,0.25)";
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(
                0,
                arcY(0) + sign * (halfW + RAIL_OFFSET) - sign * 2
              );
              for (let x = 0; x <= L; x += 6) {
                ctx.lineTo(
                  x,
                  arcY(x) + sign * (halfW + RAIL_OFFSET) - sign * 2
                );
              }
              ctx.stroke();
            }
          }

          // B·∫Øt ƒë·∫ßu v·∫Ω theo h·ªá local
          ctx.save();
          ctx.translate(br.a.x, br.a.y);
          ctx.rotate(ang);

          // ---- B√ìNG C·∫¶U (theo m·∫∑t cong) ----
          ctx.save();
          ctx.translate(SHADOW_OFF.x, SHADOW_OFF.y);
          ctx.fillStyle = "rgba(0,0,0,0.22)";
          ctx.beginPath();
          ctx.moveTo(0, arcY(0) - halfW);
          for (let x = 0; x <= L; x += 6) ctx.lineTo(x, arcY(x) - halfW);
          ctx.lineTo(L, arcY(L) + halfW);
          for (let x = L; x >= 0; x -= 6) ctx.lineTo(x, arcY(x) + halfW);
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          // ---- M·∫∂T V√ÅN (deck) cong ----
          const g = ctx.createLinearGradient(0, -halfW, 0, halfW);
          g.addColorStop(0.0, "#8b6a4a");
          g.addColorStop(0.55, "#9a7a58");
          g.addColorStop(1.0, "#6f5236");
          ctx.fillStyle = g;

          ctx.beginPath();
          ctx.moveTo(0, arcY(0) - halfW);
          for (let x = 0; x <= L; x += 6) ctx.lineTo(x, arcY(x) - halfW); // m√©p tr√™n
          ctx.lineTo(L, arcY(L) + halfW);
          for (let x = L; x >= 0; x -= 6) ctx.lineTo(x, arcY(x) + halfW); // m√©p d∆∞·ªõi
          ctx.closePath();
          ctx.fill();

          // Vi·ªÅn m√©p deck (bevel m·ªèng)
          ctx.lineWidth = EDGE_STROKE;
          ctx.strokeStyle = "#5f4531";
          ctx.beginPath();
          ctx.moveTo(0, arcY(0) - halfW);
          for (let x = 0; x <= L; x += 4) ctx.lineTo(x, arcY(x) - halfW);
          ctx.lineTo(L, arcY(L) + halfW);
          for (let x = L; x >= 0; x -= 4) ctx.lineTo(x, arcY(x) + halfW);
          ctx.closePath();
          ctx.stroke();

          // ---- NAN V√ÅN CH√âO (v√¢n g·ªó) ‚Äî CLIP TRONG M·∫∂T C·∫¶U ----
          ctx.save();
          // t·∫°o l·∫°i path m·∫∑t deck ƒë·ªÉ clip
          ctx.beginPath();
          ctx.moveTo(0, arcY(0) - halfW);
          for (let xx = 0; xx <= L; xx += 6) ctx.lineTo(xx, arcY(xx) - halfW);
          ctx.lineTo(L, arcY(L) + halfW);
          for (let xx = L; xx >= 0; xx -= 6) ctx.lineTo(xx, arcY(xx) + halfW);
          ctx.closePath();
          ctx.clip();

          for (let x = -W; x <= L + W; x += PLANK_STEP) {
            // ƒë∆∞·ªùng t·ªëi
            ctx.globalAlpha = 0.15;
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, arcY(Math.max(0, Math.min(L, x))) - halfW + 2);
            ctx.lineTo(
              x + W,
              arcY(Math.max(0, Math.min(L, x + W))) + halfW - 2
            );
            ctx.stroke();

            // ƒë∆∞·ªùng s√°ng l·ªách 3px
            ctx.globalAlpha = 0.18;
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(
              x + 3,
              arcY(Math.max(0, Math.min(L, x + 3))) - halfW + 3
            );
            ctx.lineTo(
              x + W + 3,
              arcY(Math.max(0, Math.min(L, x + W + 3))) + halfW - 1
            );
            ctx.stroke();
          }
          ctx.globalAlpha = 1;
          ctx.restore();

          // // ---- C·ªòT G·ªñ ƒê·ª®NG (posts) hai b√™n m√©p deck ----
          // const postH = Math.max(12, halfW + 12);
          // const postW = 6;
          // ctx.fillStyle = "#5c402c";
          // ctx.strokeStyle = "#3f2c1f";

          // ---- TAY V·ªäN CONG (2 b√™n) ----
          strokeRail(-1, "#bfa68b", RAIL_THICK, true); // ph√≠a ‚Äútr√™n‚Äù
          strokeRail(+1, "#bfa68b", RAIL_THICK, true); // ph√≠a ‚Äúd∆∞·ªõi‚Äù

          // reset transform cho c·∫ßu k·∫ø ti·∫øp
          ctx.restore();
        }
      }

      // --- Geometry helpers ---
      function distPointToSegment(px, py, ax, ay, bx, by) {
        const abx = bx - ax,
          aby = by - ay;
        const apx = px - ax,
          apy = py - ay;
        const ab2 = abx * abx + aby * aby || 1;
        let t = (apx * abx + apy * aby) / ab2;
        t = Math.max(0, Math.min(1, t));
        const cx = ax + abx * t,
          cy = ay + aby * t;
        return Math.hypot(px - cx, py - cy);
      }

      // ƒêi·ªÉm (px,py) c√≥ n·∫±m TRONG d·∫£i s√¥ng cong?
      function isInRiver(px, py) {
        const rp = S.riverPath;
        if (!rp || !rp.points || rp.points.length < 2) return false;
        const halfW = (rp.width || 24) / 2;
        for (let i = 0; i < rp.points.length - 1; i++) {
          const a = rp.points[i],
            b = rp.points[i + 1];
          if (distPointToSegment(px, py, a.x, a.y, b.x, b.y) <= halfW)
            return true;
        }
        return false;
      }

      // C·∫ßu (bridge) ‚Äì danh s√°ch ƒëo·∫°n th·∫≥ng + b·ªÅ r·ªông cho ph√©p ƒëi qua
      // S.bridges = S.bridges || [];
      function isOnBridge(px, py) {
        for (const br of S.bridges) {
          const d = distPointToSegment(
            px,
            py,
            br.a.x,
            br.a.y,
            br.b.x,
            br.b.y
          );
          if (d <= br.width / 2) return true;
        }
        return false;
      }

      // --- Sample points along a tank's rectangular hitbox perimeter ---
      function sampleRectPerimeter(cx, cy, size) {
        const half = size / 2;
        const left = cx - half,
          right = cx + half;
        const top = cy - half,
          bottom = cy + half;

        // M·∫≠t ƒë·ªô m·∫´u v·ª´a ph·∫£i: m·ªói ~1/4 c·∫°nh + 4 g√≥c
        const step = Math.max(6, Math.floor(size / 4));
        const pts = [];

        // Tr√™n & d∆∞·ªõi (bao g·ªìm g√≥c)
        for (let x = left; x <= right; x += step) {
          pts.push([x, top], [x, bottom]);
        }
        // Tr√°i & ph·∫£i (b·ªè g√≥c v√¨ ƒë√£ c√≥, n√™n b·∫Øt ƒë·∫ßu t·ª´ top+step)
        for (let y = top + step; y < bottom; y += step) {
          pts.push([left, y], [right, y]);
        }
        // ƒë·∫£m b·∫£o 4 g√≥c c√≥ m·∫∑t (ph√≤ng khi step kh√¥ng tr√πng bi√™n ch√≠nh x√°c)
        pts.push([left, top], [right, top], [left, bottom], [right, bottom]);

        return pts;
      }

      // C√≥ ƒëi·ªÉm n√†o c·ªßa hitbox r∆°i v√†o s√¥ng KH√îNG n·∫±m tr√™n c·∫ßu?
      function rectTouchesRiver(cx, cy, size) {
        const pts = sampleRectPerimeter(cx, cy, size);
        for (const [px, py] of pts) {
          if (isInRiver(px, py) && !isOnBridge(px, py)) return true;
        }
        return false;
      }

      // ===== V·∫Ω d·∫£i s√¥ng cong theo S.riverPath =====
      function drawRiverLabel() {
        const rp = S.riverPath;
        if (!rp?.points || rp.points.length < 4) return;

        const text = "S√îNG TH·∫†CH H√ÉN";
        const pts = rp.points;

        // K√≠ch th∆∞·ªõc nh·ªè h∆°n, font bo tr√≤n
        const fontSize = Math.max(12, Math.floor((rp.width || TILE) * 0.35));
        ctx.font = `700 ${fontSize}px "Baloo 2","Nunito", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif`;
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(233,246,255,0.88)";
        ctx.strokeStyle = "rgba(0,0,0,0.40)";
        ctx.lineWidth = Math.max(1.5, fontSize * 0.1);

        // T√≠nh t·ªïng chi·ªÅu d√†i ƒëo·∫°n path (theo to√†n s√¥ng)
        let total = 0;
        const segLen = [];
        for (let i = 0; i < pts.length - 1; i++) {
          const L = Math.hypot(
            pts[i + 1].x - pts[i].x,
            pts[i + 1].y - pts[i].y
          );
          segLen.push(L);
          total += L;
        }

        // V·ªã tr√≠ trung t√¢m ch·ªØ theo t·ªâ l·ªá (0..1) ‚Äî c√≥ clamp ƒë·ªÉ tr√°nh s√°t m√©p
        const margin = Math.max(40, ctx.measureText(text).width * 0.6);
        const minPos = margin / total;
        const maxPos = 1 - minPos;
        const tCenter = Math.max(
          minPos,
          Math.min(maxPos, S.riverLabelPos ?? 0.5)
        );

        // H√†m l·∫•y ƒëi·ªÉm t·∫°i kho·∫£ng c√°ch d·ªçc path
        function pointAtDist(dist) {
          let acc = 0;
          for (let i = 0; i < segLen.length; i++) {
            const L = segLen[i];
            if (acc + L >= dist) {
              const t = (dist - acc) / L;
              const a = pts[i],
                b = pts[i + 1];
              return {
                x: a.x + (b.x - a.x) * t,
                y: a.y + (b.y - a.y) * t,
                ang: Math.atan2(b.y - a.y, b.x - a.x),
              };
            }
            acc += L;
          }
          const a = pts[pts.length - 2],
            b = pts[pts.length - 1];
          return { x: b.x, y: b.y, ang: Math.atan2(b.y - a.y, b.x - a.x) };
        }

        // V·∫Ω ch·ªØ u·ªën theo s√¥ng: ƒëi t·ª´ng k√Ω t·ª± theo path
        const textW = ctx.measureText(text).width;
        const startDist = tCenter * total - textW / 2;
        let d = startDist;
        for (const ch of text) {
          const w = ctx.measureText(ch).width;
          const mid = pointAtDist(d + w / 2);
          ctx.save();
          ctx.translate(mid.x, mid.y);
          ctx.rotate(mid.ang);
          ctx.strokeText(ch, 0, 0);
          ctx.fillText(ch, 0, 0);
          ctx.restore();
          d += w;
        }
      }

      function drawCurvedRiverRibbon() {
        if (
          !S.riverPath ||
          !S.riverPath.points ||
          S.riverPath.points.length < 2
        )
          return;
        const t = performance.now() / 1000;

        const pts = S.riverPath.points;
        const width = S.riverPath.width;

        // 1) Th√¢n n∆∞·ªõc: stroke m·ªôt ƒë∆∞·ªùng cong v·ªõi lineWidth l·ªõn
        ctx.save();
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Gradient d·ªçc canvas nh·∫π (xanh s√¢u -> xanh s√°ng)
        const g = ctx.createLinearGradient(0, 0, 0, H);
        g.addColorStop(0, "#18506a");
        g.addColorStop(1, "#2497c6");
        ctx.strokeStyle = g;
        ctx.lineWidth = width;

        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();

        // 2) S√≥ng t∆∞·ª£ng tr∆∞ng THEO ƒê∆Ø·ªúNG CONG:
        //    d√πng nhi·ªÅu n√©t dashed m·∫£nh ch·∫°y d·ªçc theo path, offset theo th·ªùi gian.
        const { amplitude, spacing, speed } = S.riverPath.wave;
        ctx.setLineDash([spacing, spacing]);
        ctx.lineDashOffset = -t * speed * 60; // tr√¥i t·ª´ tr√°i -> ph·∫£i

        // V·∫Ω 3 d·∫£i highlight song song v·ªõi th√¢n n∆∞·ªõc (d·ªãch l·ªách v√†o/ra)
        const waveWidths = [1.6, 1.2];
        const waveAlpha = [0.26, 0.18];
        const offsets = [-width * 0.16, width * 0.16]; // l·ªách sang 2 b√™n b·ªù + gi·ªØa

        for (let k = 0; k < offsets.length; k++) {
          ctx.beginPath();
          // ƒëi l·∫°i to√†n b·ªô path, nh∆∞ng d·ªãch nh·∫π theo ph√°p tuy·∫øn
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            // ph√°p tuy·∫øn x·∫•p x·ªâ t·ª´ ƒëo·∫°n (i-1 -> i+1)
            const a = pts[Math.max(0, i - 1)];
            const b = pts[Math.min(pts.length - 1, i + 1)];
            let nx = b.y - a.y,
              ny = -(b.x - a.x); // normal ~ (dy, -dx)
            const len = Math.hypot(nx, ny) || 1;
            nx /= len;
            ny /= len;

            // rung nh√® nh·∫π theo sin ƒë·ªÉ s√≥ng ‚Äúg·ª£n‚Äù
            const wiggle =
              Math.sin(i * 0.12 + t * 1.4 + k) * (amplitude * 0.7);
            const ox = nx * (offsets[k] + wiggle);
            const oy = ny * (offsets[k] + wiggle);
            if (i === 0) ctx.moveTo(p.x + ox, p.y + oy);
            else ctx.lineTo(p.x + ox, p.y + oy);
          }
          ctx.strokeStyle = `rgba(191,231,250,${waveAlpha[k]})`;
          ctx.lineWidth = waveWidths[k];
          ctx.stroke();
        }

        ctx.restore();
      }
      // ===== Sound toggle helpers =====
      function loadSoundPref() {
        try {
          const saved = localStorage.getItem("soundEnabled");
          if (saved !== null) AUDIO.enabled = saved === "1";
        } catch (e) { }
      }
      function saveSoundPref() {
        try {
          localStorage.setItem("soundEnabled", AUDIO.enabled ? "1" : "0");
        } catch (e) { }
      }
      function updateSoundUI() {
        if (!btnSound) return;
        btnSound.textContent = AUDIO.enabled
          ? "üîä Sound: ON"
          : "üîá Sound: OFF";
        btnSound.className = "pill" + (AUDIO.enabled ? "" : " off");
        updateVolumeUI && updateVolumeUI();
      }
      // ===== Smoke helpers =====
      // ===== Smoke helpers (player-only, realistic) =====
      // H·∫°t kh√≥i: l·ªõn d·∫ßn, bay ng∆∞·ª£c h∆∞·ªõng xe + n·ªïi l√™n (buoyancy).
      // M·ªói h·∫°t c√≥ 2‚Äì3 l·ªõp m√†u ƒë·ªÉ nh√¨n ‚Äúm·ªÅm‚Äù h∆°n.
      function spawnPlayerSmoke(tank) {
        // 2 ·ªëng x·∫£ ·ªü cu·ªëi th√¢n, l·ªách 2 b√™n
        const back = tank.size * 0.38; // l√πi v·ªÅ ph√≠a sau th√°p/xe
        const offset = tank.size * 0.18; // l·ªách tr√°i/ph·∫£i
        const spots = [];

        if (tank.dir === "up") {
          spots.push({ x: tank.x - offset, y: tank.y + back });
          spots.push({ x: tank.x + offset, y: tank.y + back });
        } else if (tank.dir === "down") {
          spots.push({ x: tank.x - offset, y: tank.y - back });
          spots.push({ x: tank.x + offset, y: tank.y - back });
        } else if (tank.dir === "left") {
          spots.push({ x: tank.x + back, y: tank.y - offset });
          spots.push({ x: tank.x + back, y: tank.y + offset });
        } else {
          // right
          spots.push({ x: tank.x - back, y: tank.y - offset });
          spots.push({ x: tank.x - back, y: tank.y + offset });
        }

        // h∆∞·ªõng kh√≥i b·∫Øn ra theo chi·ªÅu ng∆∞·ª£c c·ªßa xe + nhi·ªÖu nh·∫π
        for (const sp of spots) {
          // Gi·∫£m th·ªùi gian t·ªìn t·∫°i: ~0.30‚Äì0.50s (tr∆∞·ªõc ~0.55‚Äì0.8s)
          const life = 0.3 + Math.random() * 0.2;
          const baseSpeed = 26 + Math.random() * 10;
          let vx = 0,
            vy = 0;
          if (tank.dir === "up") {
            vx = (Math.random() - 0.5) * 10;
            vy = baseSpeed;
          }
          if (tank.dir === "down") {
            vx = (Math.random() - 0.5) * 10;
            vy = -baseSpeed;
          }
          if (tank.dir === "left") {
            vx = baseSpeed;
            vy = (Math.random() - 0.5) * 10;
          }
          if (tank.dir === "right") {
            vx = -baseSpeed;
            vy = (Math.random() - 0.5) * 10;
          }

          S.smokes.push({
            x: sp.x,
            y: sp.y,
            vx,
            vy,
            ax: (Math.random() - 0.5) * 3.2, // nhi·ªÖu ngang nh·∫π h∆°n ch√∫t
            ay: -18, // n·ªïi l√™n
            life,
            max: life,
            // Thu h·∫πp b√°n k√≠nh & t·ªëc ƒë·ªô n·ªü
            r: 1.8 + Math.random() * 1.2, // tr∆∞·ªõc: 3‚Äì5
            grow: 8 + Math.random() * 6, // tr∆∞·ªõc: 16‚Äì26
            layers: 3,
            // M√†u x√°m nh·∫π h∆°n (kh√¥ng c√≤n ƒëen s·∫´m)
            c0: "rgba(70,70,70,",
            c1: "rgba(160,165,170,",
            c2: "rgba(220,225,230,",
          });
        }
      }

      function updateSmokes(dt) {
        for (let i = S.smokes.length - 1; i >= 0; i--) {
          const s = S.smokes[i];
          s.life -= dt;
          // v·∫≠n t·ªëc + n·ªïi l√™n
          s.vx += s.ax * dt;
          s.vy += s.ay * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          s.r += s.grow * dt; // l·ªõn d·∫ßn
          // gi·∫£m nhi·ªÖu theo th·ªùi gian
          s.ax *= 1 - 1.8 * dt;
          if (s.life <= 0) S.smokes.splice(i, 1);
        }
      }
      // ===== Th·∫°ch H√£n River Tile (animated) =====
      function drawThachHanRiverTile(gx, gy, x, y, size) {
        const t = performance.now() / 1000;

        // L·ªõp n∆∞·ªõc n·ªÅn: xanh s√¢u -> xanh s√°ng (c·∫£m gi√°c d√≤ng ch·∫£y)
        const g = ctx.createLinearGradient(x, y, x, y + size);
        g.addColorStop(0, "#144b63");
        g.addColorStop(1, "#2aa1d3");
        ctx.fillStyle = g;
        ctx.fillRect(x, y, size, size);

        // C√°c g·ª£n s√≥ng s√°ng (foam) l∆∞·ª£n nh·∫π theo gi√≥, tr√¥i theo d√≤ng
        // S√≥ng ch·∫°y ngang
        const basePhase = t * 1.1 + gy * 0.35 + gx * 0.15;
        for (let i = 0; i < 3; i++) {
          const colX = x + size * (0.22 + i * 0.5);
          const amp = 2.0 + i * 0.6;
          const k = 0.085;

          ctx.beginPath();
          for (let j = 0; j <= 6; j++) {
            const py = y + (size / 6) * j;
            const wave = Math.sin(basePhase + py * k + i * 0.8) * amp;
            const px = colX + wave;
            if (j === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.strokeStyle = "rgba(191,231,250,0.60)";
          ctx.stroke();
        }

        // V·ªát b·ªçt m·∫£nh tr√¥i theo d√≤ng (theo tr·ª•c d·ªçc), t·∫°o c·∫£m gi√°c c√≥ d√≤ng ch·∫£y
        const drift = (t * 28 + gx * 9) % size;
        ctx.globalAlpha = 0.28;
        ctx.fillStyle = "rgba(255,255,255,0.18)";
        ctx.fillRect(x, y + drift, size, 2);
        ctx.globalAlpha = 1;

        // Vi·ªÅn t·ªëi nh·∫π ƒë·ªÉ ‚Äúgi·ªØ n∆∞·ªõc‚Äù trong l√≤ng s√¥ng
        ctx.strokeStyle = "rgba(0,0,0,0.15)";
        ctx.strokeRect(x + 0.5, y + 0.5, size - 1, size - 1);
      }
      function dirToVec(dir) {
        switch (dir) {
          case 0:
          case "up":
            return { x: 0, y: -1 };
          case 1:
          case "right":
            return { x: 1, y: 0 };
          case 2:
          case "down":
            return { x: 0, y: 1 };
          case 3:
          case "left":
            return { x: -1, y: 0 };
          default:
            return { x: 0, y: -1 };
        }
      }

      // ===== Volume helpers =====
      function getSavedVolume() {
        try {
          const s = localStorage.getItem("soundVolume");
          if (s !== null) {
            const v = parseFloat(s);
            if (!isNaN(v)) return Math.max(0, Math.min(1, v));
          }
        } catch (e) { }
        return null; // ch∆∞a c√≥ -> d√πng m·∫∑c ƒë·ªãnh
      }
      function loadVolumePref() {
        // ƒë·∫∑t slider theo pref (n·∫øu c√≥)
        const v = getSavedVolume();
        if (volSlider) {
          const use = v != null ? v : 0.25;
          volSlider.value = Math.round(use * 100);
        }
        return v;
      }
      function saveVolumePref(v) {
        // v: 0..1
        try {
          localStorage.setItem("soundVolume", String(v));
        } catch (e) { }
      }
      function updateVolumeUI() {
        // t·∫Øt/kh√≥a slider n·∫øu Sound OFF
        if (!volWrap || !volSlider) return;
        if (AUDIO.enabled) {
          volWrap.classList.remove("off");
          volSlider.disabled = false;
        } else {
          volWrap.classList.add("off");
          volSlider.disabled = true;
        }
      }

      // ===== AUDIO (Web Audio API) =====
      let AUDIO = {
        ctx: null,
        master: null,
        enabled: true,
      };

      function ensureAudio() {
        if (AUDIO.ctx) return;
        AUDIO.ctx = new (window.AudioContext || window.webkitAudioContext)();
        AUDIO.master = AUDIO.ctx.createGain();
        const savedVol = getSavedVolume();
        AUDIO.master.gain.value = savedVol != null ? savedVol : 0.25; // set theo pref
        AUDIO.master.connect(AUDIO.ctx.destination);
        // ƒë·ªìng b·ªô UI (n·∫øu slider ƒë√£ render)
        if (volSlider)
          volSlider.value = Math.round(AUDIO.master.gain.value * 100);
        updateVolumeUI && updateVolumeUI();
      }

      // node ti·ªán l·ª£i
      function gain(v = 1) {
        const g = AUDIO.ctx.createGain();
        g.gain.value = v;
        g.connect(AUDIO.master);
        return g;
      }

      // noise burst
      function noise(duration = 0.2, vol = 1, lpFreq = 2000) {
        const sr = AUDIO.ctx.sampleRate;
        const buffer = AUDIO.ctx.createBuffer(1, sr * duration, sr);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++)
          data[i] = (Math.random() * 2 - 1) * 0.9;
        const src = AUDIO.ctx.createBufferSource();
        src.buffer = buffer;

        // l·ªçc lowpass cho ƒë·ª° ch√≥i
        const lp = AUDIO.ctx.createBiquadFilter();
        lp.type = "lowpass";
        lp.frequency.value = lpFreq;

        const g = gain(vol);
        src.connect(lp);
        lp.connect(g);

        src.start();
        return g; // tr·∫£ gain ƒë·ªÉ c√≥ th·ªÉ envelope
      }

      function tone(type = "square", freq = 440, duration = 0.12, vol = 0.8) {
        const o = AUDIO.ctx.createOscillator();
        const g = gain(vol);
        o.type = type;
        o.frequency.setValueAtTime(freq, AUDIO.ctx.currentTime);
        o.connect(g);
        o.start();
        o.stop(AUDIO.ctx.currentTime + duration);
        return g;
      }

      // ti·ªán: v·∫Ω envelope nhanh
      function env(g, a = 0.005, d = 0.15) {
        const t = AUDIO.ctx.currentTime;
        g.gain.cancelScheduledValues(t);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.linearRampToValueAtTime(g.gain.value || 1, t + a);
        g.gain.exponentialRampToValueAtTime(0.0001, t + a + d);
      }

      // SFX theo t√™n
      function playSfx(name) {
        if (!AUDIO.enabled || !AUDIO.ctx) return;

        switch (name) {
          case "shoot": {
            // beep ng·∫Øn c√≥ pitch l√™n nh·∫π
            const g = tone("square", 800, 0.08, 0.6);
            env(g, 0.002, 0.08);
            break;
          }
          case "shoot_enemy": {
            const g = tone("square", 700, 0.06, 0.35);
            env(g, 0.002, 0.06);
            break;
          }
          case "explode_wall": {
            const g = noise(0.18, 0.6, 1800);
            env(g, 0.005, 0.16);
            break;
          }
          case "explode_tank": {
            // "ƒêO√ÄNG ‚Äî ƒêO√ÄNG": 2 c√∫ crack nhanh + th√¢n n·ªï tr·∫ßm nh·∫π
            const t0 = AUDIO.ctx.currentTime;

            // T·∫°o burst noise c√≥ th·ªÉ h·∫πn gi·ªù start (kh√¥ng d√πng noise() v√¨ noise() start ngay)
            const noiseBurst = (at, dur = 0.10, vol = 0.9, hpFreq = 1800) => {
              const sr = AUDIO.ctx.sampleRate;
              const buf = AUDIO.ctx.createBuffer(1, Math.max(1, (sr * dur) | 0), sr);
              const data = buf.getChannelData(0);
              for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;

              const src = AUDIO.ctx.createBufferSource();
              src.buffer = buf;
              const hp = AUDIO.ctx.createBiquadFilter();
              hp.type = "highpass";
              hp.frequency.value = hpFreq;

              const g = gain(vol);
              src.connect(hp); hp.connect(g);

              g.gain.setValueAtTime(0.0001, at);
              g.gain.linearRampToValueAtTime(vol, at + 0.008);
              g.gain.exponentialRampToValueAtTime(0.0001, at + dur);

              src.start(at);
              src.stop(at + dur);
            };

            // Th√™m ‚Äúclick‚Äù cao ƒë·ªô ng·∫Øn ƒë·ªÉ nghe r√µ ch·ªØ "ƒëo√†ng"
            const pitchBlip = (at, f0 = 900, f1 = 350, vol = 0.42) => {
              const o = AUDIO.ctx.createOscillator();
              o.type = "square";
              const g = gain(vol);
              o.connect(g);

              o.frequency.setValueAtTime(f0, at);
              o.frequency.exponentialRampToValueAtTime(f1, at + 0.08);

              g.gain.setValueAtTime(0.0001, at);
              g.gain.linearRampToValueAtTime(0.6, at + 0.01);
              g.gain.exponentialRampToValueAtTime(0.0001, at + 0.11);

              o.start(at);
              o.stop(at + 0.12);
            };

            // ƒêO√ÄNG 1
            noiseBurst(t0 + 0.00, 0.10, 0.95, 1800);
            pitchBlip(t0 + 0.00, 900, 350, 0.42);

            // ƒêO√ÄNG 2 (tr·ªÖ ~120ms)
            noiseBurst(t0 + 0.12, 0.10, 0.9, 1800);
            pitchBlip(t0 + 0.12, 800, 300, 0.38);

            // Th√¢n n·ªï tr·∫ßm (kh·ªëi th√©p r∆°i)
            const body = tone("sine", 95, 0.26, 0.45);
            env(body, 0.006, 0.22);

            break;
          }

          case "base_destroyed": {
            // ti·∫øng r∆°i pitch + noise
            const o = AUDIO.ctx.createOscillator();
            const g = gain(0.8);
            o.type = "sawtooth";
            const t = AUDIO.ctx.currentTime;
            o.frequency.setValueAtTime(600, t);
            o.frequency.exponentialRampToValueAtTime(70, t + 0.6);
            o.connect(g);
            o.start(t);
            o.stop(t + 0.6);
            env(g, 0.005, 0.6);
            const n = noise(0.35, 0.7, 1800);
            env(n, 0.01, 0.3);
            break;
          }
          case "win": {
            // arpeggio ng·∫Øn
            const base = 523.25; // C5
            [1, 1.25, 1.5, 2].forEach((m, i) => {
              const when = AUDIO.ctx.currentTime + i * 0.09;
              const o = AUDIO.ctx.createOscillator();
              o.type = "triangle";
              o.frequency.setValueAtTime(base * m, when);
              const g = gain(0.6);
              o.connect(g);
              o.start(when);
              o.stop(when + 0.16);
              // envelope th·ªß c√¥ng
              g.gain.setValueAtTime(0.0001, when);
              g.gain.linearRampToValueAtTime(0.7, when + 0.02);
              g.gain.exponentialRampToValueAtTime(0.0001, when + 0.16);
            });
            break;
          }
          case "lose": {
            const o = AUDIO.ctx.createOscillator();
            const g = gain(0.7);
            o.type = "square";
            const t = AUDIO.ctx.currentTime;
            o.frequency.setValueAtTime(220, t);
            o.frequency.exponentialRampToValueAtTime(90, t + 0.5);
            o.connect(g);
            o.start(t);
            o.stop(t + 0.5);
            env(g, 0.005, 0.5);
            break;
          }
          // ===== NEW: ti·∫øng m√°y bay bay (loop) =====
          case "plane_start": {
            // ‚Äú√π √π √π‚Äù ‚Äì hum t·∫ßn s·ªë th·∫•p + tremolo nh·∫π
            ensureAudio();
            // node gi·ªØ tham chi·∫øu ƒë·ªÉ t·∫Øt sau n√†y
            if (AUDIO._plane) { try { playSfx("plane_stop"); } catch (e) { } }

            const t0 = AUDIO.ctx.currentTime;

            // hum ch√≠nh ~90Hz
            const hum = AUDIO.ctx.createOscillator();
            hum.type = "sine";
            hum.frequency.setValueAtTime(90, t0);

            // th√™m 1 h√†i cao h∆°n ~180Hz r·∫•t nh·ªè ƒë·ªÉ d√†y ti·∫øng
            const hum2 = AUDIO.ctx.createOscillator();
            hum2.type = "sine";
            hum2.frequency.setValueAtTime(180, t0);

            // gain ch√≠nh cho hum
            const gHum = gain(0.35);

            // Tremolo (√π √π √π): LFO 2.2Hz ƒëi·ªÅu khi·ªÉn bi√™n ƒë·ªô
            const lfo = AUDIO.ctx.createOscillator();
            lfo.type = "sine";
            lfo.frequency.setValueAtTime(2.2, t0);
            const lfoGain = AUDIO.ctx.createGain();
            lfoGain.gain.value = 0.35; // ƒë·ªô s√¢u dao ƒë·ªông
            lfo.connect(lfoGain);
            lfoGain.connect(gHum.gain);

            hum.connect(gHum);
            hum2.connect(gHum);

            hum.start(t0);
            hum2.start(t0 + 0.02);
            lfo.start(t0 + 0.01);

            AUDIO._plane = { hum, hum2, lfo, g: gHum };
            break;
          }
          case "plane_stop": {
            const P = AUDIO._plane;
            if (P) {
              const t1 = AUDIO.ctx.currentTime;
              // fade-out ng·∫Øn cho √™m tai
              try {
                P.g.gain.cancelScheduledValues(t1);
                P.g.gain.setValueAtTime(P.g.gain.value, t1);
                P.g.gain.exponentialRampToValueAtTime(0.0001, t1 + 0.20);
              } catch (e) { }
              try { P.hum.stop(t1 + 0.22); } catch (e) { }
              try { P.hum2.stop(t1 + 0.22); } catch (e) { }
              try { P.lfo.stop(t1 + 0.22); } catch (e) { }
              AUDIO._plane = null;
            }
            break;
          }


          // ===== NEW: bom n·ªï =====
          case "bomb_blast": {
            ensureAudio();
            const t = AUDIO.ctx.currentTime;

            // Nh√°t 1 ‚Äì ‚Äúu·ª≥nh‚Äù: noise + sub
            const n1 = noise(0.32, 0.9, 1400); // noise low-pass
            env(n1, 0.004, 0.28);
            const sub1 = tone("sine", 56, 0.34, 0.85); // sub ~56Hz
            env(sub1, 0.006, 0.30);

            // Nh√°t 2 ‚Äì ‚Äúu·ª≥nh‚Äù l·∫∑p l·∫°i r·∫•t nhanh (double-hit)
            const t2 = t + 0.10;
            const n2 = noise(0.26, 0.7, 1200);
            n2.gain.setValueAtTime(0.0001, t2);
            n2.gain.linearRampToValueAtTime(0.6, t2 + 0.02);
            n2.gain.exponentialRampToValueAtTime(0.0001, t2 + 0.22);
            const o2 = AUDIO.ctx.createOscillator();
            o2.type = "sine";
            const g2 = gain(0.6);
            o2.connect(g2);
            o2.frequency.setValueAtTime(65, t2);
            o2.frequency.exponentialRampToValueAtTime(50, t2 + 0.22);
            o2.start(t2);
            o2.stop(t2 + 0.24);
            break;
          }

        }
      }

      const DIRS = ["up", "down", "left", "right"];
      const rand = (n) => Math.floor(Math.random() * n);
      const choice = (arr) => arr[rand(arr.length)];
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

      // ===== DOM =====
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const uiLives = document.getElementById("uiLives");
      const uiHP = document.getElementById("uiHP");
      const uiPower = document.getElementById("uiPower");
      const uiEnemies = document.getElementById("uiEnemies");
      const uiScore = document.getElementById("uiScore");
      const uiTime = document.getElementById("uiTime");
      const uiBaseState = document.getElementById("uiBaseState");
      const overlay = document.getElementById("overlay");
      const btnStart = document.getElementById("btnStart");
      const btnRestart = document.getElementById("btnRestart");
      const btnSound = document.getElementById("uiSound");
      const volWrap = document.getElementById("uiVol");
      const volSlider = document.getElementById("uiVolSlider");

      // ===== Game State =====
      const S = {
        scorches: [], // v·∫øt ch√°y ƒëen (t√†n d∆∞) tr√™n n·ªÅn

        map: [], // grid of tiles
        explosions: [], // danh s√°ch hi·ªáu ·ª©ng n·ªï
        particles: [], // h·∫°t/tia l·ª≠a/v√≤ng xung k√≠ch
        smokes: [],
        hits: [], // (kh√¥ng b·∫Øt bu·ªôc, ƒë·ªÉ m·ªü r·ªông sau)

        bushSet: new Set(),
        base: { gx: 7, gy: 13, alive: true },
        baseRings: [],
        tanks: [], // player + enemies
        bullets: [],
        planes: [], // m√°y bay ƒëang bay
        bombs: [], // bom ƒëang r∆°i
        planeSpawned: false, // ƒë√£ spawn m√°y bay hay ch∆∞a (ch·ªâ 1 chi·∫øc/l∆∞·ª£t ch∆°i)
        planeCuePlayed: false,
        bridges: [],
        riverLabelPos: 0.32,
        wind: {
          // tr·∫°ng th√°i gi√≥ to√†n c·ª•c
          phase: 0, // pha ch·∫°y
          value: 0, // gi√° tr·ªã gi√≥ hi·ªán t·∫°i (px d·ªãch ngang)
          speed: 1.5, // t·ªëc ƒë·ªô gi√≥ (ƒëi·ªÅu ch·ªânh nhanh/ch·∫≠m)
          base: 5.0, // bi√™n ƒë·ªô gi√≥ c∆° b·∫£n (px)
          gusting: false, // c√≥ ƒëang c√≥ ‚Äúc∆°n gi√≥ m·∫°nh‚Äù kh√¥ng
          gustUntil: 0, // th·ªùi ƒëi·ªÉm k·∫øt th√∫c gust
        },
        keys: {
          up: false,
          down: false,
          left: false,
          right: false,
          shoot: false,
        },
        running: false,
        spawn: {
          active: 0,
          basicLeft: TOTAL_BASIC,
          armoredLeft: TOTAL_ARMORED,
          totalSpawned: 0,
          cooldown: 1200,
          next: 0,
          preferred: null,
          points: [
            { gx: 1, gy: 1 },
            { gx: 7, gy: 1 },
            { gx: 13, gy: 1 },
          ],
        },
        items: [], // {kind:'star'|'shovel', x,y, expiresAt, active}
        itemPlan: { stars: [], shovels: [] },
        playerId: "",
        lastTime: 0,
        elapsed: 0,
        shovelUntil: 0,
        // UI mirrored
        lives: 3,
        playerHP: 3,
        playerPower: 1,
        enemiesRemaining: TOTAL_BASIC + TOTAL_ARMORED,
        score: 0,
        timeLeft: PLAY_SECONDS,
        status: "menu", // 'menu'|'playing'|'won'|'lost'
      };

      function tile(type, hp) {
        return { type, hp };
      }
      function emptyMap() {
        const m = [];
        for (let y = 0; y < GRID; y++) {
          const r = [];
          for (let x = 0; x < GRID; x++) {
            r.push(tile("empty"));
          }
          m.push(r);
        }
        return m;
      }
      function within(x, y) {
        return x >= 0 && y >= 0 && x < GRID && y < GRID;
      }
      function toPx(gx, gy) {
        return { x: gx * TILE + TILE / 2, y: gy * TILE + TILE / 2 };
      }
      function toGrid(px, py) {
        return { gx: Math.floor(px / TILE), gy: Math.floor(py / TILE) };
      }

      // ===== Map Setup =====
      function setupLevel() {
        S.map = emptyMap();
        S.bushSet = new Set();
        // Rivers
        // River (curved, horizontal)
        carveCurvedRiver({
          baseY: 7,
          amp: 1.3, // u·ªën d·ªãu
          band: 1.2, // collision h·∫πp (~2.4 tiles t·ªïng)
          freq: 0.55,
          phase: 0.0,
          visualWidth: TILE * 1.25, // d·∫£i v·∫Ω m·∫£nh h∆°n tile-band
        });
        S.bridges = [];
        buildRiverBridges();
        // Steel & Brick layout (reworked as bunkers; keeps base walls; avoids river/bridge)
        // Helpers (scoped inside setupLevel)
        function setTileSafe(gx, gy, type) {
          if (!within(gx, gy)) return;
          const tt = S.map[gy][gx];
          if (!tt) return;
          if (tt.type === "river" || tt.type === "bridge") return;
          if (tt.type === "base") return;
          S.map[gy][gx] = tile(type, type === "steel" ? 3 : 1);
        }
        function bunker3x3(cx, cy) {
          const P = [
            ["steel", "brick", "steel"],
            ["brick", "empty", "brick"],
            ["steel", "brick", "steel"],
          ];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const t = P[dy + 1][dx + 1];
              if (t !== "empty") setTileSafe(cx + dx, cy + dy, t);
            }
          }
        }
        // === Fortifications: fewer bunkers, smarter gaps; bushes increased ===
        // Helpers (scoped inside setupLevel)
        function setTileSafe(gx, gy, type) {
          if (!within(gx, gy)) return;
          const t = S.map[gy][gx];
          if (!t) return;
          // Kh√¥ng ƒë·∫∑t l√™n s√¥ng/c·∫ßu
          if (t.type === "river" || t.type === "bridge") return;
          S.map[gy][gx] = tile(
            type,
            type === "steel" ? 3 : type === "brick" ? 1 : undefined
          );
        }
        function bunker3x3(cx, cy) {
          // th√©p ·ªü g√≥c, g·∫°ch ·ªü c·∫°nh, tr·ªëng gi·ªØa
          const P = [
            ["steel", "brick", "steel"],
            ["brick", "empty", "brick"],
            ["steel", "brick", "steel"],
          ];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const tp = P[dy + 1][dx + 1];
              if (tp === "empty") continue;
              setTileSafe(cx + dx, cy + dy, tp);
            }
          }
        }

        // --- Place fewer bunkers (tho√°ng h∆°n ƒë·ªÉ d·ªÖ di chuy·ªÉn) ---
        // Tuy·ªát ƒë·ªëi kh√¥ng ƒë√® l√™n s√¥ng/c·∫ßu v√¨ setTileSafe ƒë√£ ch·∫∑n.
        bunker3x3(3, 2); // top-left
        bunker3x3(11, 2); // top-right
        for (let dx = 0; dx < 2; dx++) {
          for (let dy = 0; dy < 2; dy++) {
            setTileSafe(2 + dx, 12 + dy, "brick"); // tr√°i
            setTileSafe(11 + dx, 12 + dy, "brick"); // ph·∫£i
          }
        }

        // Th√™m t∆∞·ªùng th√©p ch√≠nh gi·ªØa b·∫£n ƒë·ªì, ngay tr√™n player
        for (let dx = 0; dx < 3; dx++) {
          for (let dy = 0; dy < 1; dy++) {
            setTileSafe(6 + dx, 9 + dy, "steel");
          }
        }

        for (let dx = 0; dx < 1; dx++) {
          for (let dy = 0; dy < 1; dy++) {
            setTileSafe(7 + dx, 8 + dy, "steel");
          }
        }

        // === Bush overlays (5 b·ª•i m·ªói b·ªù; kh√¥ng s√°t t∆∞·ªùng; auto fallback) ===
        function canPlaceBush(gx, gy) {
          if (!within(gx, gy)) return false;

          // 1) √î ph·∫£i tr·ªëng (kh√¥ng ƒë√® l√¥ c·ªët/base)
          const t = S.map[gy][gx];
          if (!t || t.type !== "empty") return false;

          // 2) Kh√¥ng tr√™n s√¥ng/c·∫ßu
          const p = toPx(gx, gy);
          if (isInRiver(p.x, p.y)) return false;
          if (isOnBridge(p.x, p.y)) return false;

          // 3) Kh√¥ng ƒë·ª©ng s√°t t∆∞·ªùng (tr√°nh brick/steel trong b√°n k√≠nh 1 √¥)
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              if (dx === 0 && dy === 0) continue;
              const nx = gx + dx,
                ny = gy + dy;
              if (!within(nx, ny)) continue;
              const nt = S.map[ny][nx];
              if (!nt) continue;
              if (nt.type === "brick" || nt.type === "steel") return false;
            }
          }
          return true;
        }

        // th·ª≠ ƒë·∫∑t t·∫°i (gx,gy); n·∫øu kh√¥ng ƒë∆∞·ª£c th√¨ th·ª≠ c√°c offset l√¢n c·∫≠n h·ª£p l·ªá
        function placeBushWithFallback(gx, gy) {
          const OFF = [
            [0, 0],
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
            [2, 0],
            [-2, 0],
            [0, 2],
            [0, -2],
          ];
          for (const [dx, dy] of OFF) {
            const x = gx + dx,
              y = gy + dy;
            if (canPlaceBush(x, y)) {
              S.bushSet.add(`${x},${y}`);
              return true;
            }
          }
          return false;
        }

        // 5 v·ªã tr√≠ ∆ØU TI√äN cho m·ªói b·ªù (y=6: b·ªù TR√äN, y=8: b·ªù D∆Ø·ªöI)
        // L∆∞u √Ω: n·∫øu m·ªôt to·∫° ƒë·ªô b·ªã ch·∫∑n b·ªüi rule, placeBushWithFallback s·∫Ω t·ª± d·ªãch 1‚Äì2 √¥ l√¢n c·∫≠n.
        const TOP_BANK = [
          [5, 1],
          [8, 3],
          [2, 5],
          [11, 5],
          [14, 6],
        ]; // 5 b·ª•i b·ªù TR√äN
        const BOTTOM_BANK = [
          [3, 11],
          [10, 8],
          [5, 8],
          [11, 10],
          [13, 13],
        ]; // 5 b·ª•i b·ªù D∆Ø·ªöI

        TOP_BANK.forEach(([bx, by]) => placeBushWithFallback(bx, by));
        BOTTOM_BANK.forEach(([bx, by]) => placeBushWithFallback(bx, by));

        // Base
        S.base = { gx: 7, gy: 13, alive: true };
        S.map[S.base.gy][S.base.gx] = tile("base");
        S.baseRings = buildBaseRings(S.base.gx, S.base.gy);
        setBaseWalls("brick");
      }
      function buildBaseRings(cx, cy) {
        const coords = [];
        const add = (gx, gy) => {
          if (within(gx, gy) && !(gx === cx && gy === cy))
            coords.push({ gx, gy });
        };
        for (let y = cy - 1; y <= cy + 1; y++) {
          for (let x = cx - 1; x <= cx + 1; x++) {
            if (x === cx && y === cy) continue;
            add(x, y);
          }
        }
        for (let y = cy - 2; y <= cy + 2; y++) {
          for (let x = cx - 2; x <= cx + 2; x++) {
            const d = Math.max(Math.abs(x - cx), Math.abs(y - cy));
            if (d === 2) add(x, y);
          }
        }
        return coords;
      }
      function setBaseWalls(mode) {
        for (const { gx, gy } of S.baseRings) {
          if (!within(gx, gy)) continue;
          S.map[gy][gx] =
            mode === "steel" ? tile("steel", 3) : tile("brick", 1);
        }
        uiBaseState.textContent =
          "Base: " + (mode === "steel" ? "STEEL" : "BRICK");
        uiBaseState.className = "pill" + (mode === "steel" ? " steel" : "");
      }

      // ===== Airplane & Bombs =====
      function spawnPlane() {
        const margin = 40;

        // ƒê∆Ø·ªúNG CH√âO CHU·∫®N c·ªßa map: (0, H)  ‚Üí  (W, 0)
        const baseDx = W; // W - 0
        const baseDy = -H; // 0 - H
        const baseLen = Math.hypot(baseDx, baseDy) || 1;
        const dirx = baseDx / baseLen;
        const diry = baseDy / baseLen;

        // K√âO D√ÄI ƒëo·∫°n th·∫≥ng theo ƒë√∫ng h∆∞·ªõng ch√©o ƒë·ªÉ ra ngo√†i m√†n h√¨nh
        const start = { x: 0 - dirx * margin, y: H - diry * margin }; // bottom-left l√πi ra ngo√†i
        const end = { x: W + dirx * margin, y: 0 + diry * margin }; // top-right ti·∫øn ra ngo√†i

        // L∆∞u vector/h√†nh tr√¨nh
        const dx = end.x - start.x,
          dy = end.y - start.y;
        const len = Math.hypot(dx, dy) || 1;

        S.planes.push({
          x: start.x,
          y: start.y,
          sx: start.x,
          sy: start.y,
          ex: end.x,
          ey: end.y,
          dirx,
          diry,
          speed: PLANE_CFG.speed,
          traveled: 0,
          length: len,
          dropAtT: [0.05, 0.25, 0.45, 0.65, 0.85],
          dropIndex: 0,
          alive: true,
        });
        S.planeSpawned = true;
        // try { playSfx("plane_start"); } catch (e) { }
      }

      function findBombImpact(x, y0) {
        const startGy = clamp(Math.floor(y0 / TILE), 0, GRID - 1);
        const maxFallPx = TILE * 5; // r∆°i t·ªëi ƒëa ~5 √¥ cho "h·ª£p l√Ω"
        const maxGy = Math.min(GRID - 1, Math.floor((y0 + maxFallPx) / TILE));

        let hitTile = null;
        let gyHit = null;

        for (let gy = startGy; gy <= maxGy; gy++) {
          const gx = clamp(Math.floor(x / TILE), 0, GRID - 1);
          const t = S.map[gy][gx];
          if (!t) continue;

          // G·∫∑p t∆∞·ªùng/base -> n·ªï t·∫°i ƒë√≥
          if (t.type === "brick" || t.type === "steel" || t.type === "base") {
            hitTile = { gx, gy };
            gyHit = gy;
            break;
          }

          // G·∫∑p s√¥ng (kh√¥ng c√≥ c·∫ßu) -> cho n·ªï ·ªü m√©p √¥ s√¥ng
          const pos = toPx(gx, gy);
          if (isInRiver(pos.x, pos.y) && !isOnBridge(pos.x, pos.y)) {
            gyHit = gy;
            break;
          }
        }

        // Kh√¥ng g·∫∑p ch∆∞·ªõng ng·∫°i trong t·∫ßm r∆°i -> n·ªï ·ªü cu·ªëi t·∫ßm
        if (gyHit == null) gyHit = maxGy;

        const targetY = gyHit * TILE + TILE / 2;
        return { hitTile, targetY };
      }


      function dropBomb(x, y) {
        const info = findBombImpact(x, y);
        S.bombs.push({
          x,
          y,
          vy: PLANE_CFG.bombFall,
          targetY: info.targetY,
          hitTile: info.hitTile, // c√≥ th·ªÉ null
          active: true,
        });
      }

      function updatePlanes(dt, now) {
        for (let i = S.planes.length - 1; i >= 0; i--) {
          const p = S.planes[i];
          if (!p.alive) {
            S.planes.splice(i, 1);
            continue;
          }

          // di chuy·ªÉn
          const step = p.speed * dt;
          p.traveled += step;
          p.x += p.dirx * step;
          p.y += p.diry * step;

          // th·∫£ bom ·ªü c√°c m·ªëc t
          const tNow = p.traveled / p.length;
          while (
            p.dropIndex < p.dropAtT.length &&
            tNow >= p.dropAtT[p.dropIndex]
          ) {
            // Ch·ªâ th·∫£ khi hi·ªán kh√¥ng c√≥ bom ƒëang ho·∫°t ƒë·ªông
            if (!S.bombs.some(b => b.active)) {
              const ahead = 28;                         // th·∫£ h∆°i tr∆∞·ªõc m≈©i
              const lateral = (Math.random() * 32) - 16; // l·ªách ngang nh·∫π
              const nx = -p.diry, ny = p.dirx;          // ph√°p tuy·∫øn
              const dropX = clamp(p.x + p.dirx * ahead + nx * lateral, 8, W - 8);
              const dropY = clamp(p.y + p.diry * ahead + ny * lateral, 8, H - 8);
              dropBomb(dropX, dropY);
            }
            p.dropIndex++;
          }


          // ra kh·ªèi b·∫£n ƒë·ªì -> x√≥a
          if (p.traveled >= p.length + 60) {
            p.alive = false;
            S.planes.splice(i, 1);
            // n·∫øu kh√¥ng c√≤n m√°y bay n√†o -> t·∫Øt ti·∫øng m√°y bay
            if (S.planes.length === 0) {
              try { playSfx("plane_stop"); } catch (e) { }
            }
          }
        }
      }

      function explodeBomb(b) {
        // n·ªï (hi·ªáu ·ª©ng x√°m)
        // N·ªï l·ªõn h∆°n (big=true) + th√™m v√≤ng xung k√≠ch
        spawnExplosion(b.x, b.targetY, true, "tankGrey");
        try { playSfx("bomb_blast"); } catch (e) { }
        S.particles.push({
          kind: "ring",
          x: b.x,
          y: b.targetY,
          r: 10,
          rGrow: 220,            // t·ªëc ƒë·ªô n·ªü l·ªõn
          a: 0.6,
          aFade: 2.4,            // phai d·∫ßn
          color: "rgba(255,255,255,0.85)",
          life: 0.35
        });

        addScorch(b.x, b.targetY);

        // ph√° t∆∞·ªùng n·∫øu r∆°i tr√∫ng brick/steel/base (k·ªÉ c·∫£ th√©p)
        if (b.hitTile) {
          damageTile(b.hitTile.gx, b.hitTile.gy, 99); // power l·ªõn ƒë·ªÉ ph√° th√©p
        }

        // x√©t s√°t th∆∞∆°ng ng∆∞·ªùi ch∆°i
        const pl = getPlayer();
        if (pl && pl.active) {
          const dist = Math.hypot(pl.x - b.x, pl.y - b.targetY);
          // r∆°i tr√∫ng -> ch·∫øt lu√¥n
          if (dist <= PLANE_CFG.killRadius) {
            killTank(pl);
          } else {
            // n·ªï c·∫°nh 1 √¥ (Chebyshev <= 1) -> -1 m√°u
            const pg = toGrid(pl.x, pl.y);
            const eg = toGrid(b.x, b.targetY);
            const cheb = Math.max(
              Math.abs(pg.gx - eg.gx),
              Math.abs(pg.gy - eg.gy)
            );
            if (cheb === 1) {
              pl.hp = Math.max(0, pl.hp - PLANE_CFG.splashAdjDamage);
              if (pl.hp <= 0) killTank(pl);
              else {
                S.playerHP = pl.hp;
                syncUI();
              }
            }
          }
        }
      }

      function updateBombs(dt) {
        for (let i = S.bombs.length - 1; i >= 0; i--) {
          const b = S.bombs[i];
          if (!b.active) {
            S.bombs.splice(i, 1);
            continue;
          }

          b.y += b.vy * dt;
          if (b.y >= b.targetY) {
            b.active = false;
            explodeBomb(b);
            S.bombs.splice(i, 1);
          }
        }
      }

      function drawPlane(p) {
        // lazy-load ·∫£nh 1 l·∫ßn
        if (!S._planeImg) {
          S._planeImg = new Image();
          S._planeImg.src = "plane.png"; // file ƒë·∫∑t c·∫°nh index.html
        }
        const img = S._planeImg;
        if (!img.complete || !img.naturalWidth) return;

        // Scale theo chi·ªÅu cao mong mu·ªën
        const targetH = PLANE_CFG.size * 2.4; // c√≥ th·ªÉ ch·ªânh 2.0‚Äì3.0
        const ratio = img.naturalWidth / img.naturalHeight;
        const w = targetH * ratio,
          h = targetH;

        // ------ FIX: anchor (t√¢m xoay) theo th√¢n m√°y bay ------
        // ·∫¢nh c√≥ nhi·ªÅu transparent padding; tr·ªçng t√¢m th√¢n ~35% ngang, ~52% d·ªçc.
        const ax = w * 0.37; // t·ª´ tr√°i qua
        const ay = h * 0.55; // t·ª´ tr√™n xu·ªëng

        ctx.save();
        ctx.translate(p.x, p.y);

        const base = Math.atan2(p.diry, p.dirx);
        ctx.rotate(base + (PLANE_CFG.spriteFix || 0));

        // L·∫≠t d·ªçc sau khi xoay ƒë·ªÉ kh√¥ng b·ªã "√∫p"
        if (PLANE_CFG.flipVertical) ctx.scale(1, -1);

        ctx.imageSmoothingEnabled = true;
        // Khi ƒë√£ scale(1,-1), to·∫° ƒë·ªô Y c·ªßa ·∫£nh ph·∫£i ƒë·ªïi d·∫•u ·ªü offset
        const drawY = PLANE_CFG.flipVertical ? +ay : -ay;
        ctx.drawImage(img, -ax, drawY, w, h);

        ctx.restore();
      }

      function drawBomb(b) {
        // b√≥ng tr√™n m·∫∑t ƒë·∫•t (gi·ªØ nh∆∞ c≈©)
        const t = clamp((b.y - 0) / (b.targetY - 0), 0, 1);
        const shadowR = 8 + 10 * t;
        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.ellipse(
          b.x + 6,
          b.targetY + 4,
          shadowR,
          shadowR * 0.42,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.restore();

        // v·∫Ω bom b·∫±ng ·∫£nh
        if (!S._bombImg) {
          S._bombImg = new Image();
          S._bombImg.src = "bomb.png"; // ƒë·∫∑t c·∫°nh index.html
        }
        const img = S._bombImg;
        if (!img.complete || !img.naturalWidth) return;

        // cƒÉn gi·ªØa ·∫£nh t·∫°i (b.x, b.y), m≈©i h∆∞·ªõng xu·ªëng
        const targetH = Math.max(22, TILE * 0.9); // ch·ªânh k√≠ch th∆∞·ªõc ·ªü ƒë√¢y n·∫øu mu·ªën
        const ratio = img.naturalWidth / img.naturalHeight;
        const w = targetH * ratio;
        const h = targetH;

        ctx.save();
        ctx.translate(b.x, b.y);
        // ·∫¢nh bomb ƒë√£ ƒë√∫ng chi·ªÅu m≈©i xu·ªëng; kh√¥ng c·∫ßn xoay. N·∫øu file c·ªßa b·∫°n m≈©i l√™n, d√πng: ctx.rotate(Math.PI);
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(img, -w / 2, -h / 2, w, h);
        ctx.restore();
      }

      // ===== Tanks & Bullets =====
      function newPlayer() {
        const p = toPx(7, 10); // ngay tr√™n cƒÉn c·ª© nh∆∞ng ngo√†i t∆∞·ªùng
        const now = performance.now();
        return {
          id: "P-" + Math.random().toString(36).slice(2),
          x: p.x,
          y: p.y,
          dir: "up",
          speed: 100,
          size: TILE - 1,
          hp: 3,
          power: 1,
          cd: 340,
          last: 0,
          isPlayer: true,
          active: true,
          hasBullet: false,
          trackPhase: 0, // pha x√≠ch (0..1)
          trackOn: false, // c√≥ ƒëang ch·∫°y kh√¥ng
          _smokeTimer: 0,

          // NEW: v√¥ ƒë·ªãch ng·∫Øn + nh·∫•p nh√°y khi v·ª´a xu·∫•t hi·ªán ·ªü Th√†nh C·ªï
          spawnInvulnUntil: now + 900, // ms (1.8s)
          spawnBlinkPeriod: 180, // ms, chu k·ª≥ nh·∫•p nh√°y
        };
      }

      function newEnemy(kind) {
        const armored = kind === "armored";
        const sp = choice(S.spawn.points);
        const testSize = armored ? TILE - 1 : TILE - 6;
        let gx = sp.gx,
          gy = sp.gy,
          tries = 5;
        let pos = toPx(gx, gy);
        while (tries--) {
          if (
            !blockedForTank(pos.x, pos.y, testSize) &&
            !overlapAnyTank(pos.x, pos.y, testSize)
          )
            break;
          const alt = choice(S.spawn.points);
          gx = alt.gx;
          gy = alt.gy;
          pos = toPx(gx, gy);
        }
        if (blockedForTank(pos.x, pos.y, testSize)) return null;

        return {
          id: "E-" + kind + "-" + Math.random().toString(36).slice(2),
          x: pos.x,
          y: pos.y,
          dir: "down",
          speed: 80,
          size: testSize,
          hp: armored ? 3 : 1,
          power: armored ? 2 : 1,
          cd: armored ? 600 : 800,
          last: 0,
          isPlayer: false,
          active: true,
          kind,
          ai: { next: performance.now() + 300, think: 500 },
          hasBullet: false,
          trackPhase: 0,
          trackOn: false,
        };
      }
      function blockedForTank(x, y, size) {
        const half = size / 2;
        // Th√™m buffer nh·ªè ƒë·ªÉ tr√°nh g√≥c ch·∫øt
        const buffer = 2; // pixel
        const left = Math.floor((x - half + buffer) / TILE),
          right = Math.floor((x + half - buffer) / TILE),
          top = Math.floor((y - half + buffer) / TILE),
          bottom = Math.floor((y + half - buffer) / TILE);
        // === KI·ªÇM TRA ∆ØU TI√äN: Xe ƒëang ·ªü tr√™n c·∫ßu? ===
        const centerOnBridge = isOnBridge(x, y);

        // N·∫øu t√¢m xe ƒëang tr√™n c·∫ßu -> cho ph√©p di chuy·ªÉn t·ª± do trong v√πng c·∫ßu + s√¥ng
        if (centerOnBridge) {
          // Ch·ªâ ki·ªÉm tra collision v·ªõi tile-based obstacles (brick, steel, base)
          // B·ªé QUA ki·ªÉm tra s√¥ng (rectTouchesRiver)
          for (let gy = top; gy <= bottom; gy++) {
            for (let gx = left; gx <= right; gx++) {
              if (!within(gx, gy)) return true;
              const t = S.map[gy][gx];
              if (
                t &&
                (t.type === "brick" ||
                  t.type === "steel" ||
                  t.type === "base")
              ) {
                return true;
              }
            }
          }
          return false; // t·ª± do di chuy·ªÉn tr√™n c·∫ßu/s√¥ng
        }
        // 1) N·∫øu b·∫•t k·ª≥ ph·∫ßn n√†o c·ªßa hitbox ch·∫°m s√¥ng (kh√¥ng tr√™n c·∫ßu) => CH·∫∂N
        if (rectTouchesRiver(x, y, size)) return true;

        // 2) C√°c ch∆∞·ªõng ng·∫°i tile-based kh√°c v·∫´n gi·ªØ nguy√™n
        for (let gy = top; gy <= bottom; gy++) {
          for (let gx = left; gx <= right; gx++) {
            if (!within(gx, gy)) return true;
            const t = S.map[gy][gx];
            if (
              t &&
              (t.type === "brick" || t.type === "steel" || t.type === "base")
            ) {
              return true;
            }
          }
        }
        return false;
      }

      function rectOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
        return (
          Math.abs(ax - bx) * 2 < aw + bw && Math.abs(ay - by) * 2 < ah + bh
        );
      }
      function overlapAnyTank(x, y, size) {
        return S.tanks.some(
          (t) =>
            t.active &&
            rectOverlap(x, y, size, size, t.x, t.y, t.size, t.size)
        );
      }

      function shoot(t) {
        const now = performance.now();
        if (now - t.last < t.cd) return;
        if (t.hasBullet) return;
        const half = t.size / 2;
        let bx = t.x,
          by = t.y;
        const muzz = half + 6;
        if (t.dir === "up") by -= muzz;
        if (t.dir === "down") by += muzz;
        if (t.dir === "left") bx -= muzz;
        if (t.dir === "right") bx += muzz;
        S.bullets.push({
          x: bx,
          y: by,
          dir: t.dir,
          speed: t.isPlayer ? 380 : 320,
          power: t.power,
          owner: t.id,
          active: true,

          // === kamehameha fields ===
          age: 0, // th·ªùi gian s·ªëng (s)
          // k√≠ch th∆∞·ªõc: player gi·ªØ nh∆∞ c≈©; ƒë·ªãch power 1 nh·ªè h∆°n r√µ r·ªát
          width: t.isPlayer ? 3 + t.power * 1.0 : t.power === 1 ? 2.6 : 4.2,
          // m√†u: t√°ch theo power c·ªßa ƒë·ªãch
          core: t.isPlayer
            ? BULLET_COL.player.core
            : t.power === 1
              ? BULLET_COL.enemyBasic.core
              : BULLET_COL.enemyArmored.core,
          aura: t.isPlayer
            ? BULLET_COL.player.aura
            : t.power === 1
              ? BULLET_COL.enemyBasic.aura
              : BULLET_COL.enemyArmored.aura,

          trail: 0, // chi·ªÅu d√†i v·ªát
        });
        t.last = now;
        t.hasBullet = true;
        if (t.isPlayer) playSfx("shoot");
        else playSfx("shoot_enemy");
      }

      function damageTile(gx, gy, power) {
        const tile = S.map[gy][gx];
        if (tile.type === "brick" || tile.type === "steel") {
          tile.hp = (tile.hp || (tile.type === "brick" ? 1 : 3)) - power;
          if ((tile.hp || 0) <= 0) {
            S.map[gy][gx] = { type: "empty" };
            const c = toPx(gx, gy);
            spawnExplosion(c.x, c.y, false);
            try {
              playSfx("explode_wall");
            } catch (e) { }
          }
        }
        if (tile.type === "base") {
          S.base.alive = false;
          const c = toPx(gx, gy);
          spawnExplosion(c.x, c.y, true);
          try {
            playSfx("base_destroyed");
          } catch (e) { }
          endGame(false);
        }
      }

      function killTank(t) {
        t.active = false;
        try {
          explodeTankCinematic(t.x, t.y);
          playSfx("explode_tank");
        } catch (e) { }

        if (t.isPlayer) {
          S.lives = Math.max(0, S.lives - 1);
          if (S.lives <= 0) {
            endGame(false);
            return;
          }
          const np = newPlayer();
          S.playerId = np.id;
          replacePlayer(t, np);
          S.playerHP = np.hp;
          S.playerPower = np.power;
        } else {
          S.spawn.active = Math.max(0, S.spawn.active - 1);
          S.enemiesRemaining = Math.max(0, S.enemiesRemaining - 1);
          S.score += t.kind === "basic" ? 100 : 200;
          const key = t.kind === "basic" ? "basicLeft" : "armoredLeft";
          if (S.spawn[key] > 0) S.spawn.preferred = t.kind;
        }
        syncUI();
      }
      function replacePlayer(oldT, np) {
        S.tanks = S.tanks.filter((z) => z !== oldT);
        S.tanks.push(np);
      }

      // ===== Items =====
      function planItems() {
        const now = performance.now();
        const plan = (count, minS, maxS, forceFirstAt = null) => {
          const a = [];
          for (let i = 0; i < count; i++) {
            if (i === 0 && forceFirstAt !== null) {
              // Item ƒë·∫ßu ti√™n xu·∫•t hi·ªán t·∫°i th·ªùi ƒëi·ªÉm ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh
              a.push(now + forceFirstAt * 1000);
            } else {
              a.push(now + (minS + Math.random() * (maxS - minS)) * 1000);
            }
          }
          return a.sort((a, b) => a - b);
        };

        S.itemPlan.stars = plan(3, 25, PLAY_SECONDS - 30, 20); // Star ƒë·∫ßu ti√™n xu·∫•t hi·ªán sau 25s
        S.itemPlan.shovels = plan(2, 30, PLAY_SECONDS - 35, 25); // Khi√™n ƒë·∫ßu ti√™n xu·∫•t hi·ªán sau 30s
      }
      function spawnItem(kind) {
        let tries = 50;
        while (tries--) {
          const gx = rand(GRID),
            gy = rand(GRID);
          const t = S.map[gy][gx];
          const key = `${gx},${gy}`;

          // Ki·ªÉm tra ƒëi·ªÅu ki·ªán c∆° b·∫£n: tile ph·∫£i empty v√† kh√¥ng ph·∫£i base
          if (t.type !== "empty" || key === `${S.base.gx},${S.base.gy}`)
            continue;

          const p = toPx(gx, gy);

          // Ki·ªÉm tra kh√¥ng ƒë∆∞·ª£c r∆°i tr√™n s√¥ng
          if (isInRiver(p.x, p.y)) continue;

          // Ki·ªÉm tra kh√¥ng ƒë∆∞·ª£c r∆°i tr√™n c·∫ßu
          if (isOnBridge(p.x, p.y)) continue;

          // Ki·ªÉm tra Shovel kh√¥ng ƒë∆∞·ª£c r∆°i trong khu v·ª±c b·∫£o v·ªá th√†nh c·ªï (2 l·ªõp t∆∞·ªùng)
          if (kind === "shovel") {
            const baseCx = S.base.gx,
              baseCy = S.base.gy;
            const dx = Math.abs(gx - baseCx);
            const dy = Math.abs(gy - baseCy);
            const maxDist = Math.max(dx, dy);

            // Kh√¥ng spawn trong v√πng 2 l·ªõp t∆∞·ªùng b·∫£o v·ªá (b√°n k√≠nh 2 √¥ t·ª´ base)
            if (maxDist <= 2) continue;
          }

          // V·ªã tr√≠ h·ª£p l·ªá, t·∫°o item - C·∫¢ STAR V√Ä SHOVEL ƒê·ªÄU R∆†I
          const startY = p.y - TILE * 3; // c·∫£ hai ƒë·ªÅu r∆°i t·ª´ tr√™n cao
          S.items.push({
            kind,
            x: p.x,
            y: startY,
            // Th√™m c√°c thu·ªôc t√≠nh cho hi·ªáu ·ª©ng r∆°i
            fallY: p.y - TILE * 3, // v·ªã tr√≠ b·∫Øt ƒë·∫ßu r∆°i (cao 3 tile cho c·∫£ star v√† shovel)
            targetY: p.y, // v·ªã tr√≠ ƒë√≠ch
            falling: true, // C·∫¢ STAR V√Ä SHOVEL ƒê·ªÄU R∆†I
            fallSpeed: 0, // t·ªëc ƒë·ªô r∆°i ban ƒë·∫ßu
            bounce: 0, // s·ªë l·∫ßn n·∫£y
            bounceHeight: 0, // ƒë·ªô cao n·∫£y
            bouncePhase: 0, // pha n·∫£y
            // Th√™m rotation cho hi·ªáu ·ª©ng xoay
            rotation: 0, // g√≥c xoay hi·ªán t·∫°i (radian)
            rotationSpeed: kind === "star" ? 1.5 : 1.2, // t·ªëc ƒë·ªô xoay (radian/s) - star nhanh h∆°n shovel m·ªôt ch√∫t
            expiresAt: performance.now() + 12000,
            active: true,
          });
          break;
        }
      }

      // ===== Game Flow =====
      function resetGame() {
        setupLevel();
        S.tanks = [];
        S.bullets = [];
        S.items = [];
        S.planes = [];
        S.bombs = [];
        S.planeSpawned = false;
        try { playSfx("plane_stop"); } catch (e) { }
        if (typeof planeCueEl !== "undefined" && planeCueEl) {
          try { planeCueEl.pause(); planeCueEl.currentTime = 0; } catch (e) { }
        }
        S.spawn = {
          active: 0,
          basicLeft: TOTAL_BASIC,
          armoredLeft: TOTAL_ARMORED,
          totalSpawned: 0,
          cooldown: 1200,
          next: 0,
          preferred: null,
          points: [
            { gx: 1, gy: 1 },
            { gx: 7, gy: 1 },
            { gx: 13, gy: 1 },
          ],
        };
        const p = newPlayer();
        S.playerId = p.id;
        S.tanks.push(p);
        S.lives = 3;
        S.playerHP = 3;
        S.playerPower = 1;
        S.enemiesRemaining = TOTAL_BASIC + TOTAL_ARMORED;
        S.score = 0;
        S.timeLeft = PLAY_SECONDS;
        S.elapsed = 0;
        S.lastTime = 0;
        S.shovelUntil = 0;
        S.status = "playing";
        S.running = true;
        planItems();
        syncUI();
        overlay.style.display = "none";
        btnRestart.style.display = "none";
      }
      function endGame(win) {
        if (!S.running) return;
        S.running = false;
        // T·∫Øt H·∫≤N to√†n b·ªô √¢m thanh li√™n quan ƒë·∫øn m√°y bay/cue
        try { playSfx("plane_stop"); } catch (e) { }
        if (typeof planeCueEl !== "undefined" && planeCueEl) {
          try { planeCueEl.pause(); planeCueEl.currentTime = 0; } catch (e) { }
        }
        S.status = win ? "won" : "lost";
        try {
          playSfx(win ? "win" : "lose");
        } catch (e) { }
        overlay.innerHTML = `<h2>${win
          ? "Th√†nh c·ªï b·∫•t di·ªát ‚Äì 81 ng√†y ƒë√™m anh d≈©ng"
          : "S√¥ng Th·∫°ch H√£n v·∫´n ƒë·ªè m√°u anh h√πng"
          }</h2><p>Score: ${S.score
          }</p><div class="btns"><button class="btn restart" id="ovRestart">Restart</button></div>`;
        overlay.style.display = "flex";
        btnRestart.style.display = "inline-block";
        setTimeout(() => {
          const ov = document.getElementById("ovRestart");
          if (ov) ov.onclick = () => resetGame();
        }, 0);
      }

      function syncUI() {
        uiLives.textContent = S.lives;
        uiHP.textContent = getPlayer()?.hp ?? 0;
        uiPower.textContent = getPlayer()?.power ?? 1;
        uiEnemies.textContent = S.enemiesRemaining;
        uiScore.textContent = S.score;
        const mm = Math.floor(S.timeLeft / 60),
          ss = (S.timeLeft % 60).toString().padStart(2, "0");
        uiTime.textContent = `${mm}:${ss}`;
      }

      function getPlayer() {
        return S.tanks.find((t) => t.isPlayer && t.active);
      }

      // ===== Input =====
      window.addEventListener("keydown", (e) => {
        if (S.status !== "playing") return;
        if (e.key === "ArrowUp") {
          S.keys.up = true;
          e.preventDefault();
        } else if (e.key === "ArrowDown") {
          S.keys.down = true;
          e.preventDefault();
        } else if (e.key === "ArrowLeft") {
          S.keys.left = true;
          e.preventDefault();
        } else if (e.key === "ArrowRight") {
          S.keys.right = true;
          e.preventDefault();
        } else if (e.key === " ") {
          S.keys.shoot = true;
          e.preventDefault();
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.key === "ArrowUp") S.keys.up = false;
        else if (e.key === "ArrowDown") S.keys.down = false;
        else if (e.key === "ArrowLeft") S.keys.left = false;
        else if (e.key === "ArrowRight") S.keys.right = false;
        else if (e.key === " ") S.keys.shoot = false;
      });

      // ===== Loop =====
      function loop(now) {
        if (S.lastTime === 0) S.lastTime = now;
        const dt = (now - S.lastTime) / 1000;
        S.lastTime = now;
        if (S.status === "playing" && S.running) {
          S.elapsed += dt;
          const remain = Math.max(0, PLAY_SECONDS - Math.floor(S.elapsed));
          if (remain !== S.timeLeft) {
            S.timeLeft = remain;
            syncUI();
          }
          if (remain <= 0) {
            if (S.base.alive && S.lives > 0) endGame(true);
            else endGame(false);
          }
          update(dt, now);
          draw();
        } else {
          draw();
        }
        requestAnimationFrame(loop);
      }
      function updateWind(dt, now) {
        const W = S.wind;
        W.phase += dt * W.speed;

        // th·ªânh tho·∫£ng th·ªïi gi√≥ m·∫°nh 1.5‚Äì3 gi√¢y
        if (!W.gusting && Math.random() < dt * 0.12) {
          // ‚Üë xu·∫•t hi·ªán gust th∆∞·ªùng h∆°n
          W.gusting = true;
          W.gustUntil = now + 900 + Math.random() * 900; // ‚Üë gust ng·∫Øn, v√†o d·ªìn d·∫≠p
        }
        if (W.gusting && now >= W.gustUntil) W.gusting = false;

        const base = Math.sin(W.phase) * W.base;
        const gust = W.gusting ? Math.sin(W.phase * 2.2) * (W.base * 0.9) : 0;
        W.value = base + gust; // gi√° tr·ªã gi√≥ d√πng ƒë·ªÉ l·∫Øc b·ª•i c√¢y
      }

      // gi√≥ t·∫°i m·ªôt √¥ nh·∫•t ƒë·ªãnh (cho c·∫£m gi√°c nhi·ªÖu nh·∫π theo v·ªã tr√≠)
      function windAtTile(gx, gy, layer = 1) {
        // l·ªách pha theo grid ƒë·ªÉ b·ª•i kh√¥ng l·∫Øc y h·ªát nhau
        const phaseJitter = gx * 0.35 + gy * 0.22 + layer * 0.9;
        return (
          S.wind.value * (0.6 + 0.4 * Math.sin(S.wind.phase + phaseJitter))
        );
      }

      // === √Çm thanh b√°o m√°y bay (MP3) ‚Äî ph√°t tr∆∞·ªõc khi m√°y bay xu·∫•t hi·ªán 10s ===
      const PLANE_CUE_SRC = "sound_plane.mp3"; // ƒë·∫∑t file c·∫°nh index.html
      let planeCueEl = null;

      function playPlaneCue() {
        // T√¥n tr·ªçng n√∫t b·∫≠t/t·∫Øt √¢m v√† volume c·ªßa game
        if (typeof AUDIO !== "undefined" && AUDIO.enabled === false) return;

        if (!planeCueEl) {
          planeCueEl = document.createElement("audio");
          planeCueEl.src = PLANE_CUE_SRC;
          planeCueEl.preload = "auto";
          // N·∫øu ƒëang d√πng WebAudio master, n·ªëi v√†o master ƒë·ªÉ ƒÉn volume slider
          try {
            if (AUDIO && AUDIO.ctx && AUDIO.master && !planeCueEl._node) {
              planeCueEl._node = AUDIO.ctx.createMediaElementSource(planeCueEl);
              planeCueEl._node.connect(AUDIO.master);
            }
          } catch (e) {
            // ignore (tr√¨nh duy·ªát c√≥ th·ªÉ kh√¥ng cho createMediaElementSource n·∫øu g·ªçi nhi·ªÅu l·∫ßn)
          }
        }

        try {
          planeCueEl.currentTime = 0;
          planeCueEl.play();
        } catch (e) {
          // ignore autoplay restrictions: ng∆∞·ªùi ch∆°i ƒë√£ b·∫•m Start n√™n th∆∞·ªùng s·∫Ω ch∆°i ƒë∆∞·ª£c
        }
      }


      function update(dt, now) {
        updateWind(dt, now);
        // === Ph√°t √¢m thanh b√°o tr∆∞·ªõc 10s ===
        const cueAt = Math.max(0, PLANE_CFG.startAfter - 10);
        // Khi game m·ªõi/restart -> elapsed quay v·ªÅ nh·ªè h∆°n cueAt, reset c·ªù ƒë·ªÉ l·∫ßn sau ph√°t l·∫°i
        if (S.elapsed < cueAt) {
          S.planeCuePlayed = false;
        } else if (S.running && !S.planeCuePlayed && !S.planeSpawned) {
          playPlaneCue();
          S.planeCuePlayed = true;
        }

        if (!S.planeSpawned && S.elapsed >= PLANE_CFG.startAfter) {
          spawnPlane();
        }

        // c·∫≠p nh·∫≠t m√°y bay & bom
        updatePlanes(dt, now);
        updateBombs(dt);

        // === Engine sound ch·ªâ b·∫≠t khi ƒêANG CH∆†I v√† c√≥ m√°y bay n·∫±m TRONG b·∫£n ƒë·ªì ===
        const anyPlaneInView = S.planes.some(p =>
          p.x >= 0 && p.x <= W && p.y >= 0 && p.y <= H
        );

        if (S.running && anyPlaneInView) {
          if (!AUDIO._plane) { try { playSfx("plane_start"); } catch (e) { } }
        } else {
          if (AUDIO._plane) { try { playSfx("plane_stop"); } catch (e) { } }
        }
        // Items schedule
        if (S.itemPlan.stars.length && now >= S.itemPlan.stars[0]) {
          S.itemPlan.stars.shift();
          spawnItem("star");
        }
        if (S.itemPlan.shovels.length && now >= S.itemPlan.shovels[0]) {
          S.itemPlan.shovels.shift();
          spawnItem("shovel");
        }
        // expire items
        for (const it of S.items) {
          if (it.active && it.expiresAt && now >= it.expiresAt)
            it.active = false;
        }

        // === C·∫¨P NH·∫¨T HI·ªÜU ·ª®NG R∆†I CHO ITEMS ===
        for (const it of S.items) {
          if (!it.active) continue;

          // C·∫≠p nh·∫≠t rotation (xoay ƒë·ªÅu cho c·∫£ star v√† shovel)
          it.rotation = (it.rotation || 0) + (it.rotationSpeed || 1.0) * dt;
          if (it.rotation > Math.PI * 2) it.rotation -= Math.PI * 2; // gi·ªØ trong 0-2œÄ

          if (it.falling && it.y < it.targetY) {
            // ƒêang r∆°i xu·ªëng
            it.fallSpeed += 320 * dt; // gia t·ªëc tr·ªçng tr∆∞·ªùng
            it.y += it.fallSpeed * dt;

            // Ki·ªÉm tra ch·∫°m ƒë·∫•t
            if (it.y >= it.targetY) {
              it.y = it.targetY;
              it.falling = false;

              // Hi·ªáu ·ª©ng n·∫£y nh·∫π cho star
              if (it.kind === "star") {
                it.bounce = 3; // s·ªë l·∫ßn n·∫£y
                it.bounceHeight = 8; // ƒë·ªô cao n·∫£y
                it.bouncePhase = 0; // pha n·∫£y
              }
            }
          } else if (it.bounce > 0) {
            // Hi·ªáu ·ª©ng n·∫£y sau khi ch·∫°m ƒë·∫•t
            it.bouncePhase += dt * 8; // t·ªëc ƒë·ªô n·∫£y
            const bounceOffset =
              Math.sin(it.bouncePhase) * it.bounceHeight * (it.bounce / 3);
            it.y = it.targetY - Math.max(0, bounceOffset);

            if (it.bouncePhase >= Math.PI) {
              it.bounce--;
              it.bounceHeight *= 0.6; // gi·∫£m ƒë·ªô cao m·ªói l·∫ßn n·∫£y
              it.bouncePhase = 0;
              if (it.bounce <= 0) {
                it.y = it.targetY; // v·ªÅ v·ªã tr√≠ cu·ªëi
              }
            }
          }

          // C·∫≠p nh·∫≠t v·ªã tr√≠ y cho star r∆°i
          if (it.kind === "star" && it.falling) {
            it.y = it.fallY + it.fallSpeed * (it.fallSpeed / 320); // t√≠nh v·ªã tr√≠ d·ª±a tr√™n t·ªëc ƒë·ªô
          }
        }
        // player pickup
        const pl = getPlayer();
        if (pl) {
          for (const it of S.items) {
            if (!it.active) continue;
            if (
              rectOverlap(
                pl.x,
                pl.y,
                pl.size,
                pl.size,
                it.x,
                it.y,
                TILE,
                TILE
              )
            ) {
              it.active = false;
              if (it.kind === "star") {
                S.score += 50;
                pl.power = Math.min(3, pl.power + 1);
                S.playerPower = pl.power;
              } else {
                S.score += 50;
                setBaseWalls("steel");
                S.shovelUntil = performance.now() + 20000;
              }
              syncUI();
            }
          }
        }

        // shovel timer
        if (S.shovelUntil && now >= S.shovelUntil) {
          S.shovelUntil = 0;
          setBaseWalls("brick");
        }

        // Spawning
        if (
          S.spawn.totalSpawned < TOTAL_BASIC + TOTAL_ARMORED &&
          S.spawn.active < MAX_ACTIVE_ENEMIES &&
          now >= S.spawn.next
        ) {
          let type = null;
          if (
            S.spawn.preferred &&
            S.spawn[
            S.spawn.preferred === "basic" ? "basicLeft" : "armoredLeft"
            ] > 0
          ) {
            type = S.spawn.preferred;
            S.spawn.preferred = null;
          } else {
            const ops = [];
            if (S.spawn.basicLeft > 0) ops.push("basic");
            if (S.spawn.armoredLeft > 0) ops.push("armored");
            if (ops.length) type = choice(ops);
          }
          if (type) {
            const e = newEnemy(type);
            if (e) {
              S.tanks.push(e);
              S.spawn.totalSpawned++;
              S.spawn.active++;
              if (type === "basic") S.spawn.basicLeft--;
              else S.spawn.armoredLeft--;
            }
            S.spawn.next = performance.now() + S.spawn.cooldown;
          }
        }

        // Update player
        if (pl) {
          let dx = 0,
            dy = 0;

          // ∆Øu ti√™n tr·ª•c d·ªçc n·∫øu ƒëang gi·ªØ Up/Down; n·∫øu kh√¥ng th√¨ x√©t Left/Right.
          if (S.keys.up || S.keys.down) {
            dy = S.keys.up ? -1 : 1;
            pl.dir = S.keys.up ? "up" : "down";
          } else if (S.keys.left || S.keys.right) {
            dx = S.keys.left ? -1 : 1;
            pl.dir = S.keys.left ? "left" : "right";
          }

          const step = pl.speed * dt;
          tryMove(pl, dx * step, dy * step);
          // ƒë√°nh d·∫•u ƒëang ch·∫°y & c·∫≠p nh·∫≠t pha x√≠ch
          pl.trackOn = dx !== 0 || dy !== 0;
          if (pl.trackOn) {
            pl.trackPhase =
              (pl.trackPhase + (pl.speed * dt) / (TILE * 0.5)) % 1;

            // Sinh kh√≥i theo nh·ªãp ƒë·ªÅu (m·∫∑c ƒë·ªãnh ~16 fps): m·ªói 0.06s m·ªôt ƒë·ª£t 2 h·∫°t t·ª´ 2 ·ªëng x·∫£
            pl._smokeTimer += dt;
            const cadence = 0.06; // ch·ªânh d√†y/lo√£ng kh√≥i
            while (pl._smokeTimer >= cadence) {
              pl._smokeTimer -= cadence;
              spawnPlayerSmoke(pl);
            }
          } else {
            pl._smokeTimer = 0;
            pl.trackPhase = pl.trackPhase * 0.9;
          }

          if (S.keys.shoot) shoot(pl);
        }
        // Update enemies
        for (const t of S.tanks) {
          if (!t.active || t.isPlayer) continue;
          if (now >= t.ai.next) {
            t.ai.next = now + t.ai.think;
            const pl = getPlayer();
            if (pl && Math.random() < 0.6) {
              const pg = toGrid(pl.x, pl.y),
                eg = toGrid(t.x, t.y);
              if (pg.gx === eg.gx) t.dir = pg.gy < eg.gy ? "up" : "down";
              else if (pg.gy === eg.gy)
                t.dir = pg.gx < eg.gx ? "left" : "right";
              else if (Math.random() < 0.5)
                t.dir = pg.gx < eg.gx ? "left" : "right";
              else t.dir = pg.gy < eg.gy ? "up" : "down";
            } else if (Math.random() < 0.4) {
              t.dir = choice(DIRS);
            }
            if (Math.random() < 0.55) shoot(t);
          }
          const step = t.speed * dt;
          const moved = tryMove(
            t,
            t.dir === "left" ? -step : t.dir === "right" ? step : 0,
            t.dir === "up" ? -step : t.dir === "down" ? step : 0
          );
          t.trackOn = moved;
          if (t.trackOn) {
            t.trackPhase = (t.trackPhase + (t.speed * dt) / (TILE * 0.5)) % 1;
          } else {
            t.trackPhase = t.trackPhase * 0.9;
          }

          if (!moved) t.dir = choice(DIRS);
        }

        // Update bullets
        for (const b of S.bullets) {
          if (!b.active) continue;
          b.age = (b.age || 0) + dt;
          const dist = b.speed * dt;
          if (b.dir === "up") b.y -= dist;
          if (b.dir === "down") b.y += dist;
          if (b.dir === "left") b.x -= dist;
          if (b.dir === "right") b.x += dist;
          if (b.x < 0 || b.y < 0 || b.x > W || b.y > H) {
            b.active = false;
            releaseOwner(b.owner);
            continue;
          }
          const g = toGrid(b.x, b.y);
          if (within(g.gx, g.gy)) {
            const tt = S.map[g.gy][g.gx];
            if (
              tt.type === "brick" ||
              tt.type === "steel" ||
              tt.type === "base"
            ) {
              //TODO: note add more line
              damageTile(g.gx, g.gy, b.power);
              spawnExplosion(b.x, b.y, false);
              try {
                playSfx("explode_wall");
              } catch (e) { }

              b.active = false;
              releaseOwner(b.owner);
              continue;
            }
          }

          //TODO: set god mode
          for (const t of S.tanks) {
            if (!t.active) continue;
            if (t.id === b.owner) continue;
            if (!rectOverlap(b.x, b.y, 6, 6, t.x, t.y, t.size, t.size))
              continue;

            // B·ªé QUA n·∫øu player ƒëang v√¥ ƒë·ªãch khi m·ªõi spawn
            if (
              t.isPlayer &&
              t.spawnInvulnUntil &&
              performance.now() < t.spawnInvulnUntil
            ) {
              continue;
            }

            // Ai l√† ch·ªß vi√™n ƒë·∫°n?
            const owner = S.tanks.find((z) => z.id === b.owner);

            const ownerIsPlayer = !!(owner && owner.isPlayer);

            // T·∫ÆT FRIENDLY FIRE:
            // - ƒê·∫°n ng∆∞·ªùi ch∆°i ch·ªâ l√†m ƒëau ƒë·ªãch (kh√¥ng bao gi·ªù tr√∫ng player).
            // - ƒê·∫°n ƒë·ªãch ch·ªâ l√†m ƒëau ng∆∞·ªùi ch∆°i (ƒëi xuy√™n qua xe ƒë·ªãch kh√°c).
            if (ownerIsPlayer && t.isPlayer) {
              // ƒë·∫°n c·ªßa m√¨nh ch·∫°m ch√≠nh m√¨nh -> b·ªè qua
              continue;
            }
            if (!ownerIsPlayer && !t.isPlayer) {
              // ƒë·∫°n ƒë·ªãch ch·∫°m xe ƒë·ªãch -> b·ªè qua (cho ƒë·∫°n ƒëi ti·∫øp)
              continue;
            }

            // √Åp d·ª•ng s√°t th∆∞∆°ng b√¨nh th∆∞·ªùng
            t.hp -= b.power;

            // n·ªï nh·ªè nh∆∞ng d√†y ·ªü ƒëi·ªÉm va ch·∫°m
            spawnExplosion(b.x, b.y, false, "hit");

            b.active = false;
            releaseOwner(b.owner);
            if (t.hp <= 0) {
              killTank(t);
            } else if (t.isPlayer) {
              S.playerHP = t.hp;
              syncUI();
            }
            break; // ƒë√£ x·ª≠ l√Ω va ch·∫°m cho vi√™n ƒë·∫°n n√†y
          }
        }
        updateParticles(dt);
        // gi·∫£m th·ªùi gian t·ªìn t·∫°i v·∫øt ch√°y
        if (!S.scorches) S.scorches = [];
        for (let i = S.scorches.length - 1; i >= 0; i--) {
          S.scorches[i].life -= dt;
          if (S.scorches[i].life <= 0) S.scorches.splice(i, 1);
        }
        // c·∫≠p nh·∫≠t explosions
        S.explosions = S.explosions.filter((e) => now - e.start < e.duration);
        updateSmokes(dt);
      }

      function updateParticles(dt) {
        for (let i = S.particles.length - 1; i >= 0; i--) {
          const p = S.particles[i];
          p.life -= dt;
          if (p.life <= 0) {
            S.particles.splice(i, 1);
            continue;
          }

          // fade alpha
          if (p.aFade) p.a = Math.max(0, p.a - p.aFade * dt);

          if (p.kind === "ring") {
            p.r += (p.rGrow || 120) * dt;
          } else if (p.kind === "spark") {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= 0.98;
            p.vy *= 0.98;
          } else if (p.kind === "fire") {
            p.x += (p.vx || 0) * dt;
            p.y += (p.vy || 0) * dt;
            p.r += (p.grow || 60) * dt;
          } else if (p.kind === "debris") {
            p.vx += (p.ax || 0) * dt;
            p.vy += (p.ay || 0) * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.rot += (p.vr || 0) * dt;
          } else if (p.kind === "smoke") {
            // kh√≥i x√°m ƒëen loang ra v√† bay nh·∫π l√™n
            p.vx += (p.ax || 0) * dt;
            p.vy += (p.ay || 0) * dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.r += (p.grow || 36) * dt; // n·ªü t·ª´ t·ª´
          }
        }
      }

      function drawParticles() {
        for (const p of S.particles) {
          if (p.kind === "ring") {
            ctx.save();
            ctx.globalAlpha = p.a || 0.4;
            ctx.strokeStyle = p.color || "rgba(255,255,255,0.5)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          } else if (p.kind === "spark") {
            ctx.save();
            ctx.globalAlpha = p.a || 1;
            ctx.strokeStyle = p.color || "#fff";
            ctx.lineWidth = p.w || 2;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x - (p.vx || 0) * 0.03, p.y - (p.vy || 0) * 0.03); // v·ªát ng·∫Øn
            ctx.stroke();
            ctx.restore();
          } else if (p.kind === "fire") {
            ctx.save();
            ctx.globalAlpha = p.a || 1;
            const r = Math.max(1, p.r || 6);
            const g = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, r);
            g.addColorStop(0, p.core || "#fff");
            g.addColorStop(0.5, p.edge || "#ffa94d");
            g.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (p.kind === "debris") {
            ctx.save();
            ctx.globalAlpha = p.a || 1;
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot || 0);
            ctx.fillStyle = p.color || "#6b5b3e";
            ctx.fillRect(
              -(p.w || 3) / 2,
              -(p.h || 2) / 2,
              p.w || 3,
              p.h || 2
            );
            ctx.restore();
          } else if (p.kind === "smoke") {
            // 3 l·ªõp kh√≥i m·ªÅm, x√°m ƒëen -> x√°m nh·∫°t
            const k = Math.max(0, p.life / (p.maxLife || p.life || 0.6)); // 1..0
            const R = Math.max(2, p.r);
            const squash = 1 + 0.25 * (1 - k);

            // l√µi t·ªëi
            ctx.globalAlpha = 0.18 + 0.22 * k;
            ctx.fillStyle = "rgba(60,60,60,0.9)";
            ctx.beginPath();
            ctx.ellipse(
              p.x,
              p.y,
              R * 0.7,
              R * 0.7 * squash,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // trung gian
            ctx.globalAlpha = 0.15 + 0.18 * k;
            ctx.fillStyle = "rgba(140,145,150,0.7)";
            ctx.beginPath();
            ctx.ellipse(p.x, p.y, R, R * squash, 0, 0, Math.PI * 2);
            ctx.fill();

            // vi·ªÅn nh·∫°t
            ctx.globalAlpha = 0.1 + 0.12 * k;
            ctx.fillStyle = "rgba(210,215,220,0.5)";
            ctx.beginPath();
            ctx.ellipse(
              p.x,
              p.y,
              R * 1.25,
              R * 1.25 * squash,
              0,
              0,
              Math.PI * 2
            );
            ctx.fill();

            ctx.globalAlpha = 1;
          }
        }
      }
      function explodeTankCinematic(x, y) {
        const now = performance.now();

        // === Gƒê1: tia ch√≥i + qu·∫ßng n·ªï v√†ng-cam + tia l·ª≠a 8 h∆∞·ªõng ===
        // v√≤ng xung k√≠ch tr·∫Øng
        S.particles.push({
          kind: "ring",
          x,
          y,
          r: 6,
          rGrow: 160,
          a: 0.8,
          aFade: 3.2,
          color: "rgba(255,255,255,0.95)",
          life: 0.22,
        });

        // qu·∫ßng l·ª≠a ƒë·∫ßu (v√†ng-cam)
        S.particles.push({
          kind: "fire",
          x,
          y,
          vx: 0,
          vy: 0,
          r: 3,
          grow: 28,
          a: 0.95,
          aFade: 2.2,
          core: "#fff",
          edge: "#ffb74d",
          life: 0.25,
        });

        // tia l·ª≠a 8 h∆∞·ªõng
        for (let i = 0; i < 4; i++) {
          const ang = (i / 8) * Math.PI * 2;
          const spd = 50 + Math.random() * 25;
          S.particles.push({
            kind: "spark",
            x,
            y,
            vx: Math.cos(ang) * spd,
            vy: Math.sin(ang) * spd,
            a: 1.0,
            aFade: 3.8,
            color: "#ffd06b",
            w: 2,
            life: 0.25 + Math.random() * 0.12,
          });
        }

        try {
          playSfx("explode_tank_cinematic");
        } catch (e) { }

        // === Gƒê2: l·ª≠a ch√°y lan v√†ng‚Üícam‚Üíƒë·ªè + kh√≥i x√°m ƒëen + m·∫£nh s·∫Øt ===
        setTimeout(() => {
          // nhi·ªÅu fireball lan
          for (let i = 0; i < 3; i++) {
            const ang = Math.random() * Math.PI * 2;
            const spd = 40 + Math.random() * 50;
            S.particles.push({
              kind: "fire",
              x,
              y,
              vx: Math.cos(ang) * spd,
              vy: Math.sin(ang) * spd - 20,
              r: 1.5 + Math.random() * 2,
              grow: 18,
              a: 0.9,
              aFade: 1.6,
              // pha m√†u ·∫•m d·∫ßn v·ªÅ ƒë·ªè s·∫´m
              core: "#fff",
              edge: Math.random() < 0.5 ? "#ff8c3a" : "#ff5a36",
              life: 0.3 + Math.random() * 0.18,
            });
          }

          // m·∫£nh s·∫Øt (debris) tung to√©
          for (let i = 0; i < 3; i++) {
            const ang = Math.random() * Math.PI * 2;
            const spd = 40 + Math.random() * 40;
            S.particles.push({
              kind: "debris",
              x,
              y,
              vx: Math.cos(ang) * spd,
              vy: Math.sin(ang) * spd - 60,
              ax: 0,
              ay: 320,
              rot: Math.random() * Math.PI,
              vr: -2 + Math.random() * 4,
              w: 1 + Math.random() * 1.5,
              h: 1 + Math.random() * 1.0,
              color: "#5c4a2f",
              a: 0.95,
              aFade: 1.6,
              life: 0.4 + Math.random() * 0.2,
            });
          }

          try {
            playSfx("metal_rattle");
          } catch (e) { }
        }, 120);
      }

      function releaseOwner(id) {
        const o = S.tanks.find((t) => t.id === id);
        if (o) o.hasBullet = false;
      }

      function tryMove(t, dx, dy) {
        if (!dx && !dy) return false;
        const nx = clamp(t.x + dx, t.size / 2, W - t.size / 2),
          ny = clamp(t.y + dy, t.size / 2, H - t.size / 2);
        if (blockedForTank(nx, ny, t.size)) return false;
        for (const o of S.tanks) {
          if (!o.active || o.id === t.id) continue;
          if (rectOverlap(nx, ny, t.size, t.size, o.x, o.y, o.size, o.size))
            return false;
        }
        t.x = nx;
        t.y = ny;
        return true;
      }
      function spawnExplosion(x, y, big = false, kind = "default") {
        // kind: 'default' | 'hit' | 'tankGrey'
        const now = performance.now();
        let duration = big ? 600 : 300;
        if (kind === "hit") duration = 220; // n·ªï nh·ªè nh∆∞ng d√†y
        if (kind === "tankGrey") duration = 480; // n·ªï bom x√°m

        S.explosions.push({ x, y, big, kind, start: now, duration });
      }

      // ===== Render =====
      function roundRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
      }
      function drawStar(cx, cy, spikes, outer, inner) {
        let rot = (Math.PI / 2) * 3,
          x = cx,
          y = cy;
        ctx.beginPath();
        ctx.moveTo(cx, cy - outer);
        for (let i = 0; i < spikes; i++) {
          x = cx + Math.cos(rot) * outer;
          y = cy + Math.sin(rot) * outer;
          ctx.lineTo(x, y);
          rot += Math.PI / spikes;
          x = cx + Math.cos(rot) * inner;
          y = cy + Math.sin(rot) * inner;
          ctx.lineTo(x, y);
          rot += Math.PI / spikes;
        }
        ctx.lineTo(cx, cy - outer);
        ctx.closePath();
      }

      // V·∫Ω icon tr√°i tim nh·ªè (cx l√† t√¢m theo tr·ª•c X, cy l√† m√©p tr√™n)
      function drawHeartSmall(
        cx,
        cy,
        size,
        fill = "#e74c3c",
        stroke = "#5a1a1a"
      ) {
        const w = size,
          h = Math.round(size * 0.9);
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(cx, cy + h * 0.25);
        ctx.bezierCurveTo(
          cx,
          cy,
          cx - w * 0.5,
          cy,
          cx - w * 0.5,
          cy + h * 0.25
        );
        ctx.bezierCurveTo(
          cx - w * 0.5,
          cy + h * 0.55,
          cx,
          cy + h * 0.7,
          cx,
          cy + h
        );
        ctx.bezierCurveTo(
          cx,
          cy + h * 0.7,
          cx + w * 0.5,
          cy + h * 0.55,
          cx + w * 0.5,
          cy + h * 0.25
        );
        ctx.bezierCurveTo(cx + w * 0.5, cy, cx, cy, cx, cy + h * 0.25);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.strokeStyle = stroke;
        ctx.stroke();
        ctx.restore();
      }

      // ===== Player Vietnam decals (star & flag) =====

      function drawFlag(
        ctx,
        x,
        y,
        fw,
        fh,
        time,
        amplitude = 2.5,
        wavelengthFactor = 2
      ) {
        const wavelength = fw / wavelengthFactor;

        ctx.beginPath();
        ctx.moveTo(x, y);
        for (let i = 0; i <= 40; i++) {
          const px = x + (fw / 40) * i;
          const wave = Math.sin(time + px / wavelength) * amplitude;
          const py = y + wave;
          ctx.lineTo(px, py);
        }
        for (let i = 40; i >= 0; i--) {
          const px = x + (fw / 40) * i;
          const wave = Math.sin(time + px / wavelength + 0.3) * amplitude;
          const py = y + fh + wave;
          ctx.lineTo(px, py);
        }
        ctx.closePath();

        ctx.fillStyle = "#d62828";
        ctx.fill();

        // Sao v√†ng ·ªü ch√≠nh gi·ªØa c·ªù (theo s√≥ng)
        const midX = x + fw * 0.5;
        const waveTop = Math.sin(time + midX / wavelength) * amplitude;
        const waveBot = Math.sin(time + midX / wavelength + 0.3) * amplitude;
        const midY = y + fh * 0.5 + (waveTop + waveBot) / 2;

        ctx.fillStyle = "#ffd54d";
        drawStar(midX, midY, 5, fh * 0.35, fh * 0.15);
        ctx.fill();
      }

      function drawThanhCoFlat(x, y, size, alive) {
        if (!alive) {
          // N·∫øu base ƒë√£ b·ªã ph√° -> kh·ªëi x√°m
          ctx.fillStyle = "#444";
          roundRect(x + 4, y + 4, size - 8, size - 8, 6);
          ctx.fill();
          return;
        }

        const towerH = size * 0.9;
        const towerW = size * 0.9;
        const tx = x + (size - towerW) / 2;
        const ty = y + (size - towerH) / 2;

        // === Th√¢n th√†nh c·ªï (nhi·ªÅu t·∫ßng, m√†u ƒë·∫•t ƒë·ªè cam loang) ===
        function fillWall(color1, color2, rx, ry, rw, rh) {
          // gradient d·ªçc nh·∫π
          const g = ctx.createLinearGradient(rx, ry, rx, ry + rh);
          g.addColorStop(0, color1);
          g.addColorStop(1, color2);
          ctx.fillStyle = g;
          ctx.fillRect(rx, ry, rw, rh);
          // ƒëi·ªÉm loang ng·∫´u nhi√™n
          ctx.fillStyle = "rgba(0,0,0,0.1)";
          for (let i = 0; i < 4; i++) {
            ctx.fillRect(
              rx + Math.random() * rw,
              ry + Math.random() * rh,
              2,
              2
            );
          }
        }

        // t·∫ßng d∆∞·ªõi
        fillWall(
          "#c96e35",
          "#a85728",
          tx,
          ty + towerH * 0.55,
          towerW,
          towerH * 0.45
        );
        // t·∫ßng gi·ªØa
        fillWall(
          "#d87c40",
          "#b4652f",
          tx + towerW * 0.1,
          ty + towerH * 0.35,
          towerW * 0.8,
          towerH * 0.25
        );
        // t·∫ßng tr√™n
        fillWall(
          "#e2924d",
          "#c67a35",
          tx + towerW * 0.25,
          ty + towerH * 0.15,
          towerW * 0.5,
          towerH * 0.2
        );

        // === M√°i ng√≥i ƒë·ªè c√≥ highlight ===
        ctx.beginPath();
        ctx.moveTo(tx + towerW * 0.25, ty + towerH * 0.15);
        ctx.lineTo(tx + towerW * 0.75, ty + towerH * 0.15);
        ctx.lineTo(tx + towerW * 0.65, ty);
        ctx.lineTo(tx + towerW * 0.35, ty);
        ctx.closePath();
        const roofGrad = ctx.createLinearGradient(
          tx,
          ty,
          tx,
          ty + towerH * 0.15
        );
        roofGrad.addColorStop(0, "#b00");
        roofGrad.addColorStop(1, "#800");
        ctx.fillStyle = roofGrad;
        ctx.fill();

        // === C√°c c·ª≠a s·ªï nh·ªè (ch·∫•m ƒëen) ===
        ctx.fillStyle = "#111";
        ctx.fillRect(tx + towerW * 0.2, ty + towerH * 0.6, 4, 6);
        ctx.fillRect(tx + towerW * 0.5, ty + towerH * 0.6, 4, 6);
        ctx.fillRect(tx + towerW * 0.7, ty + towerH * 0.6, 4, 6);

        // === C·ªôt c·ªù ===
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + size / 2, ty);
        ctx.lineTo(x + size / 2, ty - size * 0.45);
        ctx.stroke();

        const time = performance.now() / 900; // t·ªëc ƒë·ªô ch·∫≠m
        const flagX = x + size / 2; // g√≥c tr√°i‚Äìtr√™n c·ªßa l√° c·ªù
        const flagY = ty - size * 0.45;
        drawFlag(ctx, flagX, flagY, size * 0.55, size * 0.28, time, 3, 2);
      }
      // RNG theo (gx, gy) ƒë·ªÉ b·ª•i c√¢y m·ªói √¥ h∆°i kh√°c nhau nh∆∞ng c·ªë ƒë·ªãnh
      function rngFromGrid(gx, gy) {
        let s = (gx * 73856093) ^ (gy * 19349663);
        s ^= s << 13;
        s ^= s >>> 17;
        s ^= s << 5;
        return function () {
          s ^= s << 13;
          s ^= s >>> 17;
          s ^= s << 5;
          return (s >>> 0) / 4294967295;
        };
      }
      // V·∫Ω 1 ‚Äúl√°/lobe‚Äù m·ªÅm theo h∆∞·ªõng angle
      function drawLeafLobe(cx, cy, r, angle) {
        const w = r * 0.85; // d√†i l√°
        const h = r * 0.55; // b·ªÅ ngang
        const tip = w; // ƒë·∫ßu l√°
        const sway = 0.15 * r; // ƒë·ªô cong th√¢n l√°

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(angle);

        // b√≥ng d∆∞·ªõi l√° (r·∫•t nh·∫π)
        ctx.fillStyle = "rgba(0,0,0,0.10)";
        ctx.beginPath();
        ctx.ellipse(0, h * 0.4, w * 0.9, h * 0.35, 0, 0, Math.PI * 2);
        ctx.fill();

        // th√¢n l√°: xanh s√°ng -> xanh ƒë·∫≠m
        const grad = ctx.createLinearGradient(0, 0, w, 0);
        grad.addColorStop(0.0, "#b6e07a");
        grad.addColorStop(0.5, "#6fbe56");
        grad.addColorStop(1.0, "#2e7f32");
        ctx.fillStyle = grad;

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(w * 0.35, -sway, tip, 0); // m√©p tr√™n
        ctx.quadraticCurveTo(w * 0.35, sway, 0, 0); // m√©p d∆∞·ªõi quay v·ªÅ g·ªëc
        ctx.closePath();
        ctx.fill();

        // g√¢n l√° m·∫£nh
        ctx.strokeStyle = "rgba(255,255,255,0.28)";
        ctx.lineWidth = Math.max(1, r * 0.08);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(w * 0.45, 0, tip, 0);
        ctx.stroke();

        ctx.restore();
      }

      // V·∫Ω 1 ‚Äúc·ª•m b·ª•i‚Äù (nhi·ªÅu lobe) ‚Äî c√≥ ƒëung ƒë∆∞a theo gi√≥
      function drawBushBlob(cx, cy, r, swayX, rndAngleOffset = 0) {
        // b√≥ng ƒë·ªï c·ªßa c·∫£ c·ª•m
        ctx.fillStyle = "rgba(0,0,0,0.22)";
        ctx.beginPath();
        ctx.ellipse(
          cx + swayX * 0.25,
          cy + r * 0.55,
          r * 1.05,
          r * 0.35,
          0,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // nh√≥m l√°: v·∫Ω t·ª´ nh·ªè -> l·ªõn ƒë·ªÉ c√≥ chi·ªÅu s√¢u
        const count = 12; // s·ªë l√°
        for (let i = 0; i < count; i++) {
          const t = (i + 1) / count;
          const rr = r * (0.55 + t * 0.55); // b√°n k√≠nh l√°
          const ang = rndAngleOffset + i * ((Math.PI * 2) / count);
          const localTilt = swayX * 0.02; // xoay nh·∫π theo gi√≥
          drawLeafLobe(
            cx + swayX * (0.25 + 0.35 * t) + Math.cos(ang) * r * 0.06,
            cy - r * 0.08 * (1 - t),
            rr,
            ang + localTilt
          );
        }

        // highlight vi·ªÅn ngo√†i r·∫•t nh·∫π
        ctx.strokeStyle = "rgba(255,255,255,0.20)";
        ctx.lineWidth = Math.max(1, r * 0.1);
        ctx.beginPath();
        ctx.arc(cx + swayX * 0.25, cy - r * 0.1, r * 0.85, -0.2, 1.0);
        ctx.stroke();
      }

      // V·∫Ω 1 tile b·ª•i (g·ªçi nhi·ªÅu blob + sway theo gi√≥ t·ª´ng l·ªõp)
      function drawBushTile(gx, gy, x, y, size) {
        const rnd = rngFromGrid(gx, gy); // ·ªïn ƒë·ªãnh theo √¥
        const cx = x + size * 0.5;
        const cy = y + size * 0.62;

        // gi√≥ t·∫°i tile + nhi·ªÖu nh·ªè gi·ªØa c√°c l·ªõp
        const swayBase = windAtTile(gx, gy, 1); // px
        const sway1 = swayBase * (0.9 + rnd() * 0.2);
        const sway2 = swayBase * (0.6 + rnd() * 0.2);
        const sway3 = swayBase * (0.35 + rnd() * 0.2);

        const R = size * 0.5;

        // c·ª•m sau xa nh·∫•t
        drawBushBlob(
          cx,
          cy - size * 0.08,
          R * (0.7 + rnd() * 0.1),
          sway3,
          rnd() * Math.PI * 2
        );

        // c·ª•m sau
        drawBushBlob(
          cx - size * 0.04,
          cy - size * 0.03,
          R * (0.9 + rnd() * 0.1),
          sway3,
          rnd() * Math.PI * 2
        );

        // c·ª•m gi·ªØa
        drawBushBlob(
          cx + size * 0.06,
          cy + rnd() * size * 0.02,
          R * (1.0 + rnd() * 0.12),
          sway2,
          rnd() * Math.PI * 2
        );

        // c·ª•m tr∆∞·ªõc (to nh·∫•t)
        drawBushBlob(
          cx - size * 0.08,
          cy,
          R * (1.2 + rnd() * 0.15),
          sway1,
          rnd() * Math.PI * 2
        );

        // c·ª•m tr∆∞·ªõc ph·ª• (b·ªï sung cho r·∫≠m)
        drawBushBlob(
          cx + size * 0.04,
          cy + size * 0.05,
          R * (1.1 + rnd() * 0.1),
          sway1,
          rnd() * Math.PI * 2
        );
      }
      function drawKameBullet(b) {
        const v = dirToVec(b.dir);
        const coreR = Math.max(2.8, (b.width || 4) * 0.9);
        const core = b.core || "#ffffff";
        const aura = b.aura || "rgba(255,255,255,0.5)";
        const tNow = performance.now() / 1000;

        ctx.save();

        // === 1) N·ªî NH·ªé ·ªû MI·ªÜNG N√íNG (0 -> ~0.15s) ===
        if ((b.age || 0) < 0.15) {
          const k = 1 - b.age / 0.15; // 1 -> 0
          const cx = b.x - v.x * 10;
          const cy = b.y - v.y * 10;
          const R = coreR * (2.2 + 5.0 * k); // n·ªü to l√∫c ƒë·∫ßu r·ªìi t·∫Øt

          // qu·∫ßng n·ªï m·ªÅm
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R);
          g.addColorStop(0.0, "rgba(255,255,255,0.95)");
          g.addColorStop(0.4, core);
          g.addColorStop(1.0, "rgba(255,255,255,0.00)");
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(cx, cy, R, 0, Math.PI * 2);
          ctx.fill();

          // v√≤ng shock s√°ng tho√°ng
          ctx.globalAlpha = 0.55 * k;
          ctx.strokeStyle = aura;
          ctx.lineWidth = 2 + 3 * k;
          ctx.beginPath();
          ctx.arc(cx, cy, R * 0.7, 0, Math.PI * 2);
          ctx.stroke();
          ctx.globalAlpha = 1;
        }

        // === 2) VI√äN ƒê·∫†N NƒÇNG L∆Ø·ª¢NG (kh√¥ng c√≥ ƒë∆∞·ªùng d√†i) ===
        // halo
        const haloR = coreR * 2.4;
        const gHalo = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, haloR);
        gHalo.addColorStop(0.0, "rgba(255,255,255,0.90)");
        gHalo.addColorStop(0.4, core);
        gHalo.addColorStop(1.0, "rgba(255,255,255,0.00)");
        ctx.fillStyle = gHalo;
        ctx.beginPath();
        ctx.arc(b.x, b.y, haloR, 0, Math.PI * 2);
        ctx.fill();

        // l√µi
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(b.x, b.y, coreR * 0.75, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = core;
        ctx.beginPath();
        ctx.arc(b.x, b.y, coreR * 0.55, 0, Math.PI * 2);
        ctx.fill();

        // ƒëu√¥i r·∫•t ng·∫Øn ƒë·ªÉ th·∫•y h∆∞·ªõng bay
        const tailL = 8;
        const gTail = ctx.createLinearGradient(
          b.x - v.x * tailL,
          b.y - v.y * tailL,
          b.x,
          b.y
        );
        gTail.addColorStop(0, "rgba(255,255,255,0.0)");
        gTail.addColorStop(1, core);
        ctx.strokeStyle = gTail;
        ctx.lineWidth = coreR * 0.7;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(b.x - v.x * tailL, b.y - v.y * tailL);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();

        // === 3) G·ª¢N S√ìNG LAN T·ªéA QUANH VI√äN ƒê·∫†N ===
        const period = 0.9; // 1 g·ª£n / 0.9s
        const rings = 2; // 2 v√≤ng ch·∫°y ƒëu·ªïi
        for (let i = 0; i < rings; i++) {
          const ph = ((tNow + i * period * 0.5) % period) / period; // 0..1
          const R = coreR * (1.6 + ph * 4.2);
          const a = (1 - ph) * 0.5;
          ctx.globalAlpha = a;
          ctx.strokeStyle = aura;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(b.x, b.y, R, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;

        ctx.restore();
      }
      function addScorch(x, y) {
        S.scorches.push({
          x,
          y,
          r0: 8 + Math.random() * 6,
          r1: 22 + Math.random() * 10,
          life: 6.0, // t·ªìn t·∫°i ~6 gi√¢y
          maxLife: 6.0,
          rot: Math.random() * Math.PI * 2,
        });
      }

      function drawScorches(dt) {
        if (!S.scorches) S.scorches = [];
        for (let i = S.scorches.length - 1; i >= 0; i--) {
          const s = S.scorches[i];
          s.life -= dt;
          if (s.life <= 0) {
            S.scorches.splice(i, 1);
            continue;
          }

          const k = Math.max(0, s.life / s.maxLife); // 1..0
          const R = s.r0 + (s.r1 - s.r0) * (1 - k);

          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.rotate(s.rot);

          // qu·∫ßng ch√°y ƒëen ‚Üí m·ªù d·∫ßn, l√µi xanh-l·ª•c/x√°m r·∫•t nh·∫π
          const g = ctx.createRadialGradient(0, 0, 0, 0, 0, R);
          g.addColorStop(0.0, "rgba(60,80,60," + 0.25 * k + ")"); // xanh l·ª•c x√°m (x√°c xe)
          g.addColorStop(0.45, "rgba(30,30,30," + 0.45 * k + ")"); // ƒëen
          g.addColorStop(1.0, "rgba(0,0,0,0)");
          ctx.globalAlpha = 0.9 * k;
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(0, 0, R, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }
      // === Brick Wall (classic red, white mortar, stagger 1/2) ===
      // V·∫Ω theo WORLD COORD (kh√¥ng "ƒë·ª©t" ·ªü bi√™n tile)
      // === Brick Wall (warm red, beige mortar, cinematic shading) ===
      function drawClassicBrickWallTile(gx, gy, x, y, size) {
        const rx = x,
          ry = y,
          rw = size,
          rh = size;

        // TUNE: t·ªâ l·ªá g·∫°ch & m·∫°ch v·ªØa
        const BRICK_H = Math.floor(size * 0.42);
        const BRICK_W = Math.floor(size * 1.05);
        const MORTAR = Math.max(1, Math.round(size * 0.03)); // m·ªèng, kh√¥ng l√≥a

        // M√†u **·∫•m** ƒë·ªÉ h√†i h√≤a n·ªÅn c√°t
        const COL = {
          mortar: "#e6d6bf", // v·ªØa be ·∫•m (thay v√¨ tr·∫Øng g·∫Øt)
          brickA: "#cf6841", // ƒë·ªè cam ·∫•m h∆°n
          brickB: "#b35433", // ƒë·ªè n√¢u tr·∫ßm
          aoTop: "rgba(0,0,0,0.08)", // ambient occlusion m√©p
          aoBot: "rgba(0,0,0,0.12)",
          aoSide: "rgba(0,0,0,0.06)",
          hi: "rgba(255,255,255,0.05)", // highlight r·∫•t nh·∫π
          veinL: "rgba(255,255,255,0.06)", // v√¢n s√°ng
          veinD: "rgba(0,0,0,0.06)", // v√¢n t·ªëi
        };

        // N·ªÅn v·ªØa (ƒë·ªÉ c√°c ƒë∆∞·ªùng m·∫°ch n·ªëi li·ªÅn gi·ªØa tile)
        ctx.fillStyle = COL.mortar;
        ctx.fillRect(rx, ry, rw, rh);

        // H√†ng/c·ªôt theo WORLD-SPACE ƒë·ªÉ kh√¥ng "ƒë·ª©t" ·ªü bi√™n tile
        const firstRowY = ry - (ry % (BRICK_H + MORTAR));
        for (let by = firstRowY; by < ry + rh; by += BRICK_H + MORTAR) {
          const rowIndex = Math.floor(by / (BRICK_H + MORTAR));
          const half = Math.floor((BRICK_W + MORTAR) / 2);
          const rowOffset = rowIndex & 1 ? half : 0;
          const firstColX = rx - ((rx - rowOffset) % (BRICK_W + MORTAR));

          for (let bx = firstColX; bx < rx + rw; bx += BRICK_W + MORTAR) {
            const gx0 = Math.max(bx, rx);
            const gy0 = Math.max(by, ry);
            const gx1 = Math.min(bx + BRICK_W, rx + rw);
            const gy1 = Math.min(by + BRICK_H, ry + rh);
            const w = gx1 - gx0,
              h = gy1 - gy0;
            if (w <= 0 || h <= 0) continue;

            // Hai t√¥ng g·∫°ch xen k·∫Ω + gradient d·ªçc nh·∫π
            const base =
              ((Math.floor(bx / (BRICK_W + MORTAR)) + rowIndex) & 1) === 0
                ? COL.brickA
                : COL.brickB;
            const grad = ctx.createLinearGradient(gx0, gy0, gx0, gy0 + h);
            grad.addColorStop(0.0, base);
            grad.addColorStop(0.6, base);
            grad.addColorStop(1.0, shade(base, -12));
            ctx.fillStyle = grad;
            ctx.fillRect(gx0, gy0, w, h);

            // AO (inner-shadow) s√°t m√©p ƒë·ªÉ ‚ÄúƒÉn‚Äù v√†o v·ªØa ‚Üí nh√¨n d√≠nh v√† c√≥ chi·ªÅu s√¢u
            ctx.fillStyle = COL.aoTop;
            ctx.fillRect(gx0, gy0, w, 1);
            ctx.fillStyle = COL.aoBot;
            ctx.fillRect(gx0, gy0 + h - 1, w, 1);
            ctx.fillStyle = COL.aoSide;
            ctx.fillRect(gx0, gy0, 1, h);
            ctx.fillStyle = COL.aoSide;
            ctx.fillRect(gx0 + w - 1, gy0, 1, h);

            // Highlight vi·ªÅn tr√™n r·∫•t m·ªèng (gi·∫£ bevel) ‚Äî tinh t·∫ø, tr√°nh ‚Äúkim lo·∫°i‚Äù
            ctx.fillStyle = COL.hi;
            ctx.fillRect(gx0, gy0 + 1, w, 1);

            // V√¢n g·∫°ch nh·∫π (2 ƒë∆∞·ªùng u·ªën nh·ªè trong th√¢n)
            ctx.lineWidth = 1;
            // v√¢n s√°ng
            ctx.strokeStyle = COL.veinL;
            ctx.beginPath();
            ctx.moveTo(gx0 + 2, gy0 + Math.round(h * 0.35));
            ctx.lineTo(
              gx0 + w - 2,
              gy0 + Math.round(h * (0.35 + 0.02 * (rowIndex & 1 ? -1 : 1)))
            );
            ctx.stroke();
            // v√¢n t·ªëi
            ctx.strokeStyle = COL.veinD;
            ctx.beginPath();
            ctx.moveTo(gx0 + 2, gy0 + Math.round(h * 0.68));
            ctx.lineTo(
              gx0 + w - 2,
              gy0 + Math.round(h * (0.68 + 0.02 * (rowIndex & 1 ? 1 : -1)))
            );
            ctx.stroke();
          }
        }
      }

      // (gi·ªØ helper shade() b·∫°n ƒë√£ c√≥)

      // Utility: ch·ªânh s√°ng/t·ªëi 1 m√†u hex (delta: √¢m=s·∫´m, d∆∞∆°ng=s√°ng)
      function shade(hex, delta) {
        // #rrggbb
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        if (!m) return hex;
        const clamp = (v) => Math.max(0, Math.min(255, v));
        const r = clamp(parseInt(m[1], 16) + delta);
        const g = clamp(parseInt(m[2], 16) + delta);
        const b = clamp(parseInt(m[3], 16) + delta);
        return (
          "#" +
          r.toString(16).padStart(2, "0") +
          g.toString(16).padStart(2, "0") +
          b.toString(16).padStart(2, "0")
        );
      }

      // === Riveted Steel Wall (blue-grey plates, seams, rivets, scratches) ===
      function drawRivetedSteelTile(gx, gy, x, y, size) {
        const rx = x,
          ry = y,
          rw = size,
          rh = size;

        // B·∫£ng m√†u (xanh-x√°m l·∫°nh, kh√°c r√µ t∆∞·ªùng g·∫°ch ·∫•m)
        const COL = {
          baseTop: "#5f6c79",
          baseBot: "#3e4853",
          seam: "#2b3139", // ƒë∆∞·ªùng r√°p t·∫•m
          hi: "rgba(255,255,255,0.08)", // highlight m·ªèng
          ao: "rgba(0,0,0,0.20)", // inner shadow m√©p
          rivetHi: "rgba(255,255,255,0.35)",
          rivetLo: "rgba(0,0,0,0.40)",
          scratchL: "rgba(255,255,255,0.05)",
          scratchD: "rgba(0,0,0,0.08)",
        };

        // N·ªÅn th√©p (gradient d·ªçc nh·∫π)
        const g = ctx.createLinearGradient(rx, ry, rx, ry + rh);
        g.addColorStop(0.0, COL.baseTop);
        g.addColorStop(1.0, COL.baseBot);
        ctx.fillStyle = g;
        ctx.fillRect(rx, ry, rw, rh);

        // Pattern panel theo WORLD-SPACE (l·∫∑p theo kh·ªëi 2x2 tile)
        const PW = size * 2,
          PH = size * 2;
        const p0x = Math.floor(rx / PW) * PW;
        const p0y = Math.floor(ry / PH) * PH;

        // Danh s√°ch "t·∫•m th√©p" trong 1 pattern 2x2 tile (t·ªça ƒë·ªô t∆∞∆°ng ƒë·ªëi)
        // (b·ªë c·ª•c ki·ªÉu ·∫£nh m·∫´u: mi·∫øng to/nh·ªè xen k·∫Ω t·∫°o m·∫°ch "ziczac")
        const R = [
          // row tr√™n
          { x: 0, y: 0, w: size * 1.0, h: size * 0.7 },
          { x: size * 1.0, y: 0, w: size * 1.0, h: size * 0.45 },
          { x: size * 1.0, y: size * 0.45, w: size * 1.0, h: size * 0.25 },
          // row d∆∞·ªõi
          { x: 0, y: size * 0.7, w: size * 0.9, h: size * 0.55 },
          { x: size * 0.9, y: size * 0.7, w: size * 1.1, h: size * 0.35 },
          { x: size * 1.2, y: size * 1.05, w: size * 0.8, h: size * 0.55 },
          { x: 0, y: size * 1.25, w: size * 0.8, h: size * 0.75 },
          { x: size * 0.8, y: size * 1.25, w: size * 1.2, h: size * 0.75 },
        ];

        // V·∫Ω c√°c t·∫•m trong v√πng tile hi·ªán t·∫°i (d·ªãch pattern theo p0x/p0y)
        for (let ty = p0y; ty < ry + rh; ty += PH) {
          for (let tx = p0x; tx < rx + rw; tx += PW) {
            for (const r of R) {
              const px0 = tx + r.x,
                py0 = ty + r.y;
              const px1 = px0 + r.w,
                py1 = py0 + r.h;

              // c·∫Øt theo tile
              const gx0 = Math.max(px0, rx);
              const gy0 = Math.max(py0, ry);
              const gx1 = Math.min(px1, rx + rw);
              const gy1 = Math.min(py1, ry + rh);
              const w = gx1 - gx0,
                h = gy1 - gy0;
              if (w <= 0 || h <= 0) continue;

              drawSteelPlateRect(gx0, gy0, w, h, COL);
            }
          }
        }

        // V·∫Ω ƒë∆∞·ªùng r√°p (seam) tr√™n bi√™n c√°c t·∫•m ‚Äì m·∫£nh & ƒë·∫≠m h∆°n n·ªÅn
        ctx.strokeStyle = COL.seam;
        ctx.lineWidth = 2;

        for (let ty = p0y; ty < ry + rh; ty += PH) {
          for (let tx = p0x; tx < rx + rw; tx += PW) {
            for (const r of R) {
              const px0 = tx + r.x,
                py0 = ty + r.y;
              const px1 = px0 + r.w,
                py1 = py0 + r.h;

              // Ch·ªâ k·∫ª seam n·∫±m b√™n trong tile hi·ªán t·∫°i
              // Tr√™n
              if (py0 >= ry && py0 <= ry + rh) {
                const sx0 = Math.max(px0, rx),
                  sx1 = Math.min(px1, rx + rw);
                if (sx1 > sx0) {
                  ctx.beginPath();
                  ctx.moveTo(sx0, py0);
                  ctx.lineTo(sx1, py0);
                  ctx.stroke();
                }
              }
              // D∆∞·ªõi
              if (py1 >= ry && py1 <= ry + rh) {
                const sx0 = Math.max(px0, rx),
                  sx1 = Math.min(px1, rx + rw);
                if (sx1 > sx0) {
                  ctx.beginPath();
                  ctx.moveTo(sx0, py1);
                  ctx.lineTo(sx1, py1);
                  ctx.stroke();
                }
              }
              // Tr√°i
              if (px0 >= rx && px0 <= rx + rw) {
                const sy0 = Math.max(py0, ry),
                  sy1 = Math.min(py1, ry + rh);
                if (sy1 > sy0) {
                  ctx.beginPath();
                  ctx.moveTo(px0, sy0);
                  ctx.lineTo(px0, sy1);
                  ctx.stroke();
                }
              }
              // Ph·∫£i
              if (px1 >= rx && px1 <= rx + rw) {
                const sy0 = Math.max(py0, ry),
                  sy1 = Math.min(py1, ry + rh);
                if (sy1 > sy0) {
                  ctx.beginPath();
                  ctx.moveTo(px1, sy0);
                  ctx.lineTo(px1, sy1);
                  ctx.stroke();
                }
              }
            }
          }
        }

        // ƒêinh t√°n ·ªü c√°c g√≥c/mid-edge c√°c t·∫•m (nh·ªè, n·ªïi nh·∫π)
        for (let ty = p0y; ty < ry + rh; ty += PH) {
          for (let tx = p0x; tx < rx + rw; tx += PW) {
            for (const r of R) {
              const corners = [
                [tx + r.x + 3, ty + r.y + 3],
                [tx + r.x + r.w - 3, ty + r.y + 3],
                [tx + r.x + 3, ty + r.y + r.h - 3],
                [tx + r.x + r.w - 3, ty + r.y + r.h - 3],
              ];
              for (const [cx, cy] of corners) {
                if (cx < rx || cx > rx + rw || cy < ry || cy > ry + rh)
                  continue;
                drawRivet(cx, cy, 2, COL);
              }
            }
          }
        }
      }

      // V·∫Ω 1 t·∫•m th√©p (bevel + x∆∞·ªõc nh·∫π)
      function drawSteelPlateRect(x, y, w, h, COL) {
        // Inner bevel (AO)
        ctx.fillStyle = COL.ao;
        ctx.fillRect(x, y, w, 1);
        ctx.fillRect(x, y + h - 1, w, 1);
        ctx.fillRect(x, y, 1, h);
        ctx.fillRect(x + w - 1, y, 1, h);

        // Highlight m·ªÅm b√™n trong (tr√°nh b√≥ng ki·ªÉu g∆∞∆°ng)
        ctx.fillStyle = COL.hi;
        ctx.fillRect(x + 1, y + 1, w - 2, 1);
        ctx.fillRect(x + 1, y + 1, 1, h - 2);

        // V·ªát x∆∞·ªõc r·∫•t nh·∫π (2 ƒë∆∞·ªùng s√°ng/t·ªëi)
        if (w > 8 && h > 8) {
          ctx.strokeStyle = COL.scratchL;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x + 3, y + Math.round(h * 0.35));
          ctx.lineTo(x + w - 3, y + Math.round(h * 0.35));
          ctx.stroke();

          ctx.strokeStyle = COL.scratchD;
          ctx.beginPath();
          ctx.moveTo(x + 3, y + Math.round(h * 0.7));
          ctx.lineTo(x + w - 3, y + Math.round(h * 0.7));
          ctx.stroke();
        }
      }

      // ƒêinh t√°n (n·ªïi nh·∫π b·∫±ng 2 v√≤ng ƒë·ªìng t√¢m)
      function drawRivet(cx, cy, r, COL) {
        // b√≥ng
        ctx.fillStyle = COL.rivetLo;
        ctx.beginPath();
        ctx.arc(cx + 0.5, cy + 0.7, r, 0, Math.PI * 2);
        ctx.fill();
        // highlight
        ctx.fillStyle = COL.rivetHi;
        ctx.beginPath();
        ctx.arc(cx - 0.4, cy - 0.4, r * 0.55, 0, Math.PI * 2);
        ctx.fill();
      }

      function draw() {
        ctx.clearRect(0, 0, W, H);
        // N·ªÅn ƒë·∫•t tr·∫≠n ƒë·ªãa (pattern n√¢u ƒë·∫•t)
        ctx.fillStyle = getGroundPattern(ctx);
        ctx.fillRect(0, 0, W, H);
        drawCurvedRiverRibbon();
        drawRiverLabel();
        drawBridges();
        drawScorches(S.lastTime ? 0 : 0);
        for (let gy = 0; gy < GRID; gy++) {
          for (let gx = 0; gx < GRID; gx++) {
            const t = S.map[gy][gx];
            const x = gx * TILE,
              y = gy * TILE;
            if (t.type === "empty") {
              if (((gx + gy) & 1) === 0) {
                ctx.globalAlpha = 0.1; // c≈©: 0.06
                ctx.fillStyle = "#a57c52";
                ctx.fillRect(x, y, TILE, TILE);
                ctx.globalAlpha = 1;
              }
            } else if (t.type === "brick") {
              drawClassicBrickWallTile(gx, gy, x, y, TILE);
            } else if (t.type === "steel") {
              drawRivetedSteelTile(gx, gy, x, y, TILE);
            } else if (t.type === "river") {
              // River tile no longer painted per-tile (drawn by ribbon). Do nothing here.
            } else if (t.type === "base") {
              drawThanhCoFlat(x, y, TILE, S.base.alive);
            }
          }
        }
        // items
        for (const it of S.items) {
          if (!it.active) continue;
          const x = it.x - TILE / 2,
            y = it.y - TILE / 2;
          if (it.kind === "star") {
            // === HI·ªÜU ·ª®NG √ÅNH S√ÅNG CHO STAR R∆†I ===
            if (it.falling) {
              // V·ªát s√°ng khi r∆°i
              const trailLength = Math.min(40, it.fallSpeed * 0.15);
              if (trailLength > 5) {
                const gradient = ctx.createLinearGradient(
                  it.x,
                  it.y - trailLength,
                  it.x,
                  it.y
                );
                gradient.addColorStop(0, "rgba(255, 215, 0, 0)");
                gradient.addColorStop(1, "rgba(255, 215, 0, 0.8)");
                ctx.fillStyle = gradient;
                ctx.fillRect(it.x - 2, it.y - trailLength, 4, trailLength);
              }
            }

            // √Ånh s√°ng l·∫•p l√°nh
            const time = performance.now() / 500;
            const glow = 0.7 + 0.3 * Math.sin(time);
            ctx.save();
            ctx.globalAlpha = glow;
            ctx.shadowColor = "#ffd700";
            ctx.shadowBlur = it.falling ? 20 : 10;

            // √Åp d·ª•ng rotation cho star
            ctx.translate(it.x, it.y);
            ctx.rotate(it.rotation || 0);

            ctx.fillStyle = "#ffd700";
            drawStar(0, 0, 5, TILE / 2 - 4, 6); // v·∫Ω t·∫°i g·ªëc (0,0) v√¨ ƒë√£ translate
            ctx.fill();
            ctx.strokeStyle = "#9e7b00";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
          } else {
            // Shield (thay Shovel) v·ªõi rotation ‚Äî gi·ªØ nguy√™n xoay/animation
            // ctx.save();
            // ctx.translate(it.x, it.y);
            // ctx.rotate(it.rotation || 0);
            // drawShieldIcon(TILE * 0.9);
            // ctx.restore();

            // Shield d√πng ·∫¢NH (gi·ªØ nguy√™n xoay)
            ctx.save();
            ctx.translate(it.x, it.y);
            ctx.rotate(it.rotation || 0);

            // Lazy-load 1 l·∫ßn, g·∫Øn v√†o S ƒë·ªÉ t√°i d√πng
            if (!S._shieldImg) {
              S._shieldImg = new Image();
              S._shieldImg.src = "khien.png"; // ƒë·∫∑t file c·∫°nh index.html
            }

            // V·∫Ω khi ·∫£nh s·∫µn s√†ng; ch∆∞a s·∫µn s√†ng th√¨ b·ªè qua frame n√†y
            const s = TILE * 1.0; // k√≠ch c·ª° icon
            if (S._shieldImg.complete && S._shieldImg.naturalWidth > 0) {
              // Gi·ªØ t·ªâ l·ªá ·∫£nh g·ªëc (vu√¥ng). Centered ƒë·ªÉ xoay ƒë·∫πp
              ctx.imageSmoothingEnabled = true;
              ctx.drawImage(S._shieldImg, -s / 2, -s / 2, s, s);
            }
            ctx.restore();
          }
        }
        // planes
        for (const p of S.planes) drawPlane(p);
        for (const b of S.bombs) drawBomb(b);

        // bullets
        for (const b of S.bullets) {
          if (!b.active) continue;
          drawKameBullet(b);
        }

        // smokes (player only) ‚Äî v·∫Ω d∆∞·ªõi xe
        for (const s of S.smokes) {
          const k = Math.max(0, s.life / s.max); // 1 -> 0
          const baseR = Math.max(2, s.r);
          const R = baseR * (1 + 0.6 * (1 - k)); // l·ªõn d·∫ßn √≠t h∆°n
          const squash = 1 + 0.25 * (1 - k); // elip nh·∫π

          // L·ªõp 1: l√µi t·ªëi
          ctx.globalAlpha = 0.18 + 0.22 * k;
          ctx.fillStyle = s.c0 + (0.8 * k + 0.1) + ")";
          ctx.beginPath();
          ctx.ellipse(s.x, s.y, R * 0.7, R * 0.7 * squash, 0, 0, Math.PI * 2);
          ctx.fill();

          // L·ªõp 2: x√°m xanh
          ctx.globalAlpha = 0.15 + 0.18 * k;
          ctx.fillStyle = s.c1 + (0.5 * k + 0.1) + ")";
          ctx.beginPath();
          ctx.ellipse(s.x, s.y, R, R * squash, 0, 0, Math.PI * 2);
          ctx.fill();

          // L·ªõp 3: vi·ªÅn s√°ng nh·∫°t
          ctx.globalAlpha = 0.1 + 0.12 * k;
          ctx.fillStyle = s.c2 + 0.35 * k + ")";
          ctx.beginPath();
          ctx.ellipse(
            s.x,
            s.y,
            R * 1.25,
            R * 1.25 * squash,
            0,
            0,
            Math.PI * 2
          );
          ctx.fill();

          ctx.globalAlpha = 1;
        }

        // tanks (x√≠ch h√†i h√≤a + th√¢n + th√°p ph√°o tr√≤n + decal Vi·ªát Nam cho player)
        for (const t of S.tanks) {
          if (!t.active) continue;

          const x = t.x - t.size / 2;
          const y = t.y - t.size / 2;

          // NEW: nh·∫•p nh√°y khi player v·ª´a spawn t·∫°i Th√†nh C·ªï
          if (
            t.isPlayer &&
            t.spawnInvulnUntil &&
            performance.now() < t.spawnInvulnUntil
          ) {
            const period = t.spawnBlinkPeriod || 120; // ms
            if (Math.floor(performance.now() / period) % 2 === 0) {
              continue; // b·ªè v·∫Ω frame n√†y ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng ch·ªõp t·∫Øt
            }
          }

          // m√†u th√¢n cho ƒë·ªãch (player s·∫Ω override b·∫±ng VN_COL)
          const enemyBody = t.kind === "armored" ? "#ff6b6b" : "#f0ad4e";

          // ---------- X√çCH (m√†u h√†i h√≤a) ----------
          const trackW = Math.max(6, Math.floor(t.size * 0.28));
          const rungStep = 6;
          // Cho c·∫£m gi√°c cu·ªôn ƒë√∫ng h∆∞·ªõng theo dir
          const basePhase = (t.trackPhase || 0) % 1;
          const dirSign = t.dir === "up" || t.dir === "left" ? -1 : 1;
          const rungOffset =
            ((dirSign > 0 ? basePhase : 1 - basePhase) * rungStep) | 0;

          // B·∫£ng m√†u theo lo·∫°i tank + m√†u xen k·∫Ω r√µ r√†ng cho player
          let trackBase, trackRung, trackAlt;
          if (t.isPlayer) {
            trackBase = VN_COL.dark; // n·ªÅn bƒÉng x√≠ch
            trackRung = "#0f2a12";
            trackAlt = "#8fd78a";
          } else if (t.kind === "armored") {
            // th√©p t·ªëi
            trackBase = "#2a2c31";
            trackRung = "#4b4f57";
            trackAlt = "#3a3e45";
          } else {
            // basic: n√¢u ƒë·∫•t h·ª£p th√¢n v√†ng-cam
            trackBase = "#5a4a2a";
            trackRung = "#40351f";
            trackAlt = "#6c5a36";
          }

          ctx.fillStyle = trackBase;
          if (t.isPlayer) {
            trackBase = VN_COL.dark;
            trackRung = "#0f2a12"; // t·ªëi h∆°n
            trackAlt = "#8fd78a"; // s√°ng h∆°n ‚Äì t∆∞∆°ng ph·∫£n r√µ
          } else if (t.kind === "armored") {
            // gi√°p d√†y: t√¥ng th√©p t·ªëi
            trackBase = "#2a2c31";
            trackRung = "#4b4f57";
            trackAlt = "#3a3e45";
          } else {
            // basic: t√¥ng n√¢u ƒë·∫•t h·ª£p th√¢n v√†ng-cam
            trackBase = "#5a4a2a";
            trackRung = "#40351f";
            trackAlt = "#6c5a36";
          }

          ctx.fillStyle = trackBase;

          if (t.dir === "up" || t.dir === "down") {
            // d·ªçc: x√≠ch tr√°i/ph·∫£i
            ctx.fillRect(x, y, trackW, t.size);
            ctx.fillRect(x + t.size - trackW, y, trackW, t.size);

            // rƒÉng x√≠ch cu·ªôn (xen k·∫Ω + clip ƒë·ªÉ kh√¥ng l√≥ ra ngo√†i)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, trackW, t.size); // x√≠ch tr√°i
            ctx.rect(x + t.size - trackW, y, trackW, t.size); // x√≠ch ph·∫£i
            ctx.clip();

            for (
              let i = 0, yy = y - rungOffset;
              yy < y + t.size + rungStep;
              yy += rungStep, i++
            ) {
              ctx.fillStyle = i & 1 ? trackRung : trackAlt;
              ctx.fillRect(x + 1, yy, trackW - 2, 3); // tr√°i (rƒÉng d√†y h∆°n)
              ctx.fillRect(x + t.size - trackW + 1, yy, trackW - 2, 3); // ph·∫£i
            }
            ctx.restore();
          } else {
            // ngang: x√≠ch tr√™n/d∆∞·ªõi
            ctx.fillRect(x, y, t.size, trackW);
            ctx.fillRect(x, y + t.size - trackW, t.size, trackW);

            // rƒÉng x√≠ch cu·ªôn (xen k·∫Ω + clip ƒë·ªÉ kh√¥ng l√≥ ra ngo√†i)
            ctx.save();
            ctx.beginPath();
            ctx.rect(x, y, t.size, trackW); // x√≠ch tr√™n
            ctx.rect(x, y + t.size - trackW, t.size, trackW); // x√≠ch d∆∞·ªõi
            ctx.clip();

            for (
              let i = 0, xx = x - rungOffset;
              xx < x + t.size + rungStep;
              xx += rungStep, i++
            ) {
              ctx.fillStyle = i & 1 ? trackRung : trackAlt;
              ctx.fillRect(xx, y + 1, 3, trackW - 2); // tr√™n (rƒÉng d√†y h∆°n)
              ctx.fillRect(xx, y + t.size - trackW + 1, 3, trackW - 2); // d∆∞·ªõi
            }
            ctx.restore();
          }

          // ---------- TH√ÇN ----------
          const gap = Math.max(4, Math.floor(t.size * 0.14)); // l·ªÅ v√†o th√¢n
          const bx = x + gap,
            by = y + gap,
            bw = t.size - gap * 2,
            bh = bw;

          if (t.isPlayer) {
            // n·ªÅn olive VN + r·∫±n ri
            ctx.fillStyle = VN_COL.green;
            roundRect(bx, by, bw, bh, 6);
            ctx.fill();

            ctx.fillStyle = VN_COL.green2; // 2 m·∫£ng r·∫±n ri nh·∫π
            ctx.beginPath();
            ctx.moveTo(bx, by + bh * 0.26);
            ctx.lineTo(bx + bw * 0.52, by + bh * 0.06);
            ctx.lineTo(bx + bw * 0.84, by + bh * 0.2);
            ctx.lineTo(bx + bw * 0.34, by + bh * 0.4);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(bx + bw * 0.12, by + bh * 0.7);
            ctx.lineTo(bx + bw * 0.68, by + bh * 0.48);
            ctx.lineTo(bx + bw * 0.94, by + bh * 0.63);
            ctx.lineTo(bx + bw * 0.36, by + bh * 0.86);
            ctx.closePath();
            ctx.fill();

            // ----- Ng√¥i sao cƒÉn gi·ªØa th√¢n -----
            const cx = bx + bw * 0.5;
            const cy = by + bh * 0.5;
            const starOuter = Math.max(6, Math.floor(t.size * 0.12));
            const starInner = Math.max(3, Math.floor(starOuter * 0.45));
            // vi·ªÅn t·ªëi m·∫£nh ƒë·ªÉ n·ªïi b·∫≠t
            ctx.fillStyle = VN_COL.dark;
            drawStar(cx, cy, 5, starOuter + 2, starInner + 1);
            ctx.fill();
            // sao v√†ng
            ctx.fillStyle = VN_COL.star;
            drawStar(cx, cy, 5, starOuter, starInner);
            ctx.fill();

            // ----- C·ªôt c·ªù ph√≠a sau‚Äìtr√°i (v·ªã tr√≠ h·ª£p l√Ω h∆°n) -----
            const poleH = Math.max(18, Math.floor(t.size * 0.85));
            const poleX = bx + bw * 0.12; // s√°t g√≥c sau‚Äìtr√°i
            const poleY = by - Math.max(6, Math.floor(t.size * 0.18));
            ctx.strokeStyle = "#bfbfbf";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(poleX, poleY);
            ctx.lineTo(poleX, poleY - poleH);
            ctx.stroke();

            const time = performance.now() / 900; // c√πng t·ªëc ƒë·ªô v·ªõi th√†nh c·ªï
            const fw = Math.max(16, Math.floor(t.size * 0.9));
            const fh = Math.max(10, Math.floor(t.size * 0.45));
            const fx = poleX + 2;
            const fy = poleY - poleH; // y l√† m√©p tr√™n c·ªßa c·ªù

            // G·ªçi h√†m c·ªù chung v·ªõi c√πng tham s·ªë chuy·ªÉn ƒë·ªông
            drawFlag(ctx, fx, fy, fw, fh, time, 3, 2);
          } else {
            // ƒë·ªãch gi·ªØ m√†u c≈©
            ctx.fillStyle = enemyBody;
            roundRect(bx, by, bw, bh, 6);
            ctx.fill();
          }

          // ---------- TH√ÅP PH√ÅO TR√íN + N√íNG S√öNG ----------
          // th√°p ph√°o n·∫±m tr√™n th√¢n, n√≤ng xu·∫•t ph√°t t·ª´ t√¢m th√°p ph√°o (t.x, t.y)
          const turretOuter = t.size * 0.28;
          const turretInner = t.size * 0.22;
          const barrelLen = Math.max(12, Math.floor(t.size * 0.35));

          // vi·ªÅn t·ªëi c·ªßa th√°p
          ctx.fillStyle = t.isPlayer ? VN_COL.dark : "#333";
          ctx.beginPath();
          ctx.arc(t.x, t.y, turretOuter, 0, Math.PI * 2);
          ctx.fill();
          // m·∫∑t th√°p
          ctx.fillStyle = t.isPlayer ? VN_COL.green : enemyBody;
          ctx.beginPath();
          ctx.arc(t.x, t.y, turretInner, 0, Math.PI * 2);
          ctx.fill();

          // n√≤ng s√∫ng (d√†y nh·∫π ƒë·ªÉ c√¢n ƒë·ªëi)
          ctx.fillStyle = "#2e2e2e";
          const bwid = 6;
          if (t.dir === "up")
            ctx.fillRect(t.x - bwid / 2, t.y - barrelLen, bwid, barrelLen);
          if (t.dir === "down")
            ctx.fillRect(t.x - bwid / 2, t.y, bwid, barrelLen);
          if (t.dir === "left")
            ctx.fillRect(t.x - barrelLen, t.y - bwid / 2, barrelLen, bwid);
          if (t.dir === "right")
            ctx.fillRect(t.x, t.y - bwid / 2, barrelLen, bwid);
          // ch·ªõp tr·∫Øng khi tr√∫ng ƒë·∫°n (120ms)
          if (t._flashUntil && performance.now() < t._flashUntil) {
            const k = (t._flashUntil - performance.now()) / 120; // 0..1
            ctx.save();
            ctx.globalAlpha = 0.35 * Math.max(0, k);
            ctx.fillStyle = "#ffffff";
            roundRect(bx, by, bw, bh, 6);
            ctx.fill();
            ctx.restore();
          }

          // ---------- HP b·∫±ng icon tr√°i tim g·∫Øn ·ªü ƒêU√îI xe ----------
          {
            const n = Math.max(0, t.hp | 0);
            if (n > 0) {
              const SIZ = Math.max(5, Math.floor(t.size * 0.18)); // k√≠ch c·ª° tim
              const GAP = Math.max(2, Math.floor(SIZ * 0.25)); // kho·∫£ng c√°ch
              const fill = "#e74c3c",
                stroke = "#5a1a1a";

              if (t.dir === "up" || t.dir === "down") {
                // ƒêu√¥i ·ªü c·∫°nh ƒë·ªëi di·ªán v·ªõi h∆∞·ªõng n√≤ng; x·∫øp theo TR·ª§C NGANG
                const baseY = t.dir === "up" ? y + t.size - SIZ - 2 : y + 2;
                const totalW = n * SIZ + (n - 1) * GAP;
                let cx = t.x - totalW / 2 + SIZ / 2;
                for (let i = 0; i < n; i++, cx += SIZ + GAP)
                  drawHeartSmall(cx, baseY, SIZ, fill, stroke);
              } else {
                // left/right: ƒëu√¥i ·ªü c·∫°nh tr√°i/ph·∫£i; x·∫øp theo TR·ª§C D·ªåC
                const baseXLeft = x + 2;
                const baseXRight = x + t.size - SIZ - 2;
                const cxTail =
                  (t.dir === "right" ? baseXLeft : baseXRight) + SIZ / 2;
                const totalH = n * SIZ + (n - 1) * GAP;
                let cy = t.y - totalH / 2;
                for (let i = 0; i < n; i++, cy += SIZ + GAP)
                  drawHeartSmall(cxTail, cy, SIZ, fill, stroke);
              }
            }
          }
        }

        // explosions (theo kind)
        for (const e of S.explosions) {
          const age = performance.now() - e.start;
          const t = Math.min(1, age / e.duration); // 0..1

          if (e.kind === "hit") {
            // --- n·ªï nh·ªè nh∆∞ng d√†y: nhi·ªÅu v√≤ng ch·ªìng nhau + l√µi s√°ng ---
            const R = 6 + 18 * t; // b√°n k√≠nh lan nhanh
            const a = 1 - t;

            // 1) l√µi s√°ng nh·ªè
            const g = ctx.createRadialGradient(
              e.x,
              e.y,
              0,
              e.x,
              e.y,
              R * 0.6
            );
            g.addColorStop(0, "rgba(255,255,255,0.95)");
            g.addColorStop(0.6, "rgba(255,220,120,0.9)");
            g.addColorStop(1, "rgba(255,255,255,0)");
            ctx.globalAlpha = 0.9 * a;
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(e.x, e.y, R * 0.6, 0, Math.PI * 2);
            ctx.fill();

            // 2) 2 v√≤ng shock ƒë·∫≠m
            ctx.globalAlpha = 0.75 * a;
            ctx.strokeStyle = "rgba(255,230,140,0.9)";
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.arc(e.x, e.y, R * 0.75, 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalAlpha = 0.55 * a;
            ctx.strokeStyle = "rgba(255,255,255,0.9)";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(e.x, e.y, R, 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalAlpha = 1;
            continue;
          }

          if (e.kind === "tankGrey") {
            // --- n·ªï bom x√°m: kh√≥i x√°m lan nh·ªè ---
            const R = 10 + 22 * t; // nh·ªè h∆°n n·ªï m·∫∑c ƒë·ªãnh
            const g = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, R);
            g.addColorStop(0.0, "rgba(235,235,235,0.95)");
            g.addColorStop(0.35, "rgba(180,180,180,0.75)");
            g.addColorStop(1.0, "rgba(120,120,120,0.0)");
            ctx.globalAlpha = 1 - t * 0.9;
            ctx.fillStyle = g;
            ctx.beginPath();
            ctx.arc(e.x, e.y, R, 0, Math.PI * 2);
            ctx.fill();

            // vi·ªÅn kh√≥i ƒë·∫≠m m·ªù d·∫ßn
            ctx.globalAlpha = 0.35 * (1 - t);
            ctx.strokeStyle = "rgba(80,80,80,0.9)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, R * 0.85, 0, Math.PI * 2);
            ctx.stroke();

            ctx.globalAlpha = 1;
            continue;
          }

          // --- m·∫∑c ƒë·ªãnh (c≈©) ---
          const maxR = e.big ? 32 : 16;
          const r = maxR * t;
          ctx.globalAlpha = 1 - t;
          ctx.fillStyle = e.big ? "#ff9933" : "#ffff66";
          ctx.beginPath();
          ctx.arc(e.x, e.y, r, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // particles (v√≤ng xung k√≠ch, tia l·ª≠a, fireball, debris)
        drawParticles();

        // bushes on top
        for (const key of S.bushSet) {
          const [gx, gy] = key.split(",").map(Number);
          const x = gx * TILE,
            y = gy * TILE;
          drawBushTile(gx, gy, x, y, TILE);
        }
        if (S.status === "won" || S.status === "lost") {
          /* overlay already shows text */
        }
      }

      // ===== Buttons =====
      btnStart.onclick = () => {
        ensureAudio();
        AUDIO.ctx.resume(); // Chrome y√™u c·∫ßu c√≥ gesture
        resetGame();
      };
      btnRestart.onclick = () => {
        ensureAudio();
        AUDIO.ctx.resume();
        resetGame();
      };
      // ===== Sound UI init & events =====
      // Pre-draw map for menu
      setupLevel();
      draw();
      requestAnimationFrame(loop);
    })();
  </script>
</body>

</html>